"use strict";
var request = require('request');
var Q = require('q');
function getDataSourcesFromQuery(query) {
    var queryDataSource = query.dataSource;
    if (!queryDataSource)
        return [];
    if (typeof queryDataSource === 'string') {
        return [queryDataSource];
    }
    else if (queryDataSource.type === "union") {
        return queryDataSource.dataSources;
    }
    else {
        throw new Error("unsupported datasource type '" + queryDataSource.type + "'");
    }
}
function basicLocator(host) {
    var hostnamePort = host.split(':');
    var hostname;
    var port;
    if (hostnamePort.length > 1) {
        hostname = hostnamePort[0];
        port = Number(hostnamePort[1]);
    }
    else {
        hostname = hostnamePort[0];
        port = 8082;
    }
    return function () {
        return Q({
            hostname: hostname,
            port: port
        });
    };
}
function basicUrlBuilder(location) {
    return "http://" + location.hostname + ":" + (location.port || 8082);
}
function requestAsPromise(param) {
    var deferred = (Q.defer());
    request(param, function (err, response, body) {
        if (err) {
            deferred.reject(err);
        }
        else {
            deferred.resolve({
                response: response,
                body: body
            });
        }
    });
    return deferred.promise;
}
function failIfNoDatasource(url, query, timeout) {
    return requestAsPromise({
        method: "GET",
        url: url + "datasources",
        json: true,
        timeout: timeout
    })
        .then(function (result) {
        var response = result.response;
        var body = result.body;
        var err;
        if (response.statusCode !== 200 || !Array.isArray(body)) {
            err = new Error("Bad status code (" + response.statusCode + ") in datasource listing");
            err.query = query;
            throw err;
        }
        if (getDataSourcesFromQuery(query).every(function (dataSource) { return body.indexOf(dataSource) < 0; })) {
            err = new Error("No such datasource");
            err.query = query;
            throw err;
        }
        return null;
    }, function (err) {
        err.query = query;
        throw err;
    });
}
function druidRequesterFactory(parameters) {
    var locator = parameters.locator, host = parameters.host, timeout = parameters.timeout, urlBuilder = parameters.urlBuilder, requestDecorator = parameters.requestDecorator;
    if (!locator) {
        if (!host)
            throw new Error("must have a `host` or a `locator`");
        locator = basicLocator(host);
    }
    if (!urlBuilder) {
        urlBuilder = basicUrlBuilder;
    }
    return function (req) {
        var context = req.context || {};
        var query = req.query;
        var queryType = query.queryType, intervals = query.intervals;
        if (intervals === "1000-01-01/1000-01-02") {
            return Q([]);
        }
        var url;
        return locator()
            .then(function (location) {
            if (timeout != null) {
                query.context || (query.context = {});
                query.context.timeout = timeout;
            }
            url = urlBuilder(location);
            var options;
            if (queryType === "status") {
                options = {
                    method: "GET",
                    url: url + '/status',
                    json: true,
                    timeout: timeout
                };
            }
            else {
                url += '/druid/v2/';
                if (queryType === "introspect" || queryType === "sourceList") {
                    options = {
                        method: "GET",
                        url: url + "datasources/" + (queryType === "introspect" ? getDataSourcesFromQuery(query)[0] : ''),
                        json: true,
                        timeout: timeout
                    };
                }
                else {
                    options = {
                        method: "POST",
                        url: url + (context['pretty'] ? "?pretty" : ""),
                        json: query,
                        timeout: timeout
                    };
                }
            }
            if (requestDecorator) {
                var decorationPromise = requestDecorator({
                    method: options.method,
                    url: options.url,
                    query: query
                }, context['decoratorContext']);
                if (decorationPromise) {
                    return Q(decorationPromise).then(function (decoration) {
                        if (decoration.headers) {
                            options.headers = decoration.headers;
                        }
                        return options;
                    });
                }
            }
            return options;
        })
            .then(requestAsPromise)
            .then(function (result) {
            var response = result.response;
            var body = result.body;
            var err;
            if (response.statusCode !== 200) {
                if (body && body.error === "Query timeout") {
                    err = new Error("timeout");
                }
                else {
                    var message;
                    if (body && typeof body.error === 'string') {
                        message = body.errorClass || body.error;
                        if (typeof body.errorMessage === 'string') {
                            message = message + ": " + body.errorMessage;
                        }
                    }
                    else {
                        message = "Bad status code (" + response.statusCode + ")";
                    }
                    err = new Error(message);
                    err.query = query;
                    if (body && typeof body.host === 'string')
                        err.host = body.host;
                }
                throw err;
            }
            if (typeof body !== 'object') {
                throw new Error("bad response");
            }
            if (queryType === "introspect") {
                if (Array.isArray(body.dimensions) && !body.dimensions.length &&
                    Array.isArray(body.metrics) && !body.metrics.length) {
                    return failIfNoDatasource(url, query, timeout).then(function () {
                        err = new Error("Can not use GET route, data is probably in a real-time node or more than a two weeks old. Try segmentMetadata instead.");
                        err.query = query;
                        throw err;
                    });
                }
            }
            else if (queryType !== "sourceList" && queryType !== "status") {
                if (Array.isArray(body) && !body.length) {
                    return failIfNoDatasource(url, query, timeout).then(function () {
                        return [];
                    });
                }
            }
            return body;
        }, function (err) {
            if (err.message === "ETIMEDOUT")
                err = new Error("timeout");
            err.query = query;
            throw err;
        });
    };
}
exports.druidRequesterFactory = druidRequesterFactory;
