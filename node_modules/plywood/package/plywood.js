(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.plywood = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
module.exports = function(plywood, chronoshift) {
  /*
   * Generated by PEG.js 0.9.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  function peg$parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        parser  = this,

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = function(ex) { return ex; },
        peg$c1 = function(head, tail) { return naryExpressionFactory('or', head, tail); },
        peg$c2 = function(head, tail) { return naryExpressionFactory('and', head, tail); },
        peg$c3 = function(not, ex) {
              if (not) ex = ex.not();
              return ex;
            },
        peg$c4 = function(lhs, rest) {
              if (!rest) return lhs;
              return lhs[rest[0]](rest[2]);
            },
        peg$c5 = { type: "other", description: "Comparison" },
        peg$c6 = "==",
        peg$c7 = { type: "literal", value: "==", description: "\"==\"" },
        peg$c8 = function() { return 'is'; },
        peg$c9 = "!=",
        peg$c10 = { type: "literal", value: "!=", description: "\"!=\"" },
        peg$c11 = function() { return 'isnt'; },
        peg$c12 = "in",
        peg$c13 = { type: "literal", value: "in", description: "\"in\"" },
        peg$c14 = function() { return 'in'; },
        peg$c15 = "<=",
        peg$c16 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c17 = function() { return 'lessThanOrEqual'; },
        peg$c18 = ">=",
        peg$c19 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c20 = function() { return 'greaterThanOrEqual'; },
        peg$c21 = "<",
        peg$c22 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c23 = function() { return 'lessThan'; },
        peg$c24 = ">",
        peg$c25 = { type: "literal", value: ">", description: "\">\"" },
        peg$c26 = function() { return 'greaterThan'; },
        peg$c27 = function(head, tail) { return naryExpressionFactory('concat', head, tail); },
        peg$c28 = function(head, tail) { return naryExpressionWithAltFactory('add', head, tail, '-', 'subtract'); },
        peg$c29 = "+",
        peg$c30 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c31 = "-",
        peg$c32 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c33 = function(op) { return op; },
        peg$c34 = function(head, tail) { return naryExpressionWithAltFactory('multiply', head, tail, '/', 'divide'); },
        peg$c35 = "*",
        peg$c36 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c37 = "/",
        peg$c38 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c39 = function(ex, rhs) {
              if (rhs) ex = ex.power(rhs[1]);
              return ex;
            },
        peg$c40 = "^",
        peg$c41 = { type: "literal", value: "^", description: "\"^\"" },
        peg$c42 = function(op, ex) {
              // !Number is to make sure that -3 parses as literal(-3) and not literal(3).negate()
              var negEx = ex.negate(); // Always negate (even with +) just to make sure it is possible
              return op === '-' ? negEx : ex;
            },
        peg$c43 = function(ex) { return ex.absolute(); },
        peg$c44 = function(lhs, tail) {
              if (!tail.length) return lhs;
              var operand = lhs;
              for (var i = 0, n = tail.length; i < n; i++) {
                var part = tail[i];
                var op = part[1];
                if (!possibleCalls[op]) error('no such call: ' + op);
                var params = part[3] || [];
                operand = operand[op].apply(operand, params);
              }
              return operand;
            },
        peg$c45 = function(head, tail) { return makeListMap1(head, tail); },
        peg$c46 = "ply",
        peg$c47 = { type: "literal", value: "ply", description: "\"ply\"" },
        peg$c48 = function() { return ply(); },
        peg$c49 = "$",
        peg$c50 = { type: "literal", value: "$", description: "\"$\"" },
        peg$c51 = ":",
        peg$c52 = { type: "literal", value: ":", description: "\":\"" },
        peg$c53 = function(name) { return RefExpression.parse(name); },
        peg$c54 = "{",
        peg$c55 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c56 = /^[^}]/,
        peg$c57 = { type: "class", value: "[^}]", description: "[^}]" },
        peg$c58 = "}",
        peg$c59 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c60 = function(value) { return r(value); },
        peg$c61 = { type: "other", description: "StringSet" },
        peg$c62 = function(head, tail) { return Set.fromJS(makeListMap1(head, tail)); },
        peg$c63 = { type: "other", description: "NumberSet" },
        peg$c64 = { type: "other", description: "String" },
        peg$c65 = "'",
        peg$c66 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c67 = function(chars) { return chars; },
        peg$c68 = function(chars) { error("Unmatched single quote"); },
        peg$c69 = "\"",
        peg$c70 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c71 = function(chars) { error("Unmatched double quote"); },
        peg$c72 = "null",
        peg$c73 = { type: "literal", value: "null", description: "\"null\"" },
        peg$c74 = function() { return null; },
        peg$c75 = "false",
        peg$c76 = { type: "literal", value: "false", description: "\"false\"" },
        peg$c77 = function() { return false; },
        peg$c78 = "true",
        peg$c79 = { type: "literal", value: "true", description: "\"true\"" },
        peg$c80 = function() { return true; },
        peg$c81 = "not",
        peg$c82 = { type: "literal", value: "not", description: "\"not\"" },
        peg$c83 = "and",
        peg$c84 = { type: "literal", value: "and", description: "\"and\"" },
        peg$c85 = "or",
        peg$c86 = { type: "literal", value: "or", description: "\"or\"" },
        peg$c87 = "++",
        peg$c88 = { type: "literal", value: "++", description: "\"++\"" },
        peg$c89 = /^[a-z_]/i,
        peg$c90 = { type: "class", value: "[a-z_]i", description: "[a-z_]i" },
        peg$c91 = { type: "other", description: "Number" },
        peg$c92 = function(n) { return parseFloat(n); },
        peg$c93 = /^[1-9]/,
        peg$c94 = { type: "class", value: "[1-9]", description: "[1-9]" },
        peg$c95 = ".",
        peg$c96 = { type: "literal", value: ".", description: "\".\"" },
        peg$c97 = "e",
        peg$c98 = { type: "literal", value: "e", description: "\"e\"" },
        peg$c99 = /^[+\-]/,
        peg$c100 = { type: "class", value: "[+-]", description: "[+-]" },
        peg$c101 = /^[0-9]/,
        peg$c102 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c103 = { type: "other", description: "[" },
        peg$c104 = "[",
        peg$c105 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c106 = { type: "other", description: "]" },
        peg$c107 = "]",
        peg$c108 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c109 = { type: "other", description: "(" },
        peg$c110 = "(",
        peg$c111 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c112 = { type: "other", description: ")" },
        peg$c113 = ")",
        peg$c114 = { type: "literal", value: ")", description: "\")\"" },
        peg$c115 = ",",
        peg$c116 = { type: "literal", value: ",", description: "\",\"" },
        peg$c117 = "|",
        peg$c118 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c119 = { type: "other", description: "Name" },
        peg$c120 = function(name) { return name; },
        peg$c121 = /^[a-z0-9_]/i,
        peg$c122 = { type: "class", value: "[a-z0-9_]i", description: "[a-z0-9_]i" },
        peg$c123 = { type: "other", description: "TypeName" },
        peg$c124 = /^[A-Z_\/]/,
        peg$c125 = { type: "class", value: "[A-Z_/]", description: "[A-Z_/]" },
        peg$c126 = { type: "other", description: "NotSQuote" },
        peg$c127 = /^[^']/,
        peg$c128 = { type: "class", value: "[^']", description: "[^']" },
        peg$c129 = { type: "other", description: "NotDQuote" },
        peg$c130 = /^[^"]/,
        peg$c131 = { type: "class", value: "[^\"]", description: "[^\"]" },
        peg$c132 = { type: "other", description: "Whitespace" },
        peg$c133 = /^[ \t\r\n]/,
        peg$c134 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function error(message) {
      throw peg$buildException(
        message,
        null,
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
          p, ch;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column,
          seenCR: details.seenCR
        };

        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, found, location) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new peg$SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOrExpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOrExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseAndExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseOrToken();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseAndExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseOrToken();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseAndExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAndExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseNotExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseAndToken();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseNotExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseAndToken();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseNotExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNotExpression() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseNotToken();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseComparisonExpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseComparisonExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseConcatExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseComparisonOp();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseConcatExpression();
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c4(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseComparisonOp() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c6) {
        s1 = peg$c6;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c7); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c8();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c9) {
          s1 = peg$c9;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c12) {
            s1 = peg$c12;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c15) {
              s1 = peg$c15;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c17();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c18) {
                s1 = peg$c18;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c19); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c20();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 60) {
                  s1 = peg$c21;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c22); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c23();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 62) {
                    s1 = peg$c24;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c25); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c26();
                  }
                  s0 = s1;
                }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }

      return s0;
    }

    function peg$parseConcatExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseAdditiveExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseConcatToken();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseAdditiveExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseConcatToken();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseAdditiveExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c27(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAdditiveExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseMultiplicativeExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseAdditiveOp();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseMultiplicativeExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseAdditiveOp();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseMultiplicativeExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c28(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAdditiveOp() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c29;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 43) {
          s3 = peg$c29;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c30); }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMultiplicativeExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseExponentialExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseMultiplicativeOp();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseExponentialExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseMultiplicativeOp();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseExponentialExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMultiplicativeOp() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c37;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseExponentialExpression() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseUnaryExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseExponentialOp();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseExponentialExpression();
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c39(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseExponentialOp() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 94) {
        s1 = peg$c40;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUnaryExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseAdditiveOp();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseNumber();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCallChainExpression();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c42(s1, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseCallChainExpression();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsePipe();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseOrExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsePipe();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c43(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseCallChainExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseBasicExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseDot();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseName();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseOpenParen();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseParams();
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parseCloseParen();
                if (s8 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7, s8];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseDot();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseName();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseOpenParen();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseParams();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseCloseParen();
                  if (s8 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7, s8];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c44(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseParams() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseOrExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseComma();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseOrExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseComma();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseOrExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c45(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseBasicExpression() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseOpenParen();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseOrExpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCloseParen();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c0(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c46) {
          s1 = peg$c46;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c47); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseOpenParen();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseCloseParen();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c48();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseRefExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$parseLiteralExpression();
          }
        }
      }

      return s0;
    }

    function peg$parseRefExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 36) {
        s1 = peg$c49;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = [];
        if (input.charCodeAt(peg$currPos) === 94) {
          s5 = peg$c40;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c41); }
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (input.charCodeAt(peg$currPos) === 94) {
            s5 = peg$c40;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c41); }
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseNamePart();
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 58) {
              s7 = peg$c51;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parseTypeName();
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = input.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c53(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 36) {
          s1 = peg$c49;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c50); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$currPos;
          s4 = [];
          if (input.charCodeAt(peg$currPos) === 94) {
            s5 = peg$c40;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c41); }
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (input.charCodeAt(peg$currPos) === 94) {
              s5 = peg$c40;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c41); }
            }
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s5 = peg$c54;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c55); }
            }
            if (s5 !== peg$FAILED) {
              s6 = [];
              if (peg$c56.test(input.charAt(peg$currPos))) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c57); }
              }
              if (s7 !== peg$FAILED) {
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  if (peg$c56.test(input.charAt(peg$currPos))) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c57); }
                  }
                }
              } else {
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s7 = peg$c58;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c59); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s9 = peg$c51;
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c52); }
                  }
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parseTypeName();
                    if (s10 !== peg$FAILED) {
                      s9 = [s9, s10];
                      s8 = s9;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 === peg$FAILED) {
                    s8 = null;
                  }
                  if (s8 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7, s8];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c53(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseLiteralExpression() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseNullToken();
      if (s1 === peg$FAILED) {
        s1 = peg$parseFalseToken();
        if (s1 === peg$FAILED) {
          s1 = peg$parseTrueToken();
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c60(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNumber();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c60(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseName();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c60(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseString();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c60(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseStringSet();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c60(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseNumberSet();
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c60(s1);
                }
                s0 = s1;
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseStringSet() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseOpenBracket();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseStringOrNull();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parseComma();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseStringOrNull();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parseComma();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseStringOrNull();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCloseBracket();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c62(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }

      return s0;
    }

    function peg$parseStringOrNull() {
      var s0;

      s0 = peg$parseString();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNullToken();
      }

      return s0;
    }

    function peg$parseNumberSet() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseOpenBracket();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNumberOrNull();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parseComma();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseNumberOrNull();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parseComma();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseNumberOrNull();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCloseBracket();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c62(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c63); }
      }

      return s0;
    }

    function peg$parseNumberOrNull() {
      var s0;

      s0 = peg$parseNumber();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNullToken();
      }

      return s0;
    }

    function peg$parseString() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c65;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c66); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNotSQuote();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c65;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c66); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c67(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c65;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c66); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNotSQuote();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c68(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c69;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c70); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNotDQuote();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c69;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c70); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c67(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
              s1 = peg$c69;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c70); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNotDQuote();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c71(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c64); }
      }

      return s0;
    }

    function peg$parseNullToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c72) {
        s1 = peg$c72;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c74();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFalseToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c75) {
        s1 = peg$c75;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c76); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c77();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTrueToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c78) {
        s1 = peg$c78;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c79); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c80();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNotToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c81) {
        s1 = peg$c81;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAndToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c83) {
        s1 = peg$c83;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c84); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOrToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c85) {
        s1 = peg$c85;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c86); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseConcatToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c87) {
        s1 = peg$c87;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseIdentifierPart() {
      var s0;

      if (peg$c89.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c90); }
      }

      return s0;
    }

    function peg$parseNumber() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$parseInt();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseFraction();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseExp();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c92(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c91); }
      }

      return s0;
    }

    function peg$parseInt() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        if (peg$c93.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c94); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDigits();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c31;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDigit();
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseFraction() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s2 = peg$c95;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c96); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDigits();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      return s0;
    }

    function peg$parseExp() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 1).toLowerCase() === peg$c97) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c98); }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c99.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c100); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDigits();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      return s0;
    }

    function peg$parseDigits() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseDigit();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseDigit();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      return s0;
    }

    function peg$parseDigit() {
      var s0;

      if (peg$c101.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c102); }
      }

      return s0;
    }

    function peg$parseOpenBracket() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c104;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c105); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c103); }
      }

      return s0;
    }

    function peg$parseCloseBracket() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 93) {
        s1 = peg$c107;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c108); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c106); }
      }

      return s0;
    }

    function peg$parseOpenParen() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c110;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c111); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c109); }
      }

      return s0;
    }

    function peg$parseCloseParen() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 41) {
        s1 = peg$c113;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c114); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c112); }
      }

      return s0;
    }

    function peg$parseComma() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 44) {
        s1 = peg$c115;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c116); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDot() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c95;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c96); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePipe() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s1 = peg$c117;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c118); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseReservedWord() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c46) {
        s1 = peg$c46;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 5) === peg$c75) {
          s1 = peg$c75;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c76); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c78) {
            s1 = peg$c78;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c79); }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (peg$c89.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c90); }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseName() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseNamePart();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c120(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c119); }
      }

      return s0;
    }

    function peg$parseNamePart() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseReservedWord();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (peg$c89.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c90); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c121.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c122); }
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c121.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c122); }
            }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      return s0;
    }

    function peg$parseTypeName() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c124.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c125); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c124.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c125); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c123); }
      }

      return s0;
    }

    function peg$parseNotSQuote() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c127.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c128); }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c127.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c128); }
        }
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c126); }
      }

      return s0;
    }

    function peg$parseNotDQuote() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c130.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c131); }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c130.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c131); }
        }
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c129); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c133.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c134); }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c133.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c134); }
        }
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c132); }
      }

      return s0;
    }

    // starts with function(plywood, chronoshift)
    var ply = plywood.ply;
    var $ = plywood.$;
    var r = plywood.r;
    var Expression = plywood.Expression;
    var LiteralExpression = plywood.LiteralExpression;
    var RefExpression = plywood.RefExpression;
    var Set = plywood.Set;
    var Action = plywood.Action;

    var possibleCalls = {};
    for (var key in Action.classMap) possibleCalls[key] = 1;
    possibleCalls['negate'] = 1;
    possibleCalls['isnt'] = 1;
    possibleCalls['sqrt'] = 1;
    possibleCalls['custom'] = 1; // back compat

    function makeListMap1(head, tail) {
      return [head].concat(tail.map(function(t) { return t[1] }));
    }

    function naryExpressionFactory(op, head, tail) {
      if (!tail.length) return head;
      return head[op].apply(head, tail.map(function(t) { return t[1]; }));
    }

    function naryExpressionWithAltFactory(op, head, tail, altToken, altOp) {
      if (!tail.length) return head;
      for (var i = 0; i < tail.length; i++) {
        var t = tail[i];
        head = head[t[0] === altToken ? altOp : op].call(head, t[1]);
      }
      return head;
    }



    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(
        null,
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
};

},{}],2:[function(require,module,exports){
"use strict";
module.exports = function(plywood, chronoshift) {
  /*
   * Generated by PEG.js 0.9.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  function peg$parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        parser  = this,

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = function(queryParse) { return queryParse; },
        peg$c1 = function(queryParse) {
              return queryParse;
            },
        peg$c2 = function(ex) {
              return {
                verb: null,
                expression: ex
              }
            },
        peg$c3 = function(ex) {
              return {
                verb: 'SELECT',
                rewrite: 'SHOW',
                database: 'information_schema',
                expression: ex
              };
            },
        peg$c4 = function(like, where) {
              // https://dev.mysql.com/doc/refman/5.7/en/show-variables.html
              var ex = $('GLOBAL_VARIABLES')
              if (like) ex = ex.filter(like($('VARIABLE_NAME')));
              if (where) ex = ex.filter(where);
              return ex
                .apply('Variable_name', $('VARIABLE_NAME'))
                .apply('Value', $('VARIABLE_VALUE'))
                .select('Variable_name', 'Value');
            },
        peg$c5 = function(like) {
              // https://dev.mysql.com/doc/refman/5.0/en/schemata-table.html
              var ex = $('SCHEMATA')
              if (like) ex = ex.filter(like($('SCHEMA_NAME')));
              return ex
                .apply('Database', $('SCHEMA_NAME'))
                .select('Database');
            },
        peg$c6 = function(full, db, like) {
              // https://dev.mysql.com/doc/refman/5.0/en/tables-table.html
              var ex = $('TABLES')
              if (db) ex= ex.filter($('TABLE_SCHEMA').is(r(db[1])));
              if (like) ex = ex.filter(like($('TABLE_NAME')));
              ex = ex
                .apply('Tables_in_database', $('TABLE_NAME'));

              if (full) {
                ex = ex
                  .apply('Table_type', $('TABLE_TYPE'))
                  .select('Tables_in_database', 'Table_type');
              } else {
                ex = ex.select('Tables_in_database');
              }

              return ex;
            },
        peg$c7 = function(full, table, db, like, where) {
              // https://dev.mysql.com/doc/refman/5.0/en/columns-table.html
              var ex = $('COLUMNS').filter($('TABLE_NAME').is(r(table.name)));
              db = db ? db[1] : table.namespace;
              if (db) ex = ex.filter($('TABLE_SCHEMA').is(r(db)));
              if (like) ex = ex.filter(like($('COLUMN_NAME')));
              if (where) ex = ex.filter(where);
              ex = ex
                .apply('Field', $('COLUMN_NAME'))
                .apply('Type', $('COLUMN_TYPE'))
                .apply('Null', $('IS_NULLABLE'))
                .apply('Key', $('COLUMN_KEY'))
                .apply('Default', $('COLUMN_DEFAULT'))
                .apply('Extra', $('EXTRA'))

              if (full) {
                ex = ex
                  .apply('Collation', $('COLLATION_NAME'))
                  .apply('Privileges', $('PRIVILEGES'))
                  .apply('Comment', $('COLUMN_COMMENT'))
                  .select('Field', 'Type', 'Null', 'Key', 'Default', 'Extra', 'Collation', 'Privileges', 'Comment')
              } else {
                ex = ex.select('Field', 'Type', 'Null', 'Key', 'Default', 'Extra')
              }

              return ex;
            },
        peg$c8 = { type: "any", description: "any character" },
        peg$c9 = function(verb, rest) {
              return {
                verb: verb,
                rest: rest
              };
            },
        peg$c10 = function(verb, db) {
              return {
                verb: verb,
                database: db
              };
            },
        peg$c11 = function(table, colRef, wild) {
              var ex = $('COLUMNS').filter($('TABLE_NAME').is(r(table.name)));
              if (table.namespace) ex = ex.filter($('TABLE_SCHEMA').is(r(table.namespace)));
              if (colRef) {
                ex = ex.filter($('COLUMN_NAME').is(r(colRef)));
              } else if (wild) {
                ex = ex.filter($('COLUMN_NAME').match(MatchAction.likeToRegExp(wild)));
              }

              ex = ex
                .apply('Field', $('COLUMN_NAME'))
                .apply('Type', $('COLUMN_TYPE'))
                .apply('Null', $('IS_NULLABLE'))
                .apply('Key', $('COLUMN_KEY'))
                .apply('Default', $('COLUMN_DEFAULT'))
                .apply('Extra', $('EXTRA'))
                .select('Field', 'Type', 'Null', 'Key', 'Default', 'Extra');

              return {
                verb: 'SELECT',
                rewrite: 'DESCRIBE',
                table: table.name,
                database: 'information_schema',
                expression: ex
              };
            },
        peg$c12 = function(verb) { return unsupportedVerbs[verb.toUpperCase()]; },
        peg$c13 = function(verb, rest) {
              return {
                verb: verb.toUpperCase(),
                rest: rest
              };
            },
        peg$c14 = function(distinct, columns, from, where, groupBys, having, orderBy, limit) {
              return {
                verb: 'SELECT',
                expression: constructQuery(distinct, columns, from, where, groupBys, having, orderBy, limit),
                table: getFromTable(from),
                database: getFromDatabase(from)
              };
            },
        peg$c15 = function(distinct, columns, where, groupBys, having, orderBy, limit) { return constructQuery(distinct, columns, null, where, groupBys, having, orderBy, limit); },
        peg$c16 = function() { return '*'; },
        peg$c17 = function(head, tail) { return makeListMap1(head, tail); },
        peg$c18 = function(ex, as) {
              if (as == null) {
                as = text().trim();
                if (as[0] === '`' && as[as.length - 1] === '`') as = as.substr(1, as.length - 2);
              }
              return new ApplyAction({
                name: as,
                expression: ex
              });
            },
        peg$c19 = function(name) { return name; },
        peg$c20 = function(fc) { return fc; },
        peg$c21 = function(subQuery) { return subQuery; },
        peg$c22 = function(filter) { return filter; },
        peg$c23 = function(having) { return new FilterAction({ expression: having }); },
        peg$c24 = function(orderBy, direction, tail) {
              if (tail.length) error('plywood does not currently support multi-column ORDER BYs');
              return new SortAction({ expression: orderBy, direction: direction || 'ascending' });
            },
        peg$c25 = function(a, b) {
              var limit;
              if (b) {
                if (a !== 0) error('can not skip for now');
                limit = b[1];
              } else {
                limit = a;
              }
              return new LimitAction({ limit: limit });
            },
        peg$c26 = ";",
        peg$c27 = { type: "literal", value: ";", description: "\";\"" },
        peg$c28 = function(head, tail) { return naryExpressionFactory('or', head, tail); },
        peg$c29 = function(head, tail) { return naryExpressionFactory('and', head, tail); },
        peg$c30 = function(not, ex) {
              if (not) ex = ex.not();
              return ex;
            },
        peg$c31 = function(ex, rhs) {
              if (rhs) ex = rhs(ex);
              return ex;
            },
        peg$c32 = function(not, rhs) {
              if (!not) return rhs;
              return function(ex) { return rhs(ex).not(); };
            },
        peg$c33 = function(not, rhs) {
              return function(ex) {
                ex = ex.is(rhs);
                if (not) ex = ex.not();
                return ex;
              };
            },
        peg$c34 = function(op, lhs) {
              return function(ex) { return ex[op](lhs); };
            },
        peg$c35 = function(start, end) {
              return function(ex) { return ex.greaterThan(start).and(ex.lessThan(end)); };
            },
        peg$c36 = function(list) {
              return function(ex) { return ex.in(list); };
            },
        peg$c37 = function(string) {
              return function(ex) { return ex.contains(string, 'ignoreCase'); };
            },
        peg$c38 = function(string) {
              return function(ex) { return ex.match(string); };
            },
        peg$c39 = function(string, escape) {
              var escapeStr = escape ? escape[1] : '\\';
              if (escapeStr.length > 1) error('Invalid escape string: ' + escapeStr);
              var regExp = MatchAction.likeToRegExp(string, escapeStr);
              return function(ex) { return ex.match(regExp); };
            },
        peg$c40 = { type: "other", description: "Comparison" },
        peg$c41 = "=",
        peg$c42 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c43 = function() { return 'is'; },
        peg$c44 = "<=>",
        peg$c45 = { type: "literal", value: "<=>", description: "\"<=>\"" },
        peg$c46 = "<>",
        peg$c47 = { type: "literal", value: "<>", description: "\"<>\"" },
        peg$c48 = function() { return 'isnt'; },
        peg$c49 = "!=",
        peg$c50 = { type: "literal", value: "!=", description: "\"!=\"" },
        peg$c51 = "<=",
        peg$c52 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c53 = function() { return 'lessThanOrEqual'; },
        peg$c54 = ">=",
        peg$c55 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c56 = function() { return 'greaterThanOrEqual'; },
        peg$c57 = "<",
        peg$c58 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c59 = function() { return 'lessThan'; },
        peg$c60 = ">",
        peg$c61 = { type: "literal", value: ">", description: "\">\"" },
        peg$c62 = function() { return 'greaterThan'; },
        peg$c63 = function(head, tail) { return naryExpressionWithAltFactory('add', head, tail, '-', 'subtract'); },
        peg$c64 = "+",
        peg$c65 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c66 = "-",
        peg$c67 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c68 = function(op) { return op; },
        peg$c69 = function(head, tail) { return naryExpressionWithAltFactory('multiply', head, tail, '/', 'divide'); },
        peg$c70 = "*",
        peg$c71 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c72 = "/",
        peg$c73 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c74 = function(op, ex) {
              // !Number is to make sure that -3 parses as literal(-3) and not literal(3).negate()
              var negEx = ex.negate(); // Always negate (even with +) just to make sure it is possible
              return op === '-' ? negEx : ex;
            },
        peg$c75 = function(sub) { return sub; },
        peg$c76 = function(distinct, exd) {
              if (!exd) {
                if (distinct) error('COUNT DISTINCT must have an expression');
                return dataRef.count();
              } else if (exd.ex === '*') {
                if (distinct) error('COUNT DISTINCT can not be used with *');
                return exd.data.count();
              } else {
                return distinct ? exd.data.countDistinct(exd.ex) : exd.data.filter(exd.ex.isnt(null)).count()
              }
            },
        peg$c77 = function(fn, distinct, exd) {
              if (distinct) error('can not use DISTINCT for ' + fn + ' aggregator');
              if (exd.ex === '*') error('can not use * for ' + fn + ' aggregator');
              return exd.data[fn](exd.ex);
            },
        peg$c78 = function(distinct, exd, value) {
              if (distinct) error('can not use DISTINCT for quantile aggregator');
              if (exd.ex === '*') error('can not use * for quantile aggregator');
              return exd.data.quantile(exd.ex, value);
            },
        peg$c79 = function(value, filter) {
              var d = dataRef;
              if (filter) d = d.filter(filter);
              return d.customAggregate(value);
            },
        peg$c80 = function(ex, filter) {
              var data = dataRef;
              if (filter) data = data.filter(filter);
              return { ex: ex, data: data };
            },
        peg$c81 = function(fn, params) { return fn.apply(null, params); },
        peg$c82 = function(name) { return fns[name.toUpperCase()]; },
        peg$c83 = function(ref) { return $(ref.name); },
        peg$c84 = function(ns, name) {
              return {
                namespace: ns ? ns[0] : null,
                name: name
              };
            },
        peg$c85 = function(name) { return reserved(name); },
        peg$c86 = function(name) { return name },
        peg$c87 = "`",
        peg$c88 = { type: "literal", value: "`", description: "\"`\"" },
        peg$c89 = /^[^`]/,
        peg$c90 = { type: "class", value: "[^`]", description: "[^`]" },
        peg$c91 = function(type, v) { return r(makeDate(type, v)); },
        peg$c92 = function(v) { return r(undummyNull(v)); },
        peg$c93 = function(head, tail) { return Set.fromJS(makeListMap1(head, tail).map(undummyNull)); },
        peg$c94 = function(head, tail) { return r(Set.fromJS(makeListMap1(head, tail))); },
        peg$c95 = { type: "other", description: "String" },
        peg$c96 = "'",
        peg$c97 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c98 = function(chars) { return chars; },
        peg$c99 = function(chars) { error("Unmatched single quote"); },
        peg$c100 = "\"",
        peg$c101 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c102 = function(chars) { error("Unmatched double quote"); },
        peg$c103 = function(n, unit) { return intervalUnits[unit] },
        peg$c104 = function(n, unit) {
              if (n !== 0) error('only zero intervals supported for now');
              return 0;
            },
        peg$c105 = "null",
        peg$c106 = { type: "literal", value: "NULL", description: "\"NULL\"" },
        peg$c107 = function() { return NULL; },
        peg$c108 = "true",
        peg$c109 = { type: "literal", value: "TRUE", description: "\"TRUE\"" },
        peg$c110 = function() { return true; },
        peg$c111 = "false",
        peg$c112 = { type: "literal", value: "FALSE", description: "\"FALSE\"" },
        peg$c113 = function() { return false; },
        peg$c114 = "select",
        peg$c115 = { type: "literal", value: "SELECT", description: "\"SELECT\"" },
        peg$c116 = function() { return 'SELECT'; },
        peg$c117 = "describe",
        peg$c118 = { type: "literal", value: "DESCRIBE", description: "\"DESCRIBE\"" },
        peg$c119 = "explain",
        peg$c120 = { type: "literal", value: "EXPLAIN", description: "\"EXPLAIN\"" },
        peg$c121 = function() { return 'DESCRIBE'; },
        peg$c122 = "show",
        peg$c123 = { type: "literal", value: "SHOW", description: "\"SHOW\"" },
        peg$c124 = function() { return 'SHOW'; },
        peg$c125 = "set",
        peg$c126 = { type: "literal", value: "SET", description: "\"SET\"" },
        peg$c127 = function() { return 'SET'; },
        peg$c128 = "use",
        peg$c129 = { type: "literal", value: "USE", description: "\"USE\"" },
        peg$c130 = function() { return 'USE'; },
        peg$c131 = "variables",
        peg$c132 = { type: "literal", value: "VARIABLES", description: "\"VARIABLES\"" },
        peg$c133 = "databases",
        peg$c134 = { type: "literal", value: "DATABASES", description: "\"DATABASES\"" },
        peg$c135 = "schemas",
        peg$c136 = { type: "literal", value: "SCHEMAS", description: "\"SCHEMAS\"" },
        peg$c137 = "columns",
        peg$c138 = { type: "literal", value: "COLUMNS", description: "\"COLUMNS\"" },
        peg$c139 = "full",
        peg$c140 = { type: "literal", value: "FULL", description: "\"FULL\"" },
        peg$c141 = "tables",
        peg$c142 = { type: "literal", value: "TABLES", description: "\"TABLES\"" },
        peg$c143 = "global",
        peg$c144 = { type: "literal", value: "GLOBAL", description: "\"GLOBAL\"" },
        peg$c145 = "session",
        peg$c146 = { type: "literal", value: "SESSION", description: "\"SESSION\"" },
        peg$c147 = "from",
        peg$c148 = { type: "literal", value: "FROM", description: "\"FROM\"" },
        peg$c149 = "as",
        peg$c150 = { type: "literal", value: "AS", description: "\"AS\"" },
        peg$c151 = "on",
        peg$c152 = { type: "literal", value: "ON", description: "\"ON\"" },
        peg$c153 = "left",
        peg$c154 = { type: "literal", value: "LEFT", description: "\"LEFT\"" },
        peg$c155 = "inner",
        peg$c156 = { type: "literal", value: "INNER", description: "\"INNER\"" },
        peg$c157 = "join",
        peg$c158 = { type: "literal", value: "JOIN", description: "\"JOIN\"" },
        peg$c159 = "union",
        peg$c160 = { type: "literal", value: "UNION", description: "\"UNION\"" },
        peg$c161 = "where",
        peg$c162 = { type: "literal", value: "WHERE", description: "\"WHERE\"" },
        peg$c163 = "group",
        peg$c164 = { type: "literal", value: "GROUP", description: "\"GROUP\"" },
        peg$c165 = "by",
        peg$c166 = { type: "literal", value: "BY", description: "\"BY\"" },
        peg$c167 = "order",
        peg$c168 = { type: "literal", value: "ORDER", description: "\"ORDER\"" },
        peg$c169 = "having",
        peg$c170 = { type: "literal", value: "HAVING", description: "\"HAVING\"" },
        peg$c171 = "limit",
        peg$c172 = { type: "literal", value: "LIMIT", description: "\"LIMIT\"" },
        peg$c173 = "asc",
        peg$c174 = { type: "literal", value: "ASC", description: "\"ASC\"" },
        peg$c175 = function() { return SortAction.ASCENDING;  },
        peg$c176 = "desc",
        peg$c177 = { type: "literal", value: "DESC", description: "\"DESC\"" },
        peg$c178 = function() { return SortAction.DESCENDING; },
        peg$c179 = "between",
        peg$c180 = { type: "literal", value: "BETWEEN", description: "\"BETWEEN\"" },
        peg$c181 = "in",
        peg$c182 = { type: "literal", value: "IN", description: "\"IN\"" },
        peg$c183 = "is",
        peg$c184 = { type: "literal", value: "IS", description: "\"IS\"" },
        peg$c185 = "like",
        peg$c186 = { type: "literal", value: "LIKE", description: "\"LIKE\"" },
        peg$c187 = "contains",
        peg$c188 = { type: "literal", value: "CONTAINS", description: "\"CONTAINS\"" },
        peg$c189 = "regexp",
        peg$c190 = { type: "literal", value: "REGEXP", description: "\"REGEXP\"" },
        peg$c191 = "escape",
        peg$c192 = { type: "literal", value: "ESCAPE", description: "\"ESCAPE\"" },
        peg$c193 = "not",
        peg$c194 = { type: "literal", value: "NOT", description: "\"NOT\"" },
        peg$c195 = "and",
        peg$c196 = { type: "literal", value: "AND", description: "\"AND\"" },
        peg$c197 = "or",
        peg$c198 = { type: "literal", value: "OR", description: "\"OR\"" },
        peg$c199 = "distinct",
        peg$c200 = { type: "literal", value: "DISTINCT", description: "\"DISTINCT\"" },
        peg$c201 = "count",
        peg$c202 = { type: "literal", value: "COUNT", description: "\"COUNT\"" },
        peg$c203 = function() { return 'count'; },
        peg$c204 = "count_distinct",
        peg$c205 = { type: "literal", value: "COUNT_DISTINCT", description: "\"COUNT_DISTINCT\"" },
        peg$c206 = function() { return 'countDistinct'; },
        peg$c207 = "sum",
        peg$c208 = { type: "literal", value: "SUM", description: "\"SUM\"" },
        peg$c209 = function() { return 'sum'; },
        peg$c210 = "avg",
        peg$c211 = { type: "literal", value: "AVG", description: "\"AVG\"" },
        peg$c212 = function() { return 'average'; },
        peg$c213 = "min",
        peg$c214 = { type: "literal", value: "MIN", description: "\"MIN\"" },
        peg$c215 = function() { return 'min'; },
        peg$c216 = "max",
        peg$c217 = { type: "literal", value: "MAX", description: "\"MAX\"" },
        peg$c218 = function() { return 'max'; },
        peg$c219 = "quantile",
        peg$c220 = { type: "literal", value: "QUANTILE", description: "\"QUANTILE\"" },
        peg$c221 = function() { return 'quantile'; },
        peg$c222 = "custom",
        peg$c223 = { type: "literal", value: "CUSTOM", description: "\"CUSTOM\"" },
        peg$c224 = function() { return 'customAggregate'; },
        peg$c225 = "custom_aggregate",
        peg$c226 = { type: "literal", value: "CUSTOM_AGGREGATE", description: "\"CUSTOM_AGGREGATE\"" },
        peg$c227 = "date",
        peg$c228 = { type: "literal", value: "DATE", description: "\"DATE\"" },
        peg$c229 = function() { return 'd'; },
        peg$c230 = "time",
        peg$c231 = { type: "literal", value: "TIME", description: "\"TIME\"" },
        peg$c232 = function() { return 't'; },
        peg$c233 = "timestamp",
        peg$c234 = { type: "literal", value: "TIMESTAMP", description: "\"TIMESTAMP\"" },
        peg$c235 = function() { return 'ts'; },
        peg$c236 = "d",
        peg$c237 = { type: "literal", value: "D", description: "\"D\"" },
        peg$c238 = "t",
        peg$c239 = { type: "literal", value: "T", description: "\"T\"" },
        peg$c240 = "ts",
        peg$c241 = { type: "literal", value: "TS", description: "\"TS\"" },
        peg$c242 = "interval",
        peg$c243 = { type: "literal", value: "INTERVAL", description: "\"INTERVAL\"" },
        peg$c244 = /^[a-z_]/i,
        peg$c245 = { type: "class", value: "[a-z_]i", description: "[a-z_]i" },
        peg$c246 = { type: "other", description: "Number" },
        peg$c247 = function(n) { return parseFloat(n); },
        peg$c248 = /^[1-9]/,
        peg$c249 = { type: "class", value: "[1-9]", description: "[1-9]" },
        peg$c250 = ".",
        peg$c251 = { type: "literal", value: ".", description: "\".\"" },
        peg$c252 = "e",
        peg$c253 = { type: "literal", value: "e", description: "\"e\"" },
        peg$c254 = /^[+\-]/,
        peg$c255 = { type: "class", value: "[+-]", description: "[+-]" },
        peg$c256 = /^[0-9]/,
        peg$c257 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c258 = { type: "other", description: "(" },
        peg$c259 = "(",
        peg$c260 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c261 = { type: "other", description: ")" },
        peg$c262 = ")",
        peg$c263 = { type: "literal", value: ")", description: "\")\"" },
        peg$c264 = { type: "other", description: "{" },
        peg$c265 = "{",
        peg$c266 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c267 = { type: "other", description: "}" },
        peg$c268 = "}",
        peg$c269 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c270 = ",",
        peg$c271 = { type: "literal", value: ",", description: "\",\"" },
        peg$c272 = { type: "other", description: "Name" },
        peg$c273 = /^[a-z0-9_]/i,
        peg$c274 = { type: "class", value: "[a-z0-9_]i", description: "[a-z0-9_]i" },
        peg$c275 = { type: "other", description: "RelaxedName" },
        peg$c276 = /^[a-z_\-:*\/]/i,
        peg$c277 = { type: "class", value: "[a-z_\\-:*/]i", description: "[a-z_\\-:*/]i" },
        peg$c278 = /^[a-z0-9_\-:*\/]/i,
        peg$c279 = { type: "class", value: "[a-z0-9_\\-:*/]i", description: "[a-z0-9_\\-:*/]i" },
        peg$c280 = { type: "other", description: "NotSQuote" },
        peg$c281 = /^[^']/,
        peg$c282 = { type: "class", value: "[^']", description: "[^']" },
        peg$c283 = { type: "other", description: "NotDQuote" },
        peg$c284 = /^[^"]/,
        peg$c285 = { type: "class", value: "[^\"]", description: "[^\"]" },
        peg$c286 = { type: "other", description: "Whitespace" },
        peg$c287 = /^[ \t\r\n]/,
        peg$c288 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },
        peg$c289 = "/*",
        peg$c290 = { type: "literal", value: "/*", description: "\"/*\"" },
        peg$c291 = "-- ",
        peg$c292 = { type: "literal", value: "-- ", description: "\"-- \"" },
        peg$c293 = "#",
        peg$c294 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c295 = "*/",
        peg$c296 = { type: "literal", value: "*/", description: "\"*/\"" },
        peg$c297 = /^[\n\r]/,
        peg$c298 = { type: "class", value: "[\\n\\r]", description: "[\\n\\r]" },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function error(message) {
      throw peg$buildException(
        message,
        null,
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
          p, ch;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column,
          seenCR: details.seenCR
        };

        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, found, location) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new peg$SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseQuery();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseQueryTerminator();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseQuery() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseSelectQuery();
      if (s1 === peg$FAILED) {
        s1 = peg$parseDescribeQuery();
        if (s1 === peg$FAILED) {
          s1 = peg$parseShowQuery();
          if (s1 === peg$FAILED) {
            s1 = peg$parseSetQuery();
            if (s1 === peg$FAILED) {
              s1 = peg$parseUseQuery();
              if (s1 === peg$FAILED) {
                s1 = peg$parseUnsupportedQuery();
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseOrExpression();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseShowQuery() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseShowToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseShowQueryExpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseShowQueryExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseGlobalToken();
      if (s1 === peg$FAILED) {
        s1 = peg$parseSessionToken();
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseVariablesToken();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseLikeRhs();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseWhereClause();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c4(s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseSchemasToken();
        if (s1 === peg$FAILED) {
          s1 = peg$parseDatabasesToken();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseLikeRhs();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseFullToken();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseTablesToken();
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseFromOrIn();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseRef();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseLikeRhs();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c6(s1, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseFullToken();
            if (s1 === peg$FAILED) {
              s1 = null;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseColumnsToken();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseFromOrIn();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRelaxedNamespacedRef();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$currPos;
                    s6 = peg$parseFromOrIn();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseRef();
                      if (s7 !== peg$FAILED) {
                        s6 = [s6, s7];
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 === peg$FAILED) {
                      s5 = null;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseLikeRhs();
                      if (s6 === peg$FAILED) {
                        s6 = null;
                      }
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseWhereClause();
                        if (s7 === peg$FAILED) {
                          s7 = null;
                        }
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c7(s1, s4, s5, s6, s7);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseFromOrIn() {
      var s0;

      s0 = peg$parseFromToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseInToken();
      }

      return s0;
    }

    function peg$parseSetQuery() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseSetToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = input.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c9(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUseQuery() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseUseToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseRef();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c10(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDescribeQuery() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseDescribeToken();
      if (s1 === peg$FAILED) {
        s1 = peg$parseDescToken();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseRelaxedNamespacedRef();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseRef();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseString();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c11(s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUnsupportedQuery() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseName();
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$c12(s1);
        if (s2) {
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = [];
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c8); }
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = input.substring(s4, peg$currPos);
            } else {
              s4 = s5;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSelectQuery() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseSelectToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDistinctToken();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseColumns();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseFromClause();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseWhereClause();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseGroupByClause();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseHavingClause();
                  if (s7 === peg$FAILED) {
                    s7 = null;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseOrderByClause();
                    if (s8 === peg$FAILED) {
                      s8 = null;
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseLimitClause();
                      if (s9 === peg$FAILED) {
                        s9 = null;
                      }
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c14(s2, s3, s4, s5, s6, s7, s8, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSelectSubQuery() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseSelectToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDistinctToken();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseColumns();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseWhereClause();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseGroupByClause();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseHavingClause();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseOrderByClause();
                  if (s7 === peg$FAILED) {
                    s7 = null;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseLimitClause();
                    if (s8 === peg$FAILED) {
                      s8 = null;
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c15(s2, s3, s4, s5, s6, s7, s8);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseColumns() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseStarToken();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c16();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseColumn();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseComma();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseColumn();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseComma();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseColumn();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c17(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseColumn() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseOrExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseAsOptional();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c18(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAsMandatory() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseAsToken();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseString();
        if (s2 === peg$FAILED) {
          s2 = peg$parseRef();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAsOptional() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseAsToken();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseString();
        if (s2 === peg$FAILED) {
          s2 = peg$parseRef();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFromClause() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseFromToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFromContent();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseAsOptional();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c20(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFromContent() {
      var s0, s1, s2, s3;

      s0 = peg$parseRelaxedNamespacedRef();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseOpenParen();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseSelectQuery();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseCloseParen();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c21(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseWhereClause() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseWhereToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOrExpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c22(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseGroupByClause() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseGroupToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseByToken();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseOrExpression();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parseComma();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseOrExpression();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parseComma();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseOrExpression();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c17(s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseHavingClause() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseHavingToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOrExpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c23(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOrderByClause() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseOrderToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseByToken();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseOrExpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDirection();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              s7 = peg$parseComma();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseOrExpression();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parseDirection();
                  if (s9 === peg$FAILED) {
                    s9 = null;
                  }
                  if (s9 !== peg$FAILED) {
                    s7 = [s7, s8, s9];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$currPos;
                s7 = peg$parseComma();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseOrExpression();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseDirection();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s7 = [s7, s8, s9];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c24(s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDirection() {
      var s0;

      s0 = peg$parseAscToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseDescToken();
      }

      return s0;
    }

    function peg$parseLimitClause() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseLimitToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNumber();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseComma();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseNumber();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseQueryTerminator() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        s1 = peg$c26;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c27); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOrExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseAndExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseOrToken();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseAndExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseOrToken();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseAndExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c28(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAndExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseNotExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseAndToken();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseNotExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseAndToken();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseNotExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c29(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNotExpression() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseNotToken();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseComparisonExpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c30(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseComparisonExpression() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseAdditiveExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseComparisonExpressionRhs();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseComparisonExpressionRhs() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseNotToken();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseComparisonExpressionRhsNotable();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseIsToken();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNotToken();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseAdditiveExpression();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c33(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseComparisonOp();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseAdditiveExpression();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c34(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseComparisonExpressionRhsNotable() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseBetweenToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseAdditiveExpression();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseAndToken();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseAdditiveExpression();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseInToken();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseInSetLiteralExpression();
          if (s2 === peg$FAILED) {
            s2 = peg$parseAdditiveExpression();
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c36(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseContainsToken();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseString();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c37(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseLikeRhs();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseRegExpToken();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseString();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c38(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseLikeRhs() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseLikeToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseString();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseEscapeToken();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseString();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c39(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseComparisonOp() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 61) {
        s1 = peg$c41;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c43();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c44) {
          s1 = peg$c44;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c45); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c43();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c46) {
            s1 = peg$c46;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c47); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c48();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c49) {
              s1 = peg$c49;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c50); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c48();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c51) {
                s1 = peg$c51;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c52); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c53();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c54) {
                  s1 = peg$c54;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c55); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c56();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 60) {
                    s1 = peg$c57;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c58); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c59();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 62) {
                      s1 = peg$c60;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c61); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c62();
                    }
                    s0 = s1;
                  }
                }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }

      return s0;
    }

    function peg$parseAdditiveExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseMultiplicativeExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseAdditiveOp();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseMultiplicativeExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseAdditiveOp();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseMultiplicativeExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c63(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAdditiveOp() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c64;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c66;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 43) {
          s3 = peg$c64;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c65); }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c68(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMultiplicativeExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseUnaryExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseMultiplicativeOp();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseUnaryExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseMultiplicativeOp();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseUnaryExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c69(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMultiplicativeOp() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c70;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c71); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c72;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c73); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c68(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUnaryExpression() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseAdditiveOp();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseNumber();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseBasicExpression();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c74(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseBasicExpression();
      }

      return s0;
    }

    function peg$parseBasicExpression() {
      var s0, s1, s2, s3;

      s0 = peg$parseLiteralExpression();
      if (s0 === peg$FAILED) {
        s0 = peg$parseAggregateExpression();
        if (s0 === peg$FAILED) {
          s0 = peg$parseFunctionCallExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseOpenParen();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseOrExpression();
              if (s2 === peg$FAILED) {
                s2 = peg$parseSelectSubQuery();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseCloseParen();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c75(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parseRefExpression();
            }
          }
        }
      }

      return s0;
    }

    function peg$parseAggregateExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseCountToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOpenParen();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDistinctToken();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseExpressionMaybeFiltered();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseCloseParen();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c76(s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseAggregateFn();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseOpenParen();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDistinctToken();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseExpressionMaybeFiltered();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseCloseParen();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c77(s1, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseQuantileToken();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseOpenParen();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDistinctToken();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseExpressionMaybeFiltered();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseComma();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseNumber();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseCloseParen();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c78(s3, s4, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseCustomAggregateToken();
            if (s1 === peg$FAILED) {
              s1 = peg$parseCustomToken();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseOpenParen();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseString();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseWhereClause();
                  if (s4 === peg$FAILED) {
                    s4 = null;
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseCloseParen();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c79(s3, s4);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseAggregateFn() {
      var s0;

      s0 = peg$parseSumToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseAvgToken();
        if (s0 === peg$FAILED) {
          s0 = peg$parseMinToken();
          if (s0 === peg$FAILED) {
            s0 = peg$parseMaxToken();
            if (s0 === peg$FAILED) {
              s0 = peg$parseCountDistinctToken();
            }
          }
        }
      }

      return s0;
    }

    function peg$parseExpressionMaybeFiltered() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseStarToken();
      if (s1 === peg$FAILED) {
        s1 = peg$parseOrExpression();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseWhereClause();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c80(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunctionCallExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseFn();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOpenParen();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseOrExpression();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseAsMandatory();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$parseParams();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCloseParen();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c81(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFn() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseName();
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$c82(s1);
        if (s2) {
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c82(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseParams() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseParam();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseComma();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseParam();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseComma();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseParam();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c17(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseParam() {
      var s0;

      s0 = peg$parseNumber();
      if (s0 === peg$FAILED) {
        s0 = peg$parseString();
        if (s0 === peg$FAILED) {
          s0 = peg$parseInterval();
          if (s0 === peg$FAILED) {
            s0 = peg$parseOrExpression();
          }
        }
      }

      return s0;
    }

    function peg$parseRefExpression() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseNamespacedRef();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c83(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseRelaxedNamespacedRef() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseRef();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDot();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseRelaxedRef();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c84(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNamespacedRef() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseRef();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDot();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseRef();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c84(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseRelaxedRef() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseRelaxedName();
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$c85(s1);
        if (s2) {
          s2 = peg$FAILED;
        } else {
          s2 = void 0;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c86(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseBacktickRef();
      }

      return s0;
    }

    function peg$parseRef() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseName();
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$c85(s1);
        if (s2) {
          s2 = peg$FAILED;
        } else {
          s2 = void 0;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c86(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseBacktickRef();
      }

      return s0;
    }

    function peg$parseBacktickRef() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 96) {
        s1 = peg$c87;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (peg$c89.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c90); }
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c89.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c90); }
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = input.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 96) {
            s3 = peg$c87;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c88); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c86(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNameOrString() {
      var s0;

      s0 = peg$parseName();
      if (s0 === peg$FAILED) {
        s0 = peg$parseString();
      }

      return s0;
    }

    function peg$parseLiteralExpression() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseOpenCurly();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDToken();
        if (s2 === peg$FAILED) {
          s2 = peg$parseTToken();
          if (s2 === peg$FAILED) {
            s2 = peg$parseTsToken();
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseString();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCloseCurly();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c91(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseDateToken();
        if (s1 === peg$FAILED) {
          s1 = peg$parseTimeToken();
          if (s1 === peg$FAILED) {
            s1 = peg$parseTimestampToken();
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseString();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c91(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseNumber();
          if (s1 === peg$FAILED) {
            s1 = peg$parseString();
            if (s1 === peg$FAILED) {
              s1 = peg$parseSetLiteral();
              if (s1 === peg$FAILED) {
                s1 = peg$parseNullToken();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseTrueToken();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseFalseToken();
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c92(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseSetLiteral() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseOpenCurly();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseStringNumberOrNull();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parseComma();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseStringNumberOrNull();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parseComma();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseStringNumberOrNull();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCloseCurly();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c93(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseStringNumberOrNull() {
      var s0;

      s0 = peg$parseString();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNumber();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNullToken();
        }
      }

      return s0;
    }

    function peg$parseInSetLiteralExpression() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseOpenParen();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseStringOrNumber();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parseComma();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseStringOrNumber();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parseComma();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseStringOrNumber();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCloseParen();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c94(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseStringOrNumber() {
      var s0;

      s0 = peg$parseString();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNumber();
      }

      return s0;
    }

    function peg$parseString() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c96;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c97); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNotSQuote();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c96;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c97); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c98(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c96;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c97); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNotSQuote();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c99(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c100;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c101); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNotDQuote();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c100;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c101); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c98(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
              s1 = peg$c100;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c101); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNotDQuote();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c102(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c95); }
      }

      return s0;
    }

    function peg$parseInterval() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseIntervalToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNumber();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseName();
          if (s3 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s4 = peg$c103(s2, s3);
            if (s4) {
              s4 = void 0;
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c104(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNullToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c105) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c106); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c107();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTrueToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c108) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c109); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c110();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFalseToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c111) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c112); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c113();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSelectToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c114) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c115); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c116();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDescribeToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c117) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c118); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c119) {
          s1 = input.substr(peg$currPos, 7);
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c120); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseShowToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c122) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c123); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c124();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSetToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c125) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c126); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c127();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUseToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c128) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c129); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c130();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseVariablesToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c131) {
        s1 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c132); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDatabasesToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c133) {
        s1 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c134); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSchemasToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c135) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c136); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseColumnsToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c137) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c138); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFullToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c139) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c140); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTablesToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c141) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c142); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseGlobalToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c143) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c144); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSessionToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c145) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c146); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFromToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c147) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c148); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAsToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c149) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c150); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOnToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c151) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c152); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseLeftToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c153) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c154); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseInnerToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c155) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c156); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJoinToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c157) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c158); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUnionToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c159) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c160); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseWhereToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c162); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseGroupToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c163) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c164); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseByToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c165) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c166); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOrderToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c167) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c168); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseHavingToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c169) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c170); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseLimitToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c171) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c172); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAscToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c173) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c174); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c175();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDescToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c176) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c177); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c178();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseBetweenToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c179) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c180); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseInToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c181) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c182); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseIsToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c183) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c184); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseLikeToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c185) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c186); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseContainsToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c187) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c188); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseRegExpToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c189) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c190); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseEscapeToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c191) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c192); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNotToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c193) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c194); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAndToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c195) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c196); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOrToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c197) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c198); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDistinctToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c199) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c200); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseStarToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c70;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c71); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c16();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCountToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c201) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c202); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c203();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCountDistinctToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 14).toLowerCase() === peg$c204) {
        s1 = input.substr(peg$currPos, 14);
        peg$currPos += 14;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c205); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c206();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSumToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c207) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c208); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c209();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAvgToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c210) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c211); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c212();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMinToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c213) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c214); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c215();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMaxToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c216) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c217); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c218();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseQuantileToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c219) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c220); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c221();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCustomToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c222) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c223); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c224();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCustomAggregateToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 16).toLowerCase() === peg$c225) {
        s1 = input.substr(peg$currPos, 16);
        peg$currPos += 16;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c226); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c224();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDateToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c227) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c228); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c229();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTimeToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c230) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c231); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c232();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTimestampToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c233) {
        s1 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c234); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c235();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 1).toLowerCase() === peg$c236) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c237); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c229();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 1).toLowerCase() === peg$c238) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c239); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c232();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTsToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c240) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c241); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c235();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseIntervalToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c242) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c243); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseIdentifierPart() {
      var s0;

      if (peg$c244.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c245); }
      }

      return s0;
    }

    function peg$parseNumber() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$parseInt();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseFraction();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseExp();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c247(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c246); }
      }

      return s0;
    }

    function peg$parseInt() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c66;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        if (peg$c248.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c249); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDigits();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c66;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDigit();
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseFraction() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s2 = peg$c250;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c251); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDigits();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      return s0;
    }

    function peg$parseExp() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 1).toLowerCase() === peg$c252) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c253); }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c254.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c255); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDigits();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      return s0;
    }

    function peg$parseDigits() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseDigit();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseDigit();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      return s0;
    }

    function peg$parseDigit() {
      var s0;

      if (peg$c256.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c257); }
      }

      return s0;
    }

    function peg$parseOpenParen() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c259;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c260); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c258); }
      }

      return s0;
    }

    function peg$parseCloseParen() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 41) {
        s1 = peg$c262;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c263); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c261); }
      }

      return s0;
    }

    function peg$parseOpenCurly() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c265;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c266); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c264); }
      }

      return s0;
    }

    function peg$parseCloseCurly() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 125) {
        s1 = peg$c268;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c269); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c267); }
      }

      return s0;
    }

    function peg$parseComma() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 44) {
        s1 = peg$c270;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c271); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDot() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c250;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c251); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseName() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (peg$c244.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c245); }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        if (peg$c273.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c274); }
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c273.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c274); }
          }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c272); }
      }

      return s0;
    }

    function peg$parseRelaxedName() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (peg$c276.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c277); }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        if (peg$c278.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c279); }
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c278.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c279); }
          }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c275); }
      }

      return s0;
    }

    function peg$parseNotSQuote() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c281.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c282); }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c281.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c282); }
        }
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c280); }
      }

      return s0;
    }

    function peg$parseNotDQuote() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c284.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c285); }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c284.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c285); }
        }
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c283); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c287.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c288); }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$parseSingleLineComment();
        if (s2 === peg$FAILED) {
          s2 = peg$parseInlineComment();
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c287.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c288); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseSingleLineComment();
          if (s2 === peg$FAILED) {
            s2 = peg$parseInlineComment();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c286); }
      }

      return s0;
    }

    function peg$parseInlineComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c289) {
        s1 = peg$c289;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c290); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseCommentTerminator();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseCommentTerminator();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseCommentTerminator();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSingleLineComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c291) {
        s1 = peg$c291;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c292); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c293;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c294); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseLineTerminator();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseLineTerminator();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCommentTerminator() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c295) {
        s0 = peg$c295;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c296); }
      }

      return s0;
    }

    function peg$parseLineTerminator() {
      var s0;

      if (peg$c297.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c298); }
      }

      return s0;
    }

    // starts with function(plywood, chronoshift)
    var ply = plywood.ply;
    var $ = plywood.$;
    var r = plywood.r;
    var Expression = plywood.Expression;
    var FilterAction = plywood.FilterAction;
    var ApplyAction = plywood.ApplyAction;
    var SortAction = plywood.SortAction;
    var LimitAction = plywood.LimitAction;
    var MatchAction = plywood.MatchAction;

    var Timezone = chronoshift.Timezone;

    var Set = plywood.Set;

    var dataRef = $('data');
    var NULL = {}; // A dummy for null

    function undummyNull(x) {
      return x === NULL ? null : x;
    }

    // See here: https://www.drupal.org/node/141051
    var reservedWords = {
      ALL: 1, AND: 1, AS: 1, ASC: 1,
      BETWEEN: 1, BY: 1,
      CONTAINS: 1, CREATE: 1,
      DELETE: 1, DESC: 1, DESCRIBE: 1, DISTINCT: 1, DROP: 1,
      EXISTS: 1, EXPLAIN: 1, ESCAPE: 1,
      FALSE: 1, FROM: 1,
      GROUP: 1,
      HAVING: 1,
      IN: 1, INNER: 1, INSERT: 1, INTO: 1, IS: 1,
      JOIN: 1,
      LEFT: 1, LIKE: 1, LIMIT: 1, LOOKUP: 1,
      MATCH: 1,
      NOT: 1, NULL: 1,
      ON: 1, OR: 1, ORDER: 1,
      REPLACE: 1, REGEXP: 1,
      SELECT: 1, SET: 1, SHOW: 1,
      TABLE: 1, TRUE: 1,
      UNION: 1, UPDATE: 1,
      VALUES: 1,
      WHERE: 1
    };

    var unsupportedVerbs = {
      ALTER: 1,
      CALL: 1,
      CREATE: 1,
      DEALLOCATE: 1,
      DELETE: 1,
      DO: 1,
      DROP: 1,
      EXECUTE: 1,
      HANDLER: 1,
      INSERT: 1,
      KILL: 1,
      LOAD: 1,
      LOCK: 1,
      PREPARE: 1,
      RENAME: 1,
      REPLACE: 1,
      SAVEPOINT: 1,
      START: 1,
      TRUNCATE: 1,
      UNLOCK: 1,
      UPDATE: 1
    };

    var intervalUnits = {
      MICROSECOND: 1,
      SECOND: 1,
      MINUTE: 1,
      HOUR: 1,
      DAY: 1,
      WEEK: 1,
      MONTH: 1,
      QUARTER: 1,
      YEAR: 1
    }

    var dateFormats = {
      '%Y-%m-%d %H:%i:%s': 'PT1S',
      '%Y-%m-%d %H:%i:00': 'PT1M',
      '%Y-%m-%d %H:00:00': 'PT1H',
      '%Y-%m-%d': 'P1D',
      '%Y-%m-01': 'P1M',
      '%Y-01-01': 'P1Y',
    };


    var castTypes = {
      CHAR: 'STRING',
      SIGNED: 'NUMBER'
    }

    function upgrade(v) {
      if (!Expression.isExpression(v)) return r(v);
      return v;
    }

    var notImplemented = function() { error('not implemented yet'); };
    var fns = {
      ABSOLUTE: function(op) { return upgrade(op).absolute(); },
      OVERLAP: function(op, ex) { return upgrade(op).overlap(ex); },
      SQRT: function(op) { return upgrade(op).power(0.5); },
      EXP: function(ex) { return r(Math.E).power(ex); },
      POWER: function(op, ex) { return upgrade(op).power(ex); },
      NOW: function() { return r(new Date()); },
      CURDATE: function() { return r(chronoshift.day.floor(new Date(), Timezone.UTC)); },
      CUSTOM_TRANSFORM: function(op, fn) { return upgrade(op).customTransform(fn); },
      FALLBACK: function(op, ex) { return upgrade(op).fallback(ex); },
      MATCH: function(op, reg) { return upgrade(op).match(reg); },
      EXTRACT: function(op, reg) { return upgrade(op).extract(reg); },
      CONCAT: function() { return Expression.concat(Array.prototype.map.call(arguments, upgrade)); },
      SUBSTRING: function(op, i, n) { return upgrade(op).substr(i, n); },
      UPPER: function(op) { return upgrade(op).transformCase('upperCase'); },
      LOWER: function(op) { return upgrade(op).transformCase('lowerCase'); },
      LENGTH: function(op) { return upgrade(op).length(); },
      LOCATE: function(op, ex) { return upgrade(op).indexOf(ex).add(1); },
      TIME_FLOOR: function(op, d, tz) { return upgrade(op).timeFloor(d, tz); },
      TIME_SHIFT: function(op, d, s, tz) { return upgrade(op).timeShift(d, s, tz); },
      TIME_RANGE: function(op, d, s, tz) { return upgrade(op).timeRange(d, s, tz); },
      TIME_BUCKET: function(op, d, tz) { return upgrade(op).timeBucket(d, tz); },
      NUMBER_BUCKET: function(op, s, o) { return upgrade(op).numberBucket(s, o); },
      TIME_PART: function(op, part, tz) { return upgrade(op).timePart(part, tz); },
      LOOKUP: function(op, name) { return upgrade(op).lookup(name); },
      PI: function() { return r(Math.PI); },
      STD: notImplemented,
      DATE_FORMAT: function(op, format) {
        var duration = dateFormats[format.replace(/ 00:00:00$/, '')];
        if (!duration) error('unsupported format: ' + format);
        return upgrade(op).timeFloor(duration);
      },

      YEAR: function(op, tz) { return upgrade(op).timePart('YEAR', tz); },
      MONTH: function(op, tz) { return upgrade(op).timePart('MONTH_OF_YEAR', tz); },
      WEEK_OF_YEAR: function(op, tz) { return upgrade(op).timePart('WEEK_OF_YEAR', tz); },
      DAY_OF_YEAR: function(op, tz) { return upgrade(op).timePart('DAY_OF_YEAR', tz); },
      DAY_OF_MONTH: function(op, tz) { return upgrade(op).timePart('DAY_OF_MONTH', tz); },
      DAY_OF_WEEK: function(op, tz) { return upgrade(op).timePart('DAY_OF_WEEK', tz); },
      WEEKDAY: notImplemented,
      HOUR: function(op, tz) { return upgrade(op).timePart('HOUR_OF_DAY', tz); },
      MINUTE: function(op, tz) { return upgrade(op).timePart('MINUTE_OF_HOUR', tz); },
      SECOND: function(op, tz) { return upgrade(op).timePart('SECOND_OF_MINUTE', tz); },
      DATE: function(op, tz) { return upgrade(op).timeFloor('P1D', tz); },
      TIMESTAMP: function(op) { return upgrade(op).bumpStringLiteralToTime(); },
      TIME: function() { error('time literals are not supported'); },
      DATE_ADD: function(op, d, tz) { return d === 0 ? upgrade(op) : error('only zero interval supported in date math'); },
      DATE_SUB: function(op, d, tz) { return d === 0 ? upgrade(op) : error('only zero interval supported in date math'); },
      FROM_UNIXTIME: function(op) { return upgrade(op).multiply(1000).cast('TIME') },
      CAST: function(op, ct) { return upgrade(op).cast(castTypes[ct]) },
      UNIX_TIMESTAMP: function(op) { return upgrade(op).cast('NUMBER').divide(1000); },

      // Information Functions
      BENCHMARK: function() { return r(0); },
      CHARSET: function() { return r('utf8mb4'); },
      COERCIBILITY: function() { return r(0); },
      COLLATION: function() { return r('utf8mb4_unicode_ci'); },
      CONNECTION_ID: function() { return r(123); }, // ToDo
      DATABASE: function() { return r('plyql1'); },
      FOUND_ROWS: function() { return r(2005); },
      LAST_INSERT_ID: function() { return r(0); },
      ROW_COUNT: function() { return r(0); },
      USER: function() { return r('plyql@localhost'); },
      VERSION: function() { return r('5.7.11'); }
    };
    fns.ABS = fns.ABSOLUTE;
    fns.POW = fns.POWER;
    fns.LEN = fns.LENGTH;
    fns.CHAR_LENGTH = fns.LENGTH;
    fns.IFNULL = fns.FALLBACK;
    fns.SUBSTR = fns.SUBSTRING;
    fns.CURRENT_TIMESTAMP = fns.NOW;
    fns.LCASE = fns.LOWER;
    fns.LOCALTIME = fns.NOW;
    fns.LOCALTIMESTAMP = fns.NOW;
    fns.UTC_TIMESTAMP = fns.NOW;
    fns.UCASE = fns.UPPER;
    fns.SYSDATE = fns.NOW;
    fns.CURRENT_DATE = fns.CURDATE;
    fns.UTC_DATE = fns.CURDATE;
    fns.DAY_OF_YEAR = fns.DAY_OF_YEAR;
    fns.DOY = fns.DAY_OF_YEAR;
    fns.DOW = fns.DAY_OF_WEEK;
    fns.DAYOFMONTH = fns.DAY_OF_MONTH;
    fns.DAY = fns.DAY_OF_MONTH;
    fns.WEEKOFYEAR = fns.WEEK_OF_YEAR;
    fns.WEEK = fns.WEEK_OF_YEAR;
    fns.ADDDATE = fns.DATE_ADD;
    fns.SUBDATE = fns.DATE_SUB;
    fns.STDDEV = fns.STD;
    fns.STDDEV_POP = fns.STD;

    // Information Functions
    fns.SESSION_USER = fns.USER;
    fns.SYSTEM_USER = fns.USER;
    fns.CURRENT_USER = fns.USER;
    fns.SCHEMA = fns.DATABASE;

    var objectHasOwnProperty = Object.prototype.hasOwnProperty;
    function reserved(str) {
      return objectHasOwnProperty.call(reservedWords, str.toUpperCase());
    }

    function makeDate(type, v) {
      try {
        return chronoshift.parseSQLDate(type, v);
      } catch (e) {
        var isoDate = chronoshift.parseISODate(v);
        if (isoDate) {
          if (type === 'd') isoDate = chronoshift.day.floor(isoDate, Timezone.UTC);
          return isoDate;
        }
        error(e.message);
      }
    }

    function getFromTable(from) {
      if (!from) return null;
      if (from.verb === 'SELECT') return from.table; // From is a sub-query
      return from.name; // From is a ref: `namespace`.`name`
    }

    function getFromDatabase(from) {
      if (!from) return null;
      if (from.verb === 'SELECT') return from.database; // From is a sub-query
      return from.namespace; // From is a ref: `namespace`.`name`
    }

    function extractGroupByColumn(columns, groupBy, index) {
      var label = null;
      var otherColumns = [];
      for (var i = 0; i < columns.length; i++) {
        var column = columns[i];
        if (groupBy.equals(column.expression)) {
          if (label) error('already have a label');
          label = column.name;
        } else {
          otherColumns.push(column);
        }
      }
      if (!label) label = 'split' + index;
      return {
        label: label,
        otherColumns: otherColumns
      };
    }

    function upgradeGroupBys(distinct, columns, groupBys) {
      if (Array.isArray(columns)) { // Not *
        if (!groupBys) {
          // Support for not having a group by clause if there are aggregates in the columns
          // A having an aggregate columns is the same as having "GROUP BY ''"

          var hasAggregate = columns.some(function(column) {
            var columnExpression = column.expression;
            return columnExpression.isOp('chain') &&
              columnExpression.actions.some(function(action) { return action.isAggregate(); })
          })
          if (hasAggregate) {
            return [Expression.EMPTY_STRING];
          } else if (distinct) {
            return columns.map(function(column) { return column.expression });
          }

        } else {
          return groupBys.map(function(groupBy) {
            if (groupBy.isOp('literal') && groupBy.type === 'NUMBER') {
              // Support for not having a group by clause refer to a select column by index

              var groupByColumn = columns[groupBy.value - 1];
              if (!groupByColumn) error("Unknown column '" + groupBy.value + "' in group by statement");

              return groupByColumn.expression;
            } else {
              return groupBy;
            }
          });
        }
      }

      return groupBys;
    }

    function staticColumn(column) {
      return column.expression.getFreeReferences().length === 0;
    }

    function constructQuery(distinct, columns, from, where, groupBys, having, orderBy, limit) {
      if (!columns) error('Can not have empty column list');

      var query = null;

      if (!distinct && Array.isArray(columns) && !from && !where && !groupBys && columns.every(staticColumn)) {
        // This is a SELECT 1+1; type query
        query = ply();
        for (var i = 0; i < columns.length; i++) {
          query = query.performAction(columns[i]);
        }

      } else {
        var fromEx = from ? (from.verb === 'SELECT' ? from.expression : $(from.name)) : dataRef;

        if (where) {
          fromEx = fromEx.filter(where);
        }

        groupBys = upgradeGroupBys(distinct, columns, groupBys);


        if (!groupBys) {
          // Select query
          query = fromEx;

          if (Array.isArray(columns)) {
            var attributes = [];
            for (var i = 0; i < columns.length; i++) {
              var column = columns[i];
              query = query.performAction(column);
              attributes.push(column.name);
            }
            query = query.select.apply(query, attributes);
          }

        } else {
          // Group By query
          if (columns === '*') error('can not SELECT * with a GROUP BY');

          if (groupBys.length === 1 && groupBys[0].isOp('literal')) {
            query = ply().apply('data', fromEx);
          } else {
            var splits = {};
            for (var i = 0; i < groupBys.length; i++) {
              var groupBy = groupBys[i];
              var extract = extractGroupByColumn(columns, groupBy, i);
              columns = extract.otherColumns;
              splits[extract.label] = groupBy;
            }
            query = fromEx.split(splits, 'data');
          }

          if (Array.isArray(columns)) {
            for (var i = 0; i < columns.length; i++) {
              query = query.performAction(columns[i]);
            }
          }
        }
      }

      if (having) {
        query = query.performAction(having);
      }
      if (orderBy) {
        query = query.performAction(orderBy);
      }
      if (limit) {
        query = query.performAction(limit);
      }

      return query;
    }

    function makeListMap1(head, tail) {
      if (head == null) return [];
      return [head].concat(tail.map(function(t) { return t[1] }));
    }

    function naryExpressionFactory(op, head, tail) {
      if (!tail.length) return head;
      return head[op].apply(head, tail.map(function(t) { return t[1]; }));
    }

    function naryExpressionWithAltFactory(op, head, tail, altToken, altOp) {
      if (!tail.length) return head;
      for (var i = 0; i < tail.length; i++) {
        var t = tail[i];
        head = head[t[0] === altToken ? altOp : op].call(head, t[1]);
      }
      return head;
    }



    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(
        null,
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
};

},{}],3:[function(require,module,exports){
'use strict';

var Q = require('q');

var immutableClass = require('immutable-class');
var isInstanceOf = immutableClass.isInstanceOf;
var generalEqual = immutableClass.generalEqual;
var isImmutableClass = immutableClass.isImmutableClass;
var immutableEqual = immutableClass.immutableEqual;
var immutableArraysEqual = immutableClass.immutableArraysEqual;
var immutableLookupsEqual = immutableClass.immutableLookupsEqual;

var Chronoshift = require('chronoshift');
var Timezone = Chronoshift.Timezone;
var Duration = Chronoshift.Duration;
var WallTime = Chronoshift.WallTime;
var isDate = Chronoshift.isDate;
var parseISODate = Chronoshift.parseISODate;

var dummyObject = {};

var version = exports.version = '0.12.3';
var verboseRequesterFactory = exports.verboseRequesterFactory = function(parameters) {
    var requester = parameters.requester;
    var printLine = parameters.printLine || (function (line) {
        console['log'](line);
    });
    var preQuery = parameters.preQuery || (function (query, queryNumber) {
        printLine("vvvvvvvvvvvvvvvvvvvvvvvvvv");
        printLine("Sending query " + queryNumber + ":");
        printLine(JSON.stringify(query, null, 2));
        printLine("^^^^^^^^^^^^^^^^^^^^^^^^^^");
    });
    var onSuccess = parameters.onSuccess || (function (data, time, query, queryNumber) {
        printLine("vvvvvvvvvvvvvvvvvvvvvvvvvv");
        printLine("Got result from query " + queryNumber + ": (in " + time + "ms)");
        printLine(JSON.stringify(data, null, 2));
        printLine("^^^^^^^^^^^^^^^^^^^^^^^^^^");
    });
    var onError = parameters.onError || (function (error, time, query, queryNumber) {
        printLine("vvvvvvvvvvvvvvvvvvvvvvvvvv");
        printLine("Got error in query " + queryNumber + ": " + error.message + " (in " + time + "ms)");
        printLine("^^^^^^^^^^^^^^^^^^^^^^^^^^");
    });
    var queryNumber = 0;
    return function (request) {
        queryNumber++;
        var myQueryNumber = queryNumber;
        preQuery(request.query, myQueryNumber);
        var startTime = Date.now();
        return requester(request)
            .then(function (data) {
            onSuccess(data, Date.now() - startTime, request.query, myQueryNumber);
            return data;
        }, function (error) {
            onError(error, Date.now() - startTime, request.query, myQueryNumber);
            throw error;
        });
    };
}

var retryRequesterFactory = exports.retryRequesterFactory = function(parameters) {
    var requester = parameters.requester;
    var delay = parameters.delay || 500;
    var retry = parameters.retry || 3;
    var retryOnTimeout = Boolean(parameters.retryOnTimeout);
    if (typeof delay !== "number")
        throw new TypeError("delay should be a number");
    if (typeof retry !== "number")
        throw new TypeError("retry should be a number");
    return function (request) {
        var tries = 1;
        function handleError(err) {
            if (tries > retry)
                throw err;
            tries++;
            if (err.message === "timeout" && !retryOnTimeout)
                throw err;
            return Q.delay(delay).then(function () { return requester(request); }).catch(handleError);
        }
        return requester(request).catch(handleError);
    };
}

var concurrentLimitRequesterFactory = exports.concurrentLimitRequesterFactory = function(parameters) {
    var requester = parameters.requester;
    var concurrentLimit = parameters.concurrentLimit || 5;
    if (typeof concurrentLimit !== "number")
        throw new TypeError("concurrentLimit should be a number");
    var requestQueue = [];
    var outstandingRequests = 0;
    function requestFinished() {
        outstandingRequests--;
        if (!(requestQueue.length && outstandingRequests < concurrentLimit))
            return;
        var queueItem = requestQueue.shift();
        var deferred = queueItem.deferred;
        outstandingRequests++;
        requester(queueItem.request)
            .then(deferred.resolve, deferred.reject)
            .fin(requestFinished);
    }
    return function (request) {
        if (outstandingRequests < concurrentLimit) {
            outstandingRequests++;
            return requester(request).fin(requestFinished);
        }
        else {
            var deferred = Q.defer();
            requestQueue.push({
                request: request,
                deferred: deferred
            });
            return deferred.promise;
        }
    };
}

var promiseWhile = exports.promiseWhile = function(condition, action) {
    var loop = function () {
        if (!condition())
            return Q(null);
        return Q(action()).then(loop);
    };
    return Q(null).then(loop);
}
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var objectHasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwnProperty = exports.hasOwnProperty = function(obj, key) {
    return objectHasOwnProperty.call(obj, key);
}
var repeat = exports.repeat = function(str, times) {
    return new Array(times + 1).join(str);
}
var arraysEqual = exports.arraysEqual = function(a, b) {
    if (a === b)
        return true;
    var length = a.length;
    if (length !== b.length)
        return false;
    for (var i = 0; i < length; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
var dictEqual = exports.dictEqual = function(dictA, dictB) {
    if (dictA === dictB)
        return true;
    if (!dictA !== !dictB)
        return false;
    var keys = Object.keys(dictA);
    if (keys.length !== Object.keys(dictB).length)
        return false;
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (dictA[key] !== dictB[key])
            return false;
    }
    return true;
}
var find = exports.find = function(array, fn) {
    for (var i = 0, n = array.length; i < n; i++) {
        var a = array[i];
        if (fn.call(array, a, i))
            return a;
    }
    return null;
}
var findIndex = exports.findIndex = function(array, fn) {
    for (var i = 0, n = array.length; i < n; i++) {
        var a = array[i];
        if (fn.call(array, a, i))
            return i;
    }
    return -1;
}
var findByName = exports.findByName = function(array, name) {
    return find(array, function (x) { return x.name === name; });
}
var findIndexByName = exports.findIndexByName = function(array, name) {
    return findIndex(array, function (x) { return x.name === name; });
}
var overrideByName = exports.overrideByName = function(things, thingOverride) {
    var overrideName = thingOverride.name;
    var added = false;
    things = things.map(function (t) {
        if (t.name === overrideName) {
            added = true;
            return thingOverride;
        }
        else {
            return t;
        }
    });
    if (!added)
        things.push(thingOverride);
    return things;
}
var overridesByName = exports.overridesByName = function(things, thingOverrides) {
    for (var _i = 0, thingOverrides_1 = thingOverrides; _i < thingOverrides_1.length; _i++) {
        var thingOverride = thingOverrides_1[_i];
        things = overrideByName(things, thingOverride);
    }
    return things;
}
var shallowCopy = exports.shallowCopy = function(thing) {
    var newThing = {};
    for (var k in thing) {
        if (hasOwnProperty(thing, k))
            newThing[k] = thing[k];
    }
    return newThing;
}
var deduplicateSort = exports.deduplicateSort = function(a) {
    a = a.sort();
    var newA = [];
    var last = null;
    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var v = a_1[_i];
        if (v !== last)
            newA.push(v);
        last = v;
    }
    return newA;
}
var mapLookup = exports.mapLookup = function(thing, fn) {
    var newThing = Object.create(null);
    for (var k in thing) {
        if (hasOwnProperty(thing, k))
            newThing[k] = fn(thing[k]);
    }
    return newThing;
}
var emptyLookup = exports.emptyLookup = function(lookup) {
    for (var k in lookup) {
        if (hasOwnProperty(lookup, k))
            return false;
    }
    return true;
}
var nonEmptyLookup = exports.nonEmptyLookup = function(lookup) {
    return !emptyLookup(lookup);
}
var safeAdd = exports.safeAdd = function(num, delta) {
    var stringDelta = String(delta);
    var dotIndex = stringDelta.indexOf(".");
    if (dotIndex === -1 || stringDelta.length === 18) {
        return num + delta;
    }
    else {
        var scale = Math.pow(10, stringDelta.length - dotIndex - 1);
        return (num * scale + delta * scale) / scale;
    }
}
var continuousFloorExpression = exports.continuousFloorExpression = function(variable, floorFn, size, offset) {
    var expr = variable;
    if (offset !== 0) {
        expr = expr + " - " + offset;
    }
    if (offset !== 0 && size !== 1) {
        expr = "(" + expr + ")";
    }
    if (size !== 1) {
        expr = expr + " / " + size;
    }
    expr = floorFn + "(" + expr + ")";
    if (size !== 1) {
        expr = expr + " * " + size;
    }
    if (offset !== 0) {
        expr = expr + " + " + offset;
    }
    return expr;
}
var ExtendableError = exports.ExtendableError = (function (_super) {
    __extends(ExtendableError, _super);
    function ExtendableError(message) {
        _super.call(this, message);
        this.name = this.constructor.name;
        this.message = message;
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, this.constructor);
        }
        else {
            this.stack = (new Error(message)).stack;
        }
    }
    return ExtendableError;
}(Error));
var SQLDialect = exports.SQLDialect = (function () {
    function SQLDialect() {
    }
    SQLDialect.prototype.constantGroupBy = function () {
        return "GROUP BY ''";
    };
    SQLDialect.prototype.escapeName = function (name) {
        name = name.replace(/"/g, '""');
        return '"' + name + '"';
    };
    SQLDialect.prototype.escapeLiteral = function (name) {
        if (name === null)
            return 'NULL';
        name = name.replace(/'/g, "''");
        return "'" + name + "'";
    };
    SQLDialect.prototype.booleanToSQL = function (bool) {
        return ('' + bool).toUpperCase();
    };
    SQLDialect.prototype.numberOrTimeToSQL = function (x) {
        if (x === null)
            return 'NULL';
        if (x.toISOString) {
            return this.timeToSQL(x);
        }
        else {
            return this.numberToSQL(x);
        }
    };
    SQLDialect.prototype.numberToSQL = function (num) {
        if (num === null)
            return 'NULL';
        return '' + num;
    };
    SQLDialect.prototype.dateToSQLDateString = function (date) {
        return date.toISOString()
            .replace('T', ' ')
            .replace('Z', '')
            .replace(/\.000$/, '')
            .replace(/ 00:00:00$/, '');
    };
    SQLDialect.prototype.aggregateFilterIfNeeded = function (inputSQL, expressionSQL, zeroSQL) {
        if (zeroSQL === void 0) { zeroSQL = '0'; }
        var whereIndex = inputSQL.indexOf(' WHERE ');
        if (whereIndex === -1)
            return expressionSQL;
        var filterSQL = inputSQL.substr(whereIndex + 7);
        return this.conditionalExpression(filterSQL, expressionSQL, zeroSQL);
    };
    SQLDialect.prototype.conditionalExpression = function (condition, thenPart, elsePart) {
        return "IF(" + condition + "," + thenPart + "," + elsePart + ")";
    };
    SQLDialect.prototype.concatExpression = function (a, b) {
        throw new Error('must implement');
    };
    SQLDialect.prototype.containsExpression = function (a, b) {
        throw new Error('must implement');
    };
    SQLDialect.prototype.isNotDistinctFromExpression = function (a, b) {
        if (a === 'NULL')
            return b + " IS NULL";
        if (b === 'NULL')
            return a + " IS NULL";
        return "(" + a + " IS NOT DISTINCT FROM " + b + ")";
    };
    SQLDialect.prototype.inExpression = function (operand, start, end, bounds) {
        if (start === end && bounds === '[]')
            return operand + "=" + start;
        var startSQL = null;
        if (start !== 'NULL') {
            startSQL = start + (bounds[0] === '[' ? '<=' : '<') + operand;
        }
        var endSQL = null;
        if (end !== 'NULL') {
            endSQL = operand + (bounds[1] === ']' ? '<=' : '<') + end;
        }
        if (startSQL) {
            return endSQL ? "(" + startSQL + " AND " + endSQL + ")" : startSQL;
        }
        else {
            return endSQL ? endSQL : 'TRUE';
        }
    };
    return SQLDialect;
}());
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var MySQLDialect = exports.MySQLDialect = (function (_super) {
    __extends(MySQLDialect, _super);
    function MySQLDialect() {
        _super.call(this);
    }
    MySQLDialect.prototype.escapeName = function (name) {
        name = name.replace(/`/g, '``');
        return '`' + name + '`';
    };
    MySQLDialect.prototype.escapeLiteral = function (name) {
        if (name === null)
            return 'NULL';
        return JSON.stringify(name);
    };
    MySQLDialect.prototype.timeToSQL = function (date) {
        if (!date)
            return 'NULL';
        return "TIMESTAMP('" + this.dateToSQLDateString(date) + "')";
    };
    MySQLDialect.prototype.concatExpression = function (a, b) {
        return "CONCAT(" + a + "," + b + ")";
    };
    MySQLDialect.prototype.containsExpression = function (a, b) {
        return "LOCATE(" + a + "," + b + ")>0";
    };
    MySQLDialect.prototype.lengthExpression = function (a) {
        return "CHAR_LENGTH(" + a + ")";
    };
    MySQLDialect.prototype.isNotDistinctFromExpression = function (a, b) {
        return "(" + a + "<=>" + b + ")";
    };
    MySQLDialect.prototype.regexpExpression = function (expression, regexp) {
        return "(" + expression + " REGEXP '" + regexp + "')";
    };
    MySQLDialect.prototype.castExpression = function (inputType, operand, cast) {
        var castFunction = MySQLDialect.CAST_TO_FUNCTION[cast][inputType];
        if (!castFunction)
            throw new Error("unsupported cast from " + inputType + " to " + cast + " in MySQL dialect");
        return castFunction.replace(/\$\$/g, operand);
    };
    MySQLDialect.prototype.utcToWalltime = function (operand, timezone) {
        if (timezone.isUTC())
            return operand;
        return "CONVERT_TZ(" + operand + ",'+0:00','" + timezone + "')";
    };
    MySQLDialect.prototype.walltimeToUTC = function (operand, timezone) {
        if (timezone.isUTC())
            return operand;
        return "CONVERT_TZ(" + operand + ",'" + timezone + "','+0:00')";
    };
    MySQLDialect.prototype.timeFloorExpression = function (operand, duration, timezone) {
        var bucketFormat = MySQLDialect.TIME_BUCKETING[duration.toString()];
        if (!bucketFormat)
            throw new Error("unsupported duration '" + duration + "'");
        return this.walltimeToUTC("DATE_FORMAT(" + this.utcToWalltime(operand, timezone) + ",'" + bucketFormat + "')", timezone);
    };
    MySQLDialect.prototype.timeBucketExpression = function (operand, duration, timezone) {
        return this.timeFloorExpression(operand, duration, timezone);
    };
    MySQLDialect.prototype.timePartExpression = function (operand, part, timezone) {
        var timePartFunction = MySQLDialect.TIME_PART_TO_FUNCTION[part];
        if (!timePartFunction)
            throw new Error("unsupported part " + part + " in MySQL dialect");
        return timePartFunction.replace(/\$\$/g, this.utcToWalltime(operand, timezone));
    };
    MySQLDialect.prototype.timeShiftExpression = function (operand, duration, timezone) {
        var sqlFn = "DATE_ADD(";
        var spans = duration.valueOf();
        if (spans.week) {
            return sqlFn + operand + ", INTERVAL " + String(spans.week) + ' WEEK)';
        }
        if (spans.year || spans.month) {
            var expr = String(spans.year || 0) + "-" + String(spans.month || 0);
            operand = sqlFn + operand + ", INTERVAL '" + expr + "' YEAR_MONTH)";
        }
        if (spans.day || spans.hour || spans.minute || spans.second) {
            var expr = String(spans.day || 0) + " " + [spans.hour || 0, spans.minute || 0, spans.second || 0].join(':');
            operand = sqlFn + operand + ", INTERVAL '" + expr + "' DAY_SECOND)";
        }
        return operand;
    };
    MySQLDialect.prototype.extractExpression = function (operand, regexp) {
        throw new Error('MySQL must implement extractExpression (https://github.com/mysqludf/lib_mysqludf_preg)');
    };
    MySQLDialect.prototype.indexOfExpression = function (str, substr) {
        return "LOCATE(" + substr + ", " + str + ") - 1";
    };
    MySQLDialect.TIME_BUCKETING = {
        "PT1S": "%Y-%m-%d %H:%i:%SZ",
        "PT1M": "%Y-%m-%d %H:%i:00Z",
        "PT1H": "%Y-%m-%d %H:00:00Z",
        "P1D": "%Y-%m-%d 00:00:00Z",
        "P1M": "%Y-%m-01 00:00:00Z",
        "P1Y": "%Y-01-01 00:00:00Z"
    };
    MySQLDialect.TIME_PART_TO_FUNCTION = {
        SECOND_OF_MINUTE: 'SECOND($$)',
        SECOND_OF_HOUR: '(MINUTE($$)*60+SECOND($$))',
        SECOND_OF_DAY: '((HOUR($$)*60+MINUTE($$))*60+SECOND($$))',
        SECOND_OF_WEEK: '(((WEEKDAY($$)*24)+HOUR($$)*60+MINUTE($$))*60+SECOND($$))',
        SECOND_OF_MONTH: '((((DAYOFMONTH($$)-1)*24)+HOUR($$)*60+MINUTE($$))*60+SECOND($$))',
        SECOND_OF_YEAR: '((((DAYOFYEAR($$)-1)*24)+HOUR($$)*60+MINUTE($$))*60+SECOND($$))',
        MINUTE_OF_HOUR: 'MINUTE($$)',
        MINUTE_OF_DAY: 'HOUR($$)*60+MINUTE($$)',
        MINUTE_OF_WEEK: '(WEEKDAY($$)*24)+HOUR($$)*60+MINUTE($$)',
        MINUTE_OF_MONTH: '((DAYOFMONTH($$)-1)*24)+HOUR($$)*60+MINUTE($$)',
        MINUTE_OF_YEAR: '((DAYOFYEAR($$)-1)*24)+HOUR($$)*60+MINUTE($$)',
        HOUR_OF_DAY: 'HOUR($$)',
        HOUR_OF_WEEK: '(WEEKDAY($$)*24+HOUR($$))',
        HOUR_OF_MONTH: '((DAYOFMONTH($$)-1)*24+HOUR($$))',
        HOUR_OF_YEAR: '((DAYOFYEAR($$)-1)*24+HOUR($$))',
        DAY_OF_WEEK: '(WEEKDAY($$)+1)',
        DAY_OF_MONTH: 'DAYOFMONTH($$)',
        DAY_OF_YEAR: 'DAYOFYEAR($$)',
        WEEK_OF_MONTH: null,
        WEEK_OF_YEAR: 'WEEK($$)',
        MONTH_OF_YEAR: 'MONTH($$)',
        YEAR: 'YEAR($$)'
    };
    MySQLDialect.CAST_TO_FUNCTION = {
        TIME: {
            NUMBER: 'FROM_UNIXTIME($$ / 1000)'
        },
        NUMBER: {
            TIME: 'UNIX_TIMESTAMP($$) * 1000',
            STRING: 'CAST($$ AS SIGNED)'
        },
        STRING: {
            NUMBER: 'CAST($$ AS CHAR)'
        }
    };
    return MySQLDialect;
}(SQLDialect));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var PostgresDialect = exports.PostgresDialect = (function (_super) {
    __extends(PostgresDialect, _super);
    function PostgresDialect() {
        _super.call(this);
    }
    PostgresDialect.prototype.constantGroupBy = function () {
        return "GROUP BY ''=''";
    };
    PostgresDialect.prototype.timeToSQL = function (date) {
        if (!date)
            return 'NULL';
        return "TIMESTAMP '" + this.dateToSQLDateString(date) + "'";
    };
    PostgresDialect.prototype.conditionalExpression = function (condition, thenPart, elsePart) {
        return "(CASE WHEN " + condition + " THEN " + thenPart + " ELSE " + elsePart + " END)";
    };
    PostgresDialect.prototype.concatExpression = function (a, b) {
        return "(" + a + "||" + b + ")";
    };
    PostgresDialect.prototype.containsExpression = function (a, b) {
        return "POSITION(" + a + " IN " + b + ")>0";
    };
    PostgresDialect.prototype.lengthExpression = function (a) {
        return "LENGTH(" + a + ")";
    };
    PostgresDialect.prototype.regexpExpression = function (expression, regexp) {
        return "(" + expression + " ~ '" + regexp + "')";
    };
    PostgresDialect.prototype.castExpression = function (inputType, operand, cast) {
        var castFunction = PostgresDialect.CAST_TO_FUNCTION[cast][inputType];
        if (!castFunction)
            throw new Error("unsupported cast from " + inputType + " to " + cast + " in Postgres dialect");
        return castFunction.replace(/\$\$/g, operand);
    };
    PostgresDialect.prototype.utcToWalltime = function (operand, timezone) {
        if (timezone.isUTC())
            return operand;
        return "(" + operand + " AT TIME ZONE 'UTC' AT TIME ZONE '" + timezone + "')";
    };
    PostgresDialect.prototype.walltimeToUTC = function (operand, timezone) {
        if (timezone.isUTC())
            return operand;
        return "(" + operand + " AT TIME ZONE '" + timezone + "' AT TIME ZONE 'UTC')";
    };
    PostgresDialect.prototype.timeFloorExpression = function (operand, duration, timezone) {
        var bucketFormat = PostgresDialect.TIME_BUCKETING[duration.toString()];
        if (!bucketFormat)
            throw new Error("unsupported duration '" + duration + "'");
        return this.walltimeToUTC("DATE_TRUNC('" + bucketFormat + "'," + this.utcToWalltime(operand, timezone) + ")", timezone);
    };
    PostgresDialect.prototype.timeBucketExpression = function (operand, duration, timezone) {
        return this.timeFloorExpression(operand, duration, timezone);
    };
    PostgresDialect.prototype.timePartExpression = function (operand, part, timezone) {
        var timePartFunction = PostgresDialect.TIME_PART_TO_FUNCTION[part];
        if (!timePartFunction)
            throw new Error("unsupported part " + part + " in Postgres dialect");
        return timePartFunction.replace(/\$\$/g, this.utcToWalltime(operand, timezone));
    };
    PostgresDialect.prototype.timeShiftExpression = function (operand, duration, timezone) {
        var sqlFn = "DATE_ADD(";
        var spans = duration.valueOf();
        if (spans.week) {
            return sqlFn + operand + ", INTERVAL " + String(spans.week) + ' WEEK)';
        }
        if (spans.year || spans.month) {
            var expr = String(spans.year || 0) + "-" + String(spans.month || 0);
            operand = sqlFn + operand + ", INTERVAL '" + expr + "' YEAR_MONTH)";
        }
        if (spans.day || spans.hour || spans.minute || spans.second) {
            var expr = String(spans.day || 0) + " " + [spans.hour || 0, spans.minute || 0, spans.second || 0].join(':');
            operand = sqlFn + operand + ", INTERVAL '" + expr + "' DAY_SECOND)";
        }
        return operand;
    };
    PostgresDialect.prototype.extractExpression = function (operand, regexp) {
        return "(SELECT (REGEXP_MATCHES(" + operand + ", '" + regexp + "'))[1])";
    };
    PostgresDialect.prototype.indexOfExpression = function (str, substr) {
        return "POSITION(" + substr + " IN " + str + ") - 1";
    };
    PostgresDialect.TIME_BUCKETING = {
        "PT1S": "second",
        "PT1M": "minute",
        "PT1H": "hour",
        "P1D": "day",
        "P1W": "week",
        "P1M": "month",
        "P3M": "quarter",
        "P1Y": "year"
    };
    PostgresDialect.TIME_PART_TO_FUNCTION = {
        SECOND_OF_MINUTE: "DATE_PART('second',$$)",
        SECOND_OF_HOUR: "(DATE_PART('minute',$$)*60+DATE_PART('second',$$))",
        SECOND_OF_DAY: "((DATE_PART('hour',$$)*60+DATE_PART('minute',$$))*60+DATE_PART('second',$$))",
        SECOND_OF_WEEK: "((((CAST((DATE_PART('dow',$$)+6) AS int)%7)*24)+DATE_PART('hour',$$)*60+DATE_PART('minute',$$))*60+DATE_PART('second',$$))",
        SECOND_OF_MONTH: "((((DATE_PART('day',$$)-1)*24)+DATE_PART('hour',$$)*60+DATE_PART('minute',$$))*60+DATE_PART('second',$$))",
        SECOND_OF_YEAR: "((((DATE_PART('doy',$$)-1)*24)+DATE_PART('hour',$$)*60+DATE_PART('minute',$$))*60+DATE_PART('second',$$))",
        MINUTE_OF_HOUR: "DATE_PART('minute',$$)",
        MINUTE_OF_DAY: "DATE_PART('hour',$$)*60+DATE_PART('minute',$$)",
        MINUTE_OF_WEEK: "((CAST((DATE_PART('dow',$$)+6) AS int)%7)*24)+DATE_PART('hour',$$)*60+DATE_PART('minute',$$)",
        MINUTE_OF_MONTH: "((DATE_PART('day',$$)-1)*24)+DATE_PART('hour',$$)*60+DATE_PART('minute',$$)",
        MINUTE_OF_YEAR: "((DATE_PART('doy',$$)-1)*24)+DATE_PART('hour',$$)*60+DATE_PART('minute',$$)",
        HOUR_OF_DAY: "DATE_PART('hour',$$)",
        HOUR_OF_WEEK: "((CAST((DATE_PART('dow',$$)+6) AS int)%7)*24+DATE_PART('hour',$$))",
        HOUR_OF_MONTH: "((DATE_PART('day',$$)-1)*24+DATE_PART('hour',$$))",
        HOUR_OF_YEAR: "((DATE_PART('doy',$$)-1)*24+DATE_PART('hour',$$))",
        DAY_OF_WEEK: "(CAST((DATE_PART('dow',$$)+6) AS int)%7)+1",
        DAY_OF_MONTH: "DATE_PART('day',$$)",
        DAY_OF_YEAR: "DATE_PART('doy',$$)",
        WEEK_OF_MONTH: null,
        WEEK_OF_YEAR: "DATE_PART('week',$$)",
        MONTH_OF_YEAR: "DATE_PART('month',$$)",
        YEAR: "DATE_PART('year',$$)",
    };
    PostgresDialect.CAST_TO_FUNCTION = {
        TIME: {
            NUMBER: 'TO_TIMESTAMP($$::double precision / 1000)'
        },
        NUMBER: {
            TIME: "EXTRACT(EPOCH FROM $$) * 1000",
            STRING: "$$::float"
        },
        STRING: {
            NUMBER: "$$::text"
        }
    };
    return PostgresDialect;
}(SQLDialect));










var getValueType = exports.getValueType = function(value) {
    var typeofValue = typeof value;
    if (typeofValue === 'object') {
        if (value === null) {
            return 'NULL';
        }
        else if (isDate(value)) {
            return 'TIME';
        }
        else if (hasOwnProperty(value, 'start') && hasOwnProperty(value, 'end')) {
            if (isDate(value.start) || isDate(value.end))
                return 'TIME_RANGE';
            if (typeof value.start === 'number' || typeof value.end === 'number')
                return 'NUMBER_RANGE';
            if (typeof value.start === 'string' || typeof value.end === 'string')
                return 'STRING_RANGE';
            throw new Error("unrecognizable range");
        }
        else {
            var ctrType = value.constructor.type;
            if (!ctrType) {
                if (Expression.isExpression(value)) {
                    throw new Error("expression used as datum value " + value);
                }
                else {
                    throw new Error("can not have an object without a type: " + JSON.stringify(value));
                }
            }
            if (ctrType === 'SET')
                ctrType += '/' + value.setType;
            return ctrType;
        }
    }
    else {
        if (typeofValue !== 'boolean' && typeofValue !== 'number' && typeofValue !== 'string') {
            throw new TypeError('unsupported JS type ' + typeofValue);
        }
        return typeofValue.toUpperCase();
    }
}
var getFullType = exports.getFullType = function(value) {
    var myType = getValueType(value);
    return myType === 'DATASET' ? value.getFullType() : { type: myType };
}
var getFullTypeFromDatum = exports.getFullTypeFromDatum = function(datum) {
    var datasetType = {};
    for (var k in datum) {
        if (!hasOwnProperty(datum, k))
            continue;
        datasetType[k] = getFullType(datum[k]);
    }
    return {
        type: 'DATASET',
        datasetType: datasetType
    };
}
var valueFromJS = exports.valueFromJS = function(v, typeOverride) {
    if (typeOverride === void 0) { typeOverride = null; }
    if (v == null) {
        return null;
    }
    else if (Array.isArray(v)) {
        if (v.length && typeof v[0] !== 'object') {
            return Set.fromJS(v);
        }
        else {
            return Dataset.fromJS(v);
        }
    }
    else if (typeof v === 'object') {
        switch (typeOverride || v.type) {
            case 'NUMBER':
                var n = Number(v.value);
                if (isNaN(n))
                    throw new Error("bad number value '" + v.value + "'");
                return n;
            case 'NUMBER_RANGE':
                return NumberRange.fromJS(v);
            case 'STRING_RANGE':
                return StringRange.fromJS(v);
            case 'TIME':
                return typeOverride ? v : new Date(v.value);
            case 'TIME_RANGE':
                return TimeRange.fromJS(v);
            case 'SET':
                return Set.fromJS(v);
            default:
                if (v.toISOString) {
                    return v;
                }
                else {
                    throw new Error('can not have an object without a `type` as a datum value');
                }
        }
    }
    else if (typeof v === 'string' && typeOverride === 'TIME') {
        return new Date(v);
    }
    return v;
}
var valueToJS = exports.valueToJS = function(v) {
    if (v == null) {
        return null;
    }
    else {
        var typeofV = typeof v;
        if (typeofV === 'object') {
            if (v.toISOString) {
                return v;
            }
            else {
                return v.toJS();
            }
        }
        else if (typeofV === 'number' && !isFinite(v)) {
            return String(v);
        }
    }
    return v;
}
var valueToJSInlineType = exports.valueToJSInlineType = function(v) {
    if (v == null) {
        return null;
    }
    else {
        var typeofV = typeof v;
        if (typeofV === 'object') {
            if (v.toISOString) {
                return { type: 'TIME', value: v };
            }
            else {
                var js = v.toJS();
                if (!Array.isArray(js)) {
                    js.type = v.constructor.type;
                }
                return js;
            }
        }
        else if (typeofV === 'number' && !isFinite(v)) {
            return { type: 'NUMBER', value: String(v) };
        }
    }
    return v;
}
var datumHasExternal = exports.datumHasExternal = function(datum) {
    for (var name in datum) {
        var value = datum[name];
        if (value instanceof External)
            return true;
        if (value instanceof Dataset && value.hasExternal())
            return true;
    }
    return false;
}
var introspectDatum = exports.introspectDatum = function(datum) {
    var promises = [];
    var newDatum = Object.create(null);
    Object.keys(datum)
        .forEach(function (name) {
        var v = datum[name];
        if (v instanceof External && v.needsIntrospect()) {
            promises.push(v.introspect().then(function (introspectedExternal) {
                newDatum[name] = introspectedExternal;
            }));
        }
        else {
            newDatum[name] = v;
        }
    });
    return Q.all(promises).then(function () { return newDatum; });
}
var isSetType = exports.isSetType = function(type) {
    return type && type.indexOf('SET/') === 0;
}
var wrapSetType = exports.wrapSetType = function(type) {
    return isSetType(type) ? type : ('SET/' + type);
}
var unwrapSetType = exports.unwrapSetType = function(type) {
    if (!type)
        return null;
    return isSetType(type) ? type.substr(4) : type;
}
var getAllSetTypes = exports.getAllSetTypes = function() {
    return [
        'SET/STRING',
        'SET/STRING_RANGE',
        'SET/NUMBER',
        'SET/NUMBER_RANGE',
        'SET/TIME',
        'SET/TIME_RANGE'
    ];
}
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




function isInteger(n) {
    return !isNaN(n) && n % 1 === 0;
}
function isPositiveInteger(n) {
    return isInteger(n) && 0 < n;
}
var check;
var AttributeInfo = exports.AttributeInfo = (function () {
    function AttributeInfo(parameters) {
        if (parameters.special)
            this.special = parameters.special;
        if (typeof parameters.name !== "string") {
            throw new Error("name must be a string");
        }
        this.name = parameters.name;
        if (hasOwnProperty(parameters, 'type') && !RefExpression.validType(parameters.type)) {
            throw new Error("invalid type: " + parameters.type);
        }
        this.type = parameters.type;
        this.datasetType = parameters.datasetType;
        this.unsplitable = Boolean(parameters.unsplitable);
        this.makerAction = parameters.makerAction;
    }
    AttributeInfo.isAttributeInfo = function (candidate) {
        return isInstanceOf(candidate, AttributeInfo);
    };
    AttributeInfo.jsToValue = function (parameters) {
        var value = {
            special: parameters.special,
            name: parameters.name
        };
        if (parameters.type)
            value.type = parameters.type;
        if (parameters.datasetType)
            value.datasetType = parameters.datasetType;
        if (parameters.unsplitable)
            value.unsplitable = true;
        if (parameters.makerAction)
            value.makerAction = Action.fromJS(parameters.makerAction);
        return value;
    };
    AttributeInfo.register = function (ex) {
        var op = ex.name.replace('AttributeInfo', '').replace(/^\w/, function (s) { return s.toLowerCase(); });
        AttributeInfo.classMap[op] = ex;
    };
    AttributeInfo.fromJS = function (parameters) {
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable attributeMeta");
        }
        if (!hasOwnProperty(parameters, 'special')) {
            return new AttributeInfo(AttributeInfo.jsToValue(parameters));
        }
        if (parameters.special === 'range') {
            throw new Error("'range' attribute info is no longer supported, you should apply the .extract('^\\d+') function instead");
        }
        var Class = AttributeInfo.classMap[parameters.special];
        if (!Class) {
            throw new Error("unsupported special attributeInfo '" + parameters.special + "'");
        }
        return Class.fromJS(parameters);
    };
    AttributeInfo.fromJSs = function (attributeJSs) {
        if (!Array.isArray(attributeJSs)) {
            if (attributeJSs && typeof attributeJSs === 'object') {
                var newAttributeJSs = [];
                for (var attributeName in attributeJSs) {
                    if (!hasOwnProperty(attributeJSs, attributeName))
                        continue;
                    var attributeJS = attributeJSs[attributeName];
                    attributeJS['name'] = attributeName;
                    newAttributeJSs.push(attributeJS);
                }
                console.warn('attributes now needs to be passed as an array like so: ' + JSON.stringify(newAttributeJSs, null, 2));
                attributeJSs = newAttributeJSs;
            }
            else {
                throw new TypeError("invalid attributeJSs");
            }
        }
        return attributeJSs.map(function (attributeJS) { return AttributeInfo.fromJS(attributeJS); });
    };
    AttributeInfo.toJSs = function (attributes) {
        return attributes.map(function (attribute) { return attribute.toJS(); });
    };
    AttributeInfo.override = function (attributes, attributeOverrides) {
        return overridesByName(attributes, attributeOverrides);
    };
    AttributeInfo.prototype._ensureSpecial = function (special) {
        if (!this.special) {
            this.special = special;
            return;
        }
        if (this.special !== special) {
            throw new TypeError("incorrect attributeInfo special '" + this.special + "' (needs to be: '" + special + "')");
        }
    };
    AttributeInfo.prototype._ensureType = function (myType) {
        if (!this.type) {
            this.type = myType;
            return;
        }
        if (this.type !== myType) {
            throw new TypeError("incorrect attributeInfo type '" + this.type + "' (needs to be: '" + myType + "')");
        }
    };
    AttributeInfo.prototype.toString = function () {
        var special = this.special ? "[" + this.special + "]" : '';
        return this.name + "::" + this.type + special;
    };
    AttributeInfo.prototype.valueOf = function () {
        var value = {
            name: this.name,
            type: this.type,
            unsplitable: this.unsplitable
        };
        if (this.special)
            value.special = this.special;
        if (this.datasetType)
            value.datasetType = this.datasetType;
        if (this.makerAction)
            value.makerAction = this.makerAction;
        return value;
    };
    AttributeInfo.prototype.toJS = function () {
        var js = {
            name: this.name,
            type: this.type
        };
        if (this.unsplitable)
            js.unsplitable = true;
        if (this.special)
            js.special = this.special;
        if (this.datasetType)
            js.datasetType = this.datasetType;
        if (this.makerAction)
            js.makerAction = this.makerAction.toJS();
        return js;
    };
    AttributeInfo.prototype.toJSON = function () {
        return this.toJS();
    };
    AttributeInfo.prototype.equals = function (other) {
        return AttributeInfo.isAttributeInfo(other) &&
            this.special === other.special &&
            this.name === other.name &&
            this.type === other.type &&
            Boolean(this.makerAction) === Boolean(other.makerAction) &&
            (!this.makerAction || this.makerAction.equals(other.makerAction));
    };
    AttributeInfo.prototype.serialize = function (value) {
        return value;
    };
    AttributeInfo.classMap = {};
    return AttributeInfo;
}());
check = AttributeInfo;
var UniqueAttributeInfo = exports.UniqueAttributeInfo = (function (_super) {
    __extends(UniqueAttributeInfo, _super);
    function UniqueAttributeInfo(parameters) {
        _super.call(this, parameters);
        this._ensureSpecial("unique");
        this._ensureType('STRING');
    }
    UniqueAttributeInfo.fromJS = function (parameters) {
        return new UniqueAttributeInfo(AttributeInfo.jsToValue(parameters));
    };
    UniqueAttributeInfo.prototype.serialize = function (value) {
        throw new Error("can not serialize an approximate unique value");
    };
    return UniqueAttributeInfo;
}(AttributeInfo));
AttributeInfo.register(UniqueAttributeInfo);
var ThetaAttributeInfo = exports.ThetaAttributeInfo = (function (_super) {
    __extends(ThetaAttributeInfo, _super);
    function ThetaAttributeInfo(parameters) {
        _super.call(this, parameters);
        this._ensureSpecial("theta");
        this._ensureType('STRING');
    }
    ThetaAttributeInfo.fromJS = function (parameters) {
        return new ThetaAttributeInfo(AttributeInfo.jsToValue(parameters));
    };
    ThetaAttributeInfo.prototype.serialize = function (value) {
        throw new Error("can not serialize a theta value");
    };
    return ThetaAttributeInfo;
}(AttributeInfo));
AttributeInfo.register(ThetaAttributeInfo);
var HistogramAttributeInfo = exports.HistogramAttributeInfo = (function (_super) {
    __extends(HistogramAttributeInfo, _super);
    function HistogramAttributeInfo(parameters) {
        _super.call(this, parameters);
        this._ensureSpecial("histogram");
        this._ensureType('NUMBER');
    }
    HistogramAttributeInfo.fromJS = function (parameters) {
        return new HistogramAttributeInfo(AttributeInfo.jsToValue(parameters));
    };
    HistogramAttributeInfo.prototype.serialize = function (value) {
        throw new Error("can not serialize a histogram value");
    };
    return HistogramAttributeInfo;
}(AttributeInfo));
AttributeInfo.register(HistogramAttributeInfo);

var BOUNDS_REG_EXP = /^[\[(][\])]$/;
var Range = exports.Range = (function () {
    function Range(start, end, bounds) {
        if (bounds) {
            if (!BOUNDS_REG_EXP.test(bounds)) {
                throw new Error("invalid bounds " + bounds);
            }
        }
        else {
            bounds = Range.DEFAULT_BOUNDS;
        }
        if (start !== null && end !== null && this._endpointEqual(start, end)) {
            if (bounds !== '[]') {
                start = end = this._zeroEndpoint();
            }
            if (bounds === '(]' || bounds === '()')
                this.bounds = '[)';
        }
        else {
            if (start !== null && end !== null && end < start) {
                throw new Error('must have start <= end');
            }
            if (start === null && bounds[0] === '[') {
                bounds = '(' + bounds[1];
            }
            if (end === null && bounds[1] === ']') {
                bounds = bounds[0] + ')';
            }
        }
        this.start = start;
        this.end = end;
        this.bounds = bounds;
    }
    Range.isRange = function (candidate) {
        return isInstanceOf(candidate, Range);
    };
    Range.register = function (ctr) {
        var rangeName = ctr.name.replace('Range', '').replace(/^\w/, function (s) { return s.toLowerCase(); });
        Range.classMap[rangeName] = ctr;
    };
    Range.fromJS = function (parameters) {
        var ctr;
        if (typeof parameters.start === 'number' || typeof parameters.end === 'number') {
            ctr = 'number';
        }
        else if (typeof parameters.start === 'string' || typeof parameters.end === 'string') {
            ctr = 'string';
        }
        else {
            ctr = 'time';
        }
        return Range.classMap[ctr].fromJS(parameters);
    };
    Range.prototype._zeroEndpoint = function () {
        return 0;
    };
    Range.prototype._endpointEqual = function (a, b) {
        return a === b;
    };
    Range.prototype._endpointToString = function (a) {
        return String(a);
    };
    Range.prototype._equalsHelper = function (other) {
        return Boolean(other) &&
            this.bounds === other.bounds &&
            this._endpointEqual(this.start, other.start) &&
            this._endpointEqual(this.end, other.end);
    };
    Range.prototype.toString = function () {
        var bounds = this.bounds;
        return bounds[0] + this._endpointToString(this.start) + ',' + this._endpointToString(this.end) + bounds[1];
    };
    Range.prototype.compare = function (other) {
        var myStart = this.start;
        var otherStart = other.start;
        return myStart < otherStart ? -1 : (otherStart < myStart ? 1 : 0);
    };
    Range.prototype.openStart = function () {
        return this.bounds[0] === '(';
    };
    Range.prototype.openEnd = function () {
        return this.bounds[1] === ')';
    };
    Range.prototype.empty = function () {
        return this._endpointEqual(this.start, this.end) && this.bounds === '[)';
    };
    Range.prototype.degenerate = function () {
        return this._endpointEqual(this.start, this.end) && this.bounds === '[]';
    };
    Range.prototype.contains = function (val) {
        if (val === null)
            return false;
        var start = this.start;
        var end = this.end;
        var bounds = this.bounds;
        if (bounds[0] === '[') {
            if (val < start)
                return false;
        }
        else {
            if (start !== null && val <= start)
                return false;
        }
        if (bounds[1] === ']') {
            if (end < val)
                return false;
        }
        else {
            if (end !== null && end <= val)
                return false;
        }
        return true;
    };
    Range.prototype.intersects = function (other) {
        return this.contains(other.start) || this.contains(other.end)
            || other.contains(this.start) || other.contains(this.end)
            || this._equalsHelper(other);
    };
    Range.prototype.adjacent = function (other) {
        return (this._endpointEqual(this.end, other.start) && this.openEnd() !== other.openStart())
            || (this._endpointEqual(this.start, other.end) && this.openStart() !== other.openEnd());
    };
    Range.prototype.mergeable = function (other) {
        return this.intersects(other) || this.adjacent(other);
    };
    Range.prototype.union = function (other) {
        if (!this.mergeable(other))
            return null;
        return this.extend(other);
    };
    Range.prototype.extent = function () {
        return this;
    };
    Range.prototype.extend = function (other) {
        var thisStart = this.start;
        var thisEnd = this.end;
        var otherStart = other.start;
        var otherEnd = other.end;
        var start;
        var startBound;
        if (thisStart === null || otherStart === null) {
            start = null;
            startBound = '(';
        }
        else if (thisStart < otherStart) {
            start = thisStart;
            startBound = this.bounds[0];
        }
        else {
            start = otherStart;
            startBound = other.bounds[0];
        }
        var end;
        var endBound;
        if (thisEnd === null || otherEnd === null) {
            end = null;
            endBound = ')';
        }
        else if (thisEnd < otherEnd) {
            end = otherEnd;
            endBound = other.bounds[1];
        }
        else {
            end = thisEnd;
            endBound = this.bounds[1];
        }
        return new this.constructor({ start: start, end: end, bounds: startBound + endBound });
    };
    Range.prototype.intersect = function (other) {
        if (!this.mergeable(other))
            return null;
        var thisStart = this.start;
        var thisEnd = this.end;
        var otherStart = other.start;
        var otherEnd = other.end;
        var start;
        var startBound;
        if (thisStart === null || otherStart === null) {
            if (otherStart === null) {
                start = thisStart;
                startBound = this.bounds[0];
            }
            else {
                start = otherStart;
                startBound = other.bounds[0];
            }
        }
        else if (otherStart < thisStart) {
            start = thisStart;
            startBound = this.bounds[0];
        }
        else {
            start = otherStart;
            startBound = other.bounds[0];
        }
        var end;
        var endBound;
        if (thisEnd === null || otherEnd === null) {
            if (thisEnd == null) {
                end = otherEnd;
                endBound = other.bounds[1];
            }
            else {
                end = thisEnd;
                endBound = this.bounds[1];
            }
        }
        else if (otherEnd < thisEnd) {
            end = otherEnd;
            endBound = other.bounds[1];
        }
        else {
            end = thisEnd;
            endBound = this.bounds[1];
        }
        return new this.constructor({ start: start, end: end, bounds: startBound + endBound });
    };
    Range.DEFAULT_BOUNDS = '[)';
    Range.classMap = {};
    return Range;
}());
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


function finiteOrNull(n) {
    return (isNaN(n) || isFinite(n)) ? n : null;
}
var check;
var NumberRange = exports.NumberRange = (function (_super) {
    __extends(NumberRange, _super);
    function NumberRange(parameters) {
        if (isNaN(parameters.start))
            throw new TypeError('`start` must be a number');
        if (isNaN(parameters.end))
            throw new TypeError('`end` must be a number');
        _super.call(this, parameters.start, parameters.end, parameters.bounds);
    }
    NumberRange.isNumberRange = function (candidate) {
        return isInstanceOf(candidate, NumberRange);
    };
    NumberRange.numberBucket = function (num, size, offset) {
        var start = Math.floor((num - offset) / size) * size + offset;
        return new NumberRange({
            start: start,
            end: start + size,
            bounds: Range.DEFAULT_BOUNDS
        });
    };
    NumberRange.fromNumber = function (n) {
        return new NumberRange({ start: n, end: n, bounds: '[]' });
    };
    NumberRange.fromJS = function (parameters) {
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable numberRange");
        }
        var start = parameters.start;
        var end = parameters.end;
        return new NumberRange({
            start: start === null ? null : finiteOrNull(Number(start)),
            end: end === null ? null : finiteOrNull(Number(end)),
            bounds: parameters.bounds
        });
    };
    NumberRange.prototype.valueOf = function () {
        return {
            start: this.start,
            end: this.end,
            bounds: this.bounds
        };
    };
    NumberRange.prototype.toJS = function () {
        var js = {
            start: this.start,
            end: this.end
        };
        if (this.bounds !== Range.DEFAULT_BOUNDS)
            js.bounds = this.bounds;
        return js;
    };
    NumberRange.prototype.toJSON = function () {
        return this.toJS();
    };
    NumberRange.prototype.equals = function (other) {
        return NumberRange.isNumberRange(other) && this._equalsHelper(other);
    };
    NumberRange.prototype.midpoint = function () {
        return (this.start + this.end) / 2;
    };
    NumberRange.type = 'NUMBER_RANGE';
    return NumberRange;
}(Range));
check = NumberRange;
Range.register(NumberRange);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




function toDate(date, name) {
    if (date === null)
        return null;
    if (typeof date === "undefined")
        throw new TypeError("timeRange must have a " + name);
    if (typeof date === 'string' || typeof date === 'number')
        date = parseISODate(date, Expression.defaultParserTimezone);
    if (!date.getDay)
        throw new TypeError("timeRange must have a " + name + " that is a Date");
    return date;
}
var START_OF_TIME = "1000";
var END_OF_TIME = "3000";
function dateToIntervalPart(date) {
    return date.toISOString()
        .replace('.000Z', 'Z')
        .replace(':00Z', 'Z')
        .replace(':00Z', 'Z');
}
var check;
var TimeRange = exports.TimeRange = (function (_super) {
    __extends(TimeRange, _super);
    function TimeRange(parameters) {
        _super.call(this, parameters.start, parameters.end, parameters.bounds);
    }
    TimeRange.isTimeRange = function (candidate) {
        return isInstanceOf(candidate, TimeRange);
    };
    TimeRange.intervalFromDate = function (date) {
        return dateToIntervalPart(date) + '/' + dateToIntervalPart(new Date(date.valueOf() + 1));
    };
    TimeRange.timeBucket = function (date, duration, timezone) {
        if (!date)
            return null;
        var start = duration.floor(date, timezone);
        return new TimeRange({
            start: start,
            end: duration.shift(start, timezone, 1),
            bounds: Range.DEFAULT_BOUNDS
        });
    };
    TimeRange.fromTime = function (t) {
        return new TimeRange({ start: t, end: t, bounds: '[]' });
    };
    TimeRange.fromJS = function (parameters) {
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable timeRange");
        }
        return new TimeRange({
            start: toDate(parameters.start, 'start'),
            end: toDate(parameters.end, 'end'),
            bounds: parameters.bounds
        });
    };
    TimeRange.prototype._zeroEndpoint = function () {
        return new Date(0);
    };
    TimeRange.prototype._endpointEqual = function (a, b) {
        if (a === null) {
            return b === null;
        }
        else {
            return b !== null && a.valueOf() === b.valueOf();
        }
    };
    TimeRange.prototype._endpointToString = function (a) {
        if (!a)
            return 'null';
        return a.toISOString();
    };
    TimeRange.prototype.valueOf = function () {
        return {
            start: this.start,
            end: this.end,
            bounds: this.bounds
        };
    };
    TimeRange.prototype.toJS = function () {
        var js = {
            start: this.start,
            end: this.end
        };
        if (this.bounds !== Range.DEFAULT_BOUNDS)
            js.bounds = this.bounds;
        return js;
    };
    TimeRange.prototype.toJSON = function () {
        return this.toJS();
    };
    TimeRange.prototype.equals = function (other) {
        return TimeRange.isTimeRange(other) && this._equalsHelper(other);
    };
    TimeRange.prototype.toInterval = function () {
        var _a = this, start = _a.start, end = _a.end, bounds = _a.bounds;
        var interval = [START_OF_TIME, END_OF_TIME];
        if (start) {
            if (bounds[0] === '(')
                start = new Date(start.valueOf() + 1);
            interval[0] = dateToIntervalPart(start);
        }
        if (end) {
            if (bounds[1] === ']')
                end = new Date(end.valueOf() + 1);
            interval[1] = dateToIntervalPart(end);
        }
        return interval.join("/");
    };
    TimeRange.prototype.midpoint = function () {
        return new Date((this.start.valueOf() + this.end.valueOf()) / 2);
    };
    TimeRange.prototype.isAligned = function (duration, timezone) {
        var _a = this, start = _a.start, end = _a.end;
        return (!start || duration.isAligned(start, timezone)) && (!end || duration.isAligned(end, timezone));
    };
    TimeRange.type = 'TIME_RANGE';
    return TimeRange;
}(Range));
check = TimeRange;
Range.register(TimeRange);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var check;
var StringRange = exports.StringRange = (function (_super) {
    __extends(StringRange, _super);
    function StringRange(parameters) {
        var start = parameters.start, end = parameters.end;
        if (typeof start !== 'string' && start !== null)
            throw new TypeError('`start` must be a string');
        if (typeof end !== 'string' && end !== null)
            throw new TypeError('`end` must be a string');
        _super.call(this, start, end, parameters.bounds);
    }
    StringRange.isStringRange = function (candidate) {
        return isInstanceOf(candidate, StringRange);
    };
    StringRange.fromString = function (s) {
        return new StringRange({ start: s, end: s, bounds: '[]' });
    };
    StringRange.fromJS = function (parameters) {
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable StringRange");
        }
        var start = parameters.start;
        var end = parameters.end;
        var bounds = parameters.bounds;
        return new StringRange({
            start: start, end: end, bounds: bounds
        });
    };
    StringRange.prototype.valueOf = function () {
        return {
            start: this.start,
            end: this.end,
            bounds: this.bounds
        };
    };
    StringRange.prototype.toJS = function () {
        var js = {
            start: this.start,
            end: this.end
        };
        if (this.bounds !== Range.DEFAULT_BOUNDS)
            js.bounds = this.bounds;
        return js;
    };
    StringRange.prototype.toJSON = function () {
        return this.toJS();
    };
    StringRange.prototype.equals = function (other) {
        return StringRange.isStringRange(other) && this._equalsHelper(other);
    };
    StringRange.prototype.midpoint = function () {
        throw new Error("midpoint not supported in string range");
    };
    StringRange.prototype._zeroEndpoint = function () {
        return "";
    };
    StringRange.type = 'STRING_RANGE';
    return StringRange;
}(Range));
check = StringRange;
Range.register(StringRange);







function dateString(date) {
    return date.toISOString();
}
function arrayFromJS(xs, setType) {
    return xs.map(function (x) { return valueFromJS(x, setType); });
}
function unifyElements(elements) {
    var newElements = Object.create(null);
    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var accumulator = elements_1[_i];
        var newElementsKeys = Object.keys(newElements);
        for (var _a = 0, newElementsKeys_1 = newElementsKeys; _a < newElementsKeys_1.length; _a++) {
            var newElementsKey = newElementsKeys_1[_a];
            var newElement = newElements[newElementsKey];
            var unionElement = accumulator.union(newElement);
            if (unionElement) {
                accumulator = unionElement;
                delete newElements[newElementsKey];
            }
        }
        newElements[accumulator.toString()] = accumulator;
    }
    return Object.keys(newElements).map(function (k) { return newElements[k]; });
}
function intersectElements(elements1, elements2) {
    var newElements = [];
    for (var _i = 0, elements1_1 = elements1; _i < elements1_1.length; _i++) {
        var element1 = elements1_1[_i];
        for (var _a = 0, elements2_1 = elements2; _a < elements2_1.length; _a++) {
            var element2 = elements2_1[_a];
            var intersect = element1.intersect(element2);
            if (intersect)
                newElements.push(intersect);
        }
    }
    return newElements;
}
var typeUpgrades = {
    'NUMBER': 'NUMBER_RANGE',
    'TIME': 'TIME_RANGE',
    'STRING': 'STRING_RANGE'
};
var check;
var Set = exports.Set = (function () {
    function Set(parameters) {
        var setType = parameters.setType;
        this.setType = setType;
        var keyFn = setType === 'TIME' ? dateString : String;
        this.keyFn = keyFn;
        var elements = parameters.elements;
        var newElements = null;
        var hash = Object.create(null);
        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            var key = keyFn(element);
            if (hash[key]) {
                if (!newElements)
                    newElements = elements.slice(0, i);
            }
            else {
                hash[key] = element;
                if (newElements)
                    newElements.push(element);
            }
        }
        if (newElements) {
            elements = newElements;
        }
        if (setType === 'NUMBER_RANGE' || setType === 'TIME_RANGE' || setType === 'STRING_RANGE') {
            elements = unifyElements(elements);
        }
        this.elements = elements;
        this.hash = hash;
    }
    Set.isSet = function (candidate) {
        return isInstanceOf(candidate, Set);
    };
    Set.convertToSet = function (thing) {
        var thingType = getValueType(thing);
        if (isSetType(thingType))
            return thing;
        return Set.fromJS({ setType: thingType, elements: [thing] });
    };
    Set.generalUnion = function (a, b) {
        var aSet = Set.convertToSet(a);
        var bSet = Set.convertToSet(b);
        var aSetType = aSet.setType;
        var bSetType = bSet.setType;
        if (typeUpgrades[aSetType] === bSetType) {
            aSet = aSet.upgradeType();
        }
        else if (typeUpgrades[bSetType] === aSetType) {
            bSet = bSet.upgradeType();
        }
        else if (aSetType !== bSetType) {
            return null;
        }
        return aSet.union(bSet).simplify();
    };
    Set.generalIntersect = function (a, b) {
        var aSet = Set.convertToSet(a);
        var bSet = Set.convertToSet(b);
        var aSetType = aSet.setType;
        var bSetType = bSet.setType;
        if (typeUpgrades[aSetType] === bSetType) {
            aSet = aSet.upgradeType();
        }
        else if (typeUpgrades[bSetType] === aSetType) {
            bSet = bSet.upgradeType();
        }
        else if (aSetType !== bSetType) {
            return null;
        }
        return aSet.intersect(bSet).simplify();
    };
    Set.fromJS = function (parameters) {
        if (Array.isArray(parameters)) {
            parameters = { elements: parameters };
        }
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable set");
        }
        var setType = parameters.setType;
        var elements = parameters.elements;
        if (!setType) {
            setType = getValueType(elements.length ? elements[0] : null);
        }
        return new Set({
            setType: setType,
            elements: arrayFromJS(elements, setType)
        });
    };
    Set.prototype.valueOf = function () {
        return {
            setType: this.setType,
            elements: this.elements
        };
    };
    Set.prototype.toJS = function () {
        return {
            setType: this.setType,
            elements: this.elements.map(valueToJS)
        };
    };
    Set.prototype.toJSON = function () {
        return this.toJS();
    };
    Set.prototype.toString = function () {
        if (this.setType === "NULL")
            return "null";
        return "" + this.elements.map(String).join(", ");
    };
    Set.prototype.equals = function (other) {
        return Set.isSet(other) &&
            this.setType === other.setType &&
            this.elements.length === other.elements.length &&
            this.elements.slice().sort().join('') === other.elements.slice().sort().join('');
    };
    Set.prototype.cardinality = function () {
        return this.size();
    };
    Set.prototype.size = function () {
        return this.elements.length;
    };
    Set.prototype.empty = function () {
        return this.elements.length === 0;
    };
    Set.prototype.simplify = function () {
        var simpleSet = this.downgradeType();
        var simpleSetElements = simpleSet.elements;
        return simpleSetElements.length === 1 ? simpleSetElements[0] : simpleSet;
    };
    Set.prototype.getType = function () {
        return 'SET/' + this.setType;
    };
    Set.prototype.upgradeType = function () {
        if (this.setType === 'NUMBER') {
            return Set.fromJS({
                setType: 'NUMBER_RANGE',
                elements: this.elements.map(NumberRange.fromNumber)
            });
        }
        else if (this.setType === 'TIME') {
            return Set.fromJS({
                setType: 'TIME_RANGE',
                elements: this.elements.map(TimeRange.fromTime)
            });
        }
        else if (this.setType === 'STRING') {
            return Set.fromJS({
                setType: 'STRING_RANGE',
                elements: this.elements.map(StringRange.fromString)
            });
        }
        else {
            return this;
        }
    };
    Set.prototype.downgradeType = function () {
        if (this.setType === 'NUMBER_RANGE' || this.setType === 'TIME_RANGE' || this.setType === 'STRING_RANGE') {
            var elements = this.elements;
            var simpleElements = [];
            for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
                var element = elements_2[_i];
                if (element.degenerate()) {
                    simpleElements.push(element.start);
                }
                else {
                    return this;
                }
            }
            return Set.fromJS(simpleElements);
        }
        else {
            return this;
        }
    };
    Set.prototype.extent = function () {
        var setType = this.setType;
        if (hasOwnProperty(typeUpgrades, setType)) {
            return this.upgradeType().extent();
        }
        if (setType !== 'NUMBER_RANGE' && setType !== 'TIME_RANGE' && setType !== 'STRING_RANGE')
            return null;
        var elements = this.elements;
        var extent = elements[0] || null;
        for (var i = 1; i < elements.length; i++) {
            extent = extent.extend(elements[i]);
        }
        return extent;
    };
    Set.prototype.union = function (other) {
        if (this.empty())
            return other;
        if (other.empty())
            return this;
        if (this.setType !== other.setType) {
            throw new TypeError("can not union sets of different types");
        }
        var newElements = this.elements.slice();
        var otherElements = other.elements;
        for (var _i = 0, otherElements_1 = otherElements; _i < otherElements_1.length; _i++) {
            var el = otherElements_1[_i];
            if (this.contains(el))
                continue;
            newElements.push(el);
        }
        return new Set({
            setType: this.setType,
            elements: newElements
        });
    };
    Set.prototype.intersect = function (other) {
        if (this.empty() || other.empty())
            return Set.EMPTY;
        var setType = this.setType;
        if (this.setType !== other.setType) {
            throw new TypeError("can not intersect sets of different types");
        }
        var thisElements = this.elements;
        var newElements;
        if (setType === 'NUMBER_RANGE' || setType === 'TIME_RANGE' || setType === 'STRING_RANGE') {
            var otherElements = other.elements;
            newElements = intersectElements(thisElements, otherElements);
        }
        else {
            newElements = [];
            for (var _i = 0, thisElements_1 = thisElements; _i < thisElements_1.length; _i++) {
                var el = thisElements_1[_i];
                if (!other.contains(el))
                    continue;
                newElements.push(el);
            }
        }
        return new Set({
            setType: this.setType,
            elements: newElements
        });
    };
    Set.prototype.overlap = function (other) {
        if (this.empty() || other.empty())
            return false;
        if (this.setType !== other.setType) {
            throw new TypeError("can determine overlap sets of different types");
        }
        var thisElements = this.elements;
        for (var _i = 0, thisElements_2 = thisElements; _i < thisElements_2.length; _i++) {
            var el = thisElements_2[_i];
            if (!other.contains(el))
                continue;
            return true;
        }
        return false;
    };
    Set.prototype.contains = function (value) {
        var setType = this.setType;
        if ((setType === 'NUMBER_RANGE' && typeof value === 'number')
            || (setType === 'TIME_RANGE' && isDate(value))
            || (setType === 'STRING_RANGE' && typeof value === 'string')) {
            return this.containsWithin(value);
        }
        return hasOwnProperty(this.hash, this.keyFn(value));
    };
    Set.prototype.containsWithin = function (value) {
        var elements = this.elements;
        for (var k in elements) {
            if (!hasOwnProperty(elements, k))
                continue;
            if (elements[k].contains(value))
                return true;
        }
        return false;
    };
    Set.prototype.add = function (value) {
        var setType = this.setType;
        var valueType = getValueType(value);
        if (setType === 'NULL')
            setType = valueType;
        if (valueType !== 'NULL' && setType !== valueType)
            throw new Error('value type must match');
        if (this.contains(value))
            return this;
        return new Set({
            setType: setType,
            elements: this.elements.concat([value])
        });
    };
    Set.prototype.remove = function (value) {
        if (!this.contains(value))
            return this;
        var keyFn = this.keyFn;
        var key = keyFn(value);
        return new Set({
            setType: this.setType,
            elements: this.elements.filter(function (element) { return keyFn(element) !== key; })
        });
    };
    Set.prototype.toggle = function (value) {
        return this.contains(value) ? this.remove(value) : this.add(value);
    };
    Set.type = 'SET';
    return Set;
}());
check = Set;
Set.EMPTY = Set.fromJS([]);











var foldContext = exports.foldContext = function(d, c) {
    var newContext = Object.create(c);
    for (var k in d) {
        newContext[k] = d[k];
    }
    return newContext;
}
var directionFns = {
    ascending: function (a, b) {
        if (a == null) {
            return b == null ? 0 : -1;
        }
        else {
            if (a.compare)
                return a.compare(b);
            if (b == null)
                return 1;
        }
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    },
    descending: function (a, b) {
        if (b == null) {
            return a == null ? 0 : -1;
        }
        else {
            if (b.compare)
                return b.compare(a);
            if (a == null)
                return 1;
        }
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }
};
function typePreference(type) {
    switch (type) {
        case 'TIME': return 0;
        case 'STRING': return 1;
        case 'DATASET': return 5;
        default: return 2;
    }
}
function uniqueColumns(columns) {
    var seen = {};
    var uniqueColumns = [];
    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
        var column = columns_1[_i];
        if (!seen[column.name]) {
            uniqueColumns.push(column);
            seen[column.name] = true;
        }
    }
    return uniqueColumns;
}
function flattenColumns(nestedColumns, prefixColumns) {
    var flatColumns = [];
    var i = 0;
    var prefixString = '';
    while (i < nestedColumns.length) {
        var nestedColumn = nestedColumns[i];
        if (nestedColumn.type === 'DATASET') {
            nestedColumns = nestedColumn.columns;
            if (prefixColumns)
                prefixString += nestedColumn.name + '.';
            i = 0;
        }
        else {
            flatColumns.push({
                name: prefixString + nestedColumn.name,
                type: nestedColumn.type
            });
            i++;
        }
    }
    return uniqueColumns(flatColumns);
}
function removeLineBreaks(v) {
    return v.replace(/(?:\r\n|\r|\n)/g, ' ');
}
var escapeFnCSV = function (v) {
    v = removeLineBreaks(v);
    if (v.indexOf('"') === -1 && v.indexOf(",") === -1)
        return v;
    return "\"" + v.replace(/"/g, '""') + "\"";
};
var escapeFnTSV = function (v) {
    return removeLineBreaks(v).replace(/\t/g, "").replace(/"/g, '""');
};
var typeOrder = {
    'NULL': 0,
    'TIME': 1,
    'TIME_RANGE': 2,
    'SET/TIME': 3,
    'SET/TIME_RANGE': 4,
    'STRING': 5,
    'SET/STRING': 6,
    'BOOLEAN': 7,
    'NUMBER': 8,
    'NUMBER_RANGE': 9,
    'SET/NUMBER': 10,
    'SET/NUMBER_RANGE': 11,
    'DATASET': 12
};
var defaultFormatter = {
    'NULL': function (v) { return 'NULL'; },
    'TIME': function (v) { return v.toISOString(); },
    'TIME_RANGE': function (v) { return '' + v; },
    'SET/TIME': function (v) { return '' + v; },
    'SET/TIME_RANGE': function (v) { return '' + v; },
    'STRING': function (v) { return '' + v; },
    'SET/STRING': function (v) { return '' + v; },
    'BOOLEAN': function (v) { return '' + v; },
    'NUMBER': function (v) { return '' + v; },
    'NUMBER_RANGE': function (v) { return '' + v; },
    'SET/NUMBER': function (v) { return '' + v; },
    'SET/NUMBER_RANGE': function (v) { return '' + v; },
    'DATASET': function (v) { return 'DATASET'; }
};
function isBoolean(b) {
    return b === true || b === false;
}
function isNumber(n) {
    return n !== null && !isNaN(Number(n));
}
function isString(str) {
    return typeof str === "string";
}
function getAttributeInfo(name, attributeValue) {
    if (attributeValue == null)
        return null;
    if (isDate(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'TIME' });
    }
    else if (isBoolean(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'BOOLEAN' });
    }
    else if (isNumber(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'NUMBER' });
    }
    else if (isString(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'STRING' });
    }
    else if (NumberRange.isNumberRange(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'NUMBER_RANGE' });
    }
    else if (StringRange.isStringRange(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'STRING_RANGE' });
    }
    else if (TimeRange.isTimeRange(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'TIME_RANGE' });
    }
    else if (Set.isSet(attributeValue)) {
        return new AttributeInfo({ name: name, type: attributeValue.getType() });
    }
    else if (Dataset.isDataset(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'DATASET', datasetType: attributeValue.getFullType().datasetType });
    }
    else {
        throw new Error("Could not introspect");
    }
}
function datumFromJS(js) {
    if (typeof js !== 'object')
        throw new TypeError("datum must be an object");
    var datum = Object.create(null);
    for (var k in js) {
        if (!hasOwnProperty(js, k))
            continue;
        datum[k] = valueFromJS(js[k]);
    }
    return datum;
}
function datumToJS(datum) {
    var js = {};
    for (var k in datum) {
        var v = datum[k];
        if (v && v.suppress)
            continue;
        js[k] = valueToJSInlineType(v);
    }
    return js;
}
function joinDatums(datumA, datumB) {
    var newDatum = Object.create(null);
    for (var k in datumA) {
        newDatum[k] = datumA[k];
    }
    for (var k in datumB) {
        newDatum[k] = datumB[k];
    }
    return newDatum;
}
function copy(obj) {
    var newObj = {};
    var k;
    for (k in obj) {
        if (hasOwnProperty(obj, k))
            newObj[k] = obj[k];
    }
    return newObj;
}
var check;
var Dataset = exports.Dataset = (function () {
    function Dataset(parameters) {
        this.attributes = null;
        this.keys = null;
        if (parameters.suppress === true)
            this.suppress = true;
        if (parameters.keys) {
            this.keys = parameters.keys;
        }
        var data = parameters.data;
        if (!Array.isArray(data)) {
            throw new TypeError("must have a `data` array");
        }
        this.data = data;
        var attributes = parameters.attributes;
        if (!attributes)
            attributes = Dataset.getAttributesFromData(data);
        var attributeOverrides = parameters.attributeOverrides;
        if (attributeOverrides) {
            attributes = AttributeInfo.override(attributes, attributeOverrides);
        }
        this.attributes = attributes;
    }
    Dataset.isDataset = function (candidate) {
        return isInstanceOf(candidate, Dataset);
    };
    Dataset.getAttributesFromData = function (data) {
        if (!data.length)
            return [];
        var attributeNamesToIntrospect = Object.keys(data[0]);
        var attributes = [];
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var datum = data_1[_i];
            var attributeNamesStillToIntrospect = [];
            for (var _a = 0, attributeNamesToIntrospect_1 = attributeNamesToIntrospect; _a < attributeNamesToIntrospect_1.length; _a++) {
                var attributeNameToIntrospect = attributeNamesToIntrospect_1[_a];
                var attributeInfo = getAttributeInfo(attributeNameToIntrospect, datum[attributeNameToIntrospect]);
                if (attributeInfo) {
                    attributes.push(attributeInfo);
                }
                else {
                    attributeNamesStillToIntrospect.push(attributeNameToIntrospect);
                }
            }
            attributeNamesToIntrospect = attributeNamesStillToIntrospect;
            if (!attributeNamesToIntrospect.length)
                break;
        }
        for (var _b = 0, attributeNamesToIntrospect_2 = attributeNamesToIntrospect; _b < attributeNamesToIntrospect_2.length; _b++) {
            var attributeName = attributeNamesToIntrospect_2[_b];
            attributes.push(new AttributeInfo({ name: attributeName, type: 'STRING' }));
        }
        attributes.sort(function (a, b) {
            var typeDiff = typeOrder[a.type] - typeOrder[b.type];
            if (typeDiff)
                return typeDiff;
            return a.name.localeCompare(b.name);
        });
        return attributes;
    };
    Dataset.parseJSON = function (text) {
        text = text.trim();
        var firstChar = text[0];
        if (firstChar[0] === '[') {
            try {
                return JSON.parse(text);
            }
            catch (e) {
                throw new Error("could not parse");
            }
        }
        else if (firstChar[0] === '{') {
            return text.split(/\r?\n/).map(function (line, i) {
                try {
                    return JSON.parse(line);
                }
                catch (e) {
                    throw new Error("problem in line: " + i + ": '" + line + "'");
                }
            });
        }
        else {
            throw new Error("Unsupported start, starts with '" + firstChar[0] + "'");
        }
    };
    Dataset.fromJS = function (parameters) {
        if (Array.isArray(parameters)) {
            parameters = { data: parameters };
        }
        if (!Array.isArray(parameters.data)) {
            throw new Error('must have data');
        }
        var value = {};
        if (hasOwnProperty(parameters, 'attributes')) {
            value.attributes = AttributeInfo.fromJSs(parameters.attributes);
        }
        else if (hasOwnProperty(parameters, 'attributeOverrides')) {
            value.attributeOverrides = AttributeInfo.fromJSs(parameters.attributeOverrides);
        }
        value.keys = parameters.keys;
        value.data = parameters.data.map(datumFromJS);
        return new Dataset(value);
    };
    Dataset.prototype.valueOf = function () {
        var value = {};
        if (this.suppress)
            value.suppress = true;
        if (this.attributes)
            value.attributes = this.attributes;
        if (this.keys)
            value.keys = this.keys;
        value.data = this.data;
        return value;
    };
    Dataset.prototype.toJS = function () {
        return this.data.map(datumToJS);
    };
    Dataset.prototype.toString = function () {
        return "Dataset(" + this.data.length + ")";
    };
    Dataset.prototype.toJSON = function () {
        return this.toJS();
    };
    Dataset.prototype.equals = function (other) {
        return Dataset.isDataset(other) &&
            this.data.length === other.data.length;
    };
    Dataset.prototype.hide = function () {
        var value = this.valueOf();
        value.suppress = true;
        return new Dataset(value);
    };
    Dataset.prototype.basis = function () {
        var data = this.data;
        return data.length === 1 && Object.keys(data[0]).length === 0;
    };
    Dataset.prototype.hasExternal = function () {
        if (!this.data.length)
            return false;
        return datumHasExternal(this.data[0]);
    };
    Dataset.prototype.getFullType = function () {
        var attributes = this.attributes;
        if (!attributes)
            throw new Error("dataset has not been introspected");
        var myDatasetType = {};
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var attribute = attributes_1[_i];
            var attrName = attribute.name;
            if (attribute.type === 'DATASET') {
                myDatasetType[attrName] = {
                    type: 'DATASET',
                    datasetType: attribute.datasetType
                };
            }
            else {
                myDatasetType[attrName] = {
                    type: attribute.type
                };
            }
        }
        return {
            type: 'DATASET',
            datasetType: myDatasetType
        };
    };
    Dataset.prototype.select = function (attrs) {
        var attributes = this.attributes;
        var newAttributes = [];
        var attrLookup = Object.create(null);
        for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
            var attr = attrs_1[_i];
            attrLookup[attr] = true;
            var existingAttribute = findByName(attributes, attr);
            if (existingAttribute)
                newAttributes.push(existingAttribute);
        }
        var data = this.data;
        var n = data.length;
        var newData = new Array(n);
        for (var i = 0; i < n; i++) {
            var datum = data[i];
            var newDatum = Object.create(null);
            for (var key in datum) {
                if (attrLookup[key]) {
                    newDatum[key] = datum[key];
                }
            }
            newData[i] = newDatum;
        }
        var value = this.valueOf();
        value.attributes = newAttributes;
        value.data = newData;
        return new Dataset(value);
    };
    Dataset.prototype.apply = function (name, exFn, type, context) {
        var data = this.data;
        var n = data.length;
        var newData = new Array(n);
        for (var i = 0; i < n; i++) {
            var datum = data[i];
            var newDatum = Object.create(null);
            for (var key in datum)
                newDatum[key] = datum[key];
            newDatum[name] = exFn(datum, context, i);
            newData[i] = newDatum;
        }
        var datasetType = null;
        if (type === 'DATASET' && newData[0] && newData[0][name]) {
            datasetType = newData[0][name].getFullType().datasetType;
        }
        var value = this.valueOf();
        value.attributes = overrideByName(value.attributes, new AttributeInfo({ name: name, type: type, datasetType: datasetType }));
        value.data = newData;
        return new Dataset(value);
    };
    Dataset.prototype.applyPromise = function (name, exFn, type, context) {
        var _this = this;
        var value = this.valueOf();
        var promises = value.data.map(function (datum) { return exFn(datum, context); });
        return Q.all(promises).then(function (values) {
            return _this.apply(name, (function (d, c, i) { return values[i]; }), type, context);
        });
    };
    Dataset.prototype.filter = function (exFn, context) {
        var value = this.valueOf();
        value.data = value.data.filter(function (datum) { return exFn(datum, context); });
        return new Dataset(value);
    };
    Dataset.prototype.sort = function (exFn, direction, context) {
        var value = this.valueOf();
        var directionFn = directionFns[direction];
        value.data = this.data.sort(function (a, b) {
            return directionFn(exFn(a, context), exFn(b, context));
        });
        return new Dataset(value);
    };
    Dataset.prototype.limit = function (limit) {
        var data = this.data;
        if (data.length <= limit)
            return this;
        var value = this.valueOf();
        value.data = data.slice(0, limit);
        return new Dataset(value);
    };
    Dataset.prototype.count = function () {
        return this.data.length;
    };
    Dataset.prototype.sum = function (exFn, context) {
        var data = this.data;
        var sum = 0;
        for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
            var datum = data_2[_i];
            sum += exFn(datum, context);
        }
        return sum;
    };
    Dataset.prototype.average = function (exFn, context) {
        var count = this.count();
        return count ? (this.sum(exFn, context) / count) : null;
    };
    Dataset.prototype.min = function (exFn, context) {
        var data = this.data;
        var min = Infinity;
        for (var _i = 0, data_3 = data; _i < data_3.length; _i++) {
            var datum = data_3[_i];
            var v = exFn(datum, context);
            if (v < min)
                min = v;
        }
        return min;
    };
    Dataset.prototype.max = function (exFn, context) {
        var data = this.data;
        var max = -Infinity;
        for (var _i = 0, data_4 = data; _i < data_4.length; _i++) {
            var datum = data_4[_i];
            var v = exFn(datum, context);
            if (max < v)
                max = v;
        }
        return max;
    };
    Dataset.prototype.countDistinct = function (exFn, context) {
        var data = this.data;
        var seen = Object.create(null);
        var count = 0;
        for (var _i = 0, data_5 = data; _i < data_5.length; _i++) {
            var datum = data_5[_i];
            var v = exFn(datum, context);
            if (!seen[v]) {
                seen[v] = 1;
                ++count;
            }
        }
        return count;
    };
    Dataset.prototype.quantile = function (exFn, quantile, context) {
        var data = this.data;
        var vs = [];
        for (var _i = 0, data_6 = data; _i < data_6.length; _i++) {
            var datum = data_6[_i];
            var v = exFn(datum, context);
            if (v != null)
                vs.push(v);
        }
        vs.sort(function (a, b) { return a - b; });
        var n = vs.length;
        if (quantile === 0)
            return vs[0];
        if (quantile === 1)
            return vs[n - 1];
        var rank = n * quantile - 1;
        if (rank === Math.floor(rank)) {
            return (vs[rank] + vs[rank + 1]) / 2;
        }
        else {
            return vs[Math.ceil(rank)];
        }
    };
    Dataset.prototype.split = function (splitFns, datasetName, context) {
        var _a = this, data = _a.data, attributes = _a.attributes;
        var keys = Object.keys(splitFns);
        var numberOfKeys = keys.length;
        var splitFnList = keys.map(function (k) { return splitFns[k]; });
        var splits = {};
        var datumGroups = {};
        var finalData = [];
        var finalDataset = [];
        function addDatum(datum, valueList) {
            var key = valueList.join(';_PLYw00d_;');
            if (hasOwnProperty(datumGroups, key)) {
                datumGroups[key].push(datum);
            }
            else {
                var newDatum = Object.create(null);
                for (var i = 0; i < numberOfKeys; i++) {
                    newDatum[keys[i]] = valueList[i];
                }
                finalDataset.push(datumGroups[key] = [datum]);
                splits[key] = newDatum;
                finalData.push(newDatum);
            }
        }
        for (var _i = 0, data_7 = data; _i < data_7.length; _i++) {
            var datum = data_7[_i];
            var valueList = splitFnList.map(function (splitFn) { return splitFn(datum, context); });
            if (Set.isSet(valueList[0])) {
                if (valueList.length > 1)
                    throw new Error('multi-dimensional set split is not implemented');
                var elements = valueList[0].elements;
                for (var _b = 0, elements_1 = elements; _b < elements_1.length; _b++) {
                    var element = elements_1[_b];
                    addDatum(datum, [element]);
                }
            }
            else {
                addDatum(datum, valueList);
            }
        }
        for (var i = 0; i < finalData.length; i++) {
            finalData[i][datasetName] = new Dataset({
                suppress: true,
                attributes: attributes,
                data: finalDataset[i]
            });
        }
        return new Dataset({
            keys: keys,
            data: finalData
        });
    };
    Dataset.prototype.introspect = function () {
        console.error('introspection is always done, `.introspect()` method never needs to be called');
    };
    Dataset.prototype.getExternals = function () {
        if (this.data.length === 0)
            return [];
        var datum = this.data[0];
        var externals = [];
        Object.keys(datum).forEach(function (applyName) {
            var applyValue = datum[applyName];
            if (applyValue instanceof Dataset) {
                externals.push.apply(externals, applyValue.getExternals());
            }
        });
        return External.deduplicateExternals(externals);
    };
    Dataset.prototype.join = function (other) {
        if (!other)
            return this;
        var thisKey = this.keys[0];
        if (!thisKey)
            throw new Error('join lhs must have a key (be a product of a split)');
        var otherKey = other.keys[0];
        if (!otherKey)
            throw new Error('join rhs must have a key (be a product of a split)');
        var thisData = this.data;
        var otherData = other.data;
        var k;
        var mapping = Object.create(null);
        for (var i = 0; i < thisData.length; i++) {
            var datum = thisData[i];
            k = String(thisKey ? datum[thisKey] : i);
            mapping[k] = [datum];
        }
        for (var i = 0; i < otherData.length; i++) {
            var datum = otherData[i];
            k = String(otherKey ? datum[otherKey] : i);
            if (!mapping[k])
                mapping[k] = [];
            mapping[k].push(datum);
        }
        var newData = [];
        for (var j in mapping) {
            var datums = mapping[j];
            if (datums.length === 1) {
                newData.push(datums[0]);
            }
            else {
                newData.push(joinDatums(datums[0], datums[1]));
            }
        }
        return new Dataset({ data: newData });
    };
    Dataset.prototype.findDatumByAttribute = function (attribute, value) {
        return find(this.data, function (d) { return generalEqual(d[attribute], value); });
    };
    Dataset.prototype.getNestedColumns = function () {
        var nestedColumns = [];
        var attributes = this.attributes;
        var subDatasetAdded = false;
        for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++) {
            var attribute = attributes_2[_i];
            var column = {
                name: attribute.name,
                type: attribute.type
            };
            if (attribute.type === 'DATASET') {
                var subDataset = this.data[0][attribute.name];
                if (!subDatasetAdded && Dataset.isDataset(subDataset)) {
                    subDatasetAdded = true;
                    column.columns = subDataset.getNestedColumns();
                    nestedColumns.push(column);
                }
            }
            else {
                nestedColumns.push(column);
            }
        }
        return nestedColumns;
    };
    Dataset.prototype.getColumns = function (options) {
        if (options === void 0) { options = {}; }
        var prefixColumns = options.prefixColumns;
        return flattenColumns(this.getNestedColumns(), prefixColumns);
    };
    Dataset.prototype._flattenHelper = function (nestedColumns, prefix, order, nestingName, parentName, nesting, context, flat) {
        var nestedColumnsLength = nestedColumns.length;
        if (!nestedColumnsLength)
            return;
        var data = this.data;
        var datasetColumn = nestedColumns.filter(function (nestedColumn) { return nestedColumn.type === 'DATASET'; })[0];
        for (var _i = 0, data_8 = data; _i < data_8.length; _i++) {
            var datum = data_8[_i];
            var flatDatum = context ? copy(context) : {};
            if (nestingName)
                flatDatum[nestingName] = nesting;
            if (parentName)
                flatDatum[parentName] = context;
            for (var _a = 0, nestedColumns_1 = nestedColumns; _a < nestedColumns_1.length; _a++) {
                var flattenedColumn = nestedColumns_1[_a];
                if (flattenedColumn.type === 'DATASET')
                    continue;
                var flatName = (prefix !== null ? prefix : '') + flattenedColumn.name;
                flatDatum[flatName] = datum[flattenedColumn.name];
            }
            if (datasetColumn) {
                var nextPrefix = null;
                if (prefix !== null)
                    nextPrefix = prefix + datasetColumn.name + '.';
                if (order === 'preorder')
                    flat.push(flatDatum);
                datum[datasetColumn.name]._flattenHelper(datasetColumn.columns, nextPrefix, order, nestingName, parentName, nesting + 1, flatDatum, flat);
                if (order === 'postorder')
                    flat.push(flatDatum);
            }
            if (!datasetColumn)
                flat.push(flatDatum);
        }
    };
    Dataset.prototype.flatten = function (options) {
        if (options === void 0) { options = {}; }
        var prefixColumns = options.prefixColumns;
        var order = options.order;
        var nestingName = options.nestingName;
        var parentName = options.parentName;
        var nestedColumns = this.getNestedColumns();
        var flatData = [];
        if (nestedColumns.length) {
            this._flattenHelper(nestedColumns, (prefixColumns ? '' : null), order, nestingName, parentName, 0, null, flatData);
        }
        return flatData;
    };
    Dataset.prototype.toTabular = function (tabulatorOptions) {
        var formatter = tabulatorOptions.formatter || {};
        var finalizer = tabulatorOptions.finalizer;
        var data = this.flatten(tabulatorOptions);
        var columns = this.getColumns(tabulatorOptions);
        var lines = [];
        lines.push(columns.map(function (c) { return c.name; }).join(tabulatorOptions.separator || ','));
        for (var i = 0; i < data.length; i++) {
            var datum = data[i];
            lines.push(columns.map(function (c) {
                var value = datum[c.name];
                var formatted = String((formatter[c.type] || defaultFormatter[c.type])(value));
                var finalized = formatted && finalizer ? finalizer(formatted) : formatted;
                return finalized;
            }).join(tabulatorOptions.separator || ','));
        }
        var lineBreak = tabulatorOptions.lineBreak || '\n';
        return lines.join(lineBreak) + (tabulatorOptions.finalLineBreak === 'include' && lines.length > 0 ? lineBreak : '');
    };
    Dataset.prototype.toCSV = function (tabulatorOptions) {
        if (tabulatorOptions === void 0) { tabulatorOptions = {}; }
        tabulatorOptions.finalizer = escapeFnCSV;
        tabulatorOptions.separator = tabulatorOptions.separator || ',';
        tabulatorOptions.lineBreak = tabulatorOptions.lineBreak || '\r\n';
        tabulatorOptions.finalLineBreak = tabulatorOptions.finalLineBreak || 'suppress';
        return this.toTabular(tabulatorOptions);
    };
    Dataset.prototype.toTSV = function (tabulatorOptions) {
        if (tabulatorOptions === void 0) { tabulatorOptions = {}; }
        tabulatorOptions.finalizer = escapeFnTSV;
        tabulatorOptions.separator = tabulatorOptions.separator || '\t';
        tabulatorOptions.lineBreak = tabulatorOptions.lineBreak || '\r\n';
        tabulatorOptions.finalLineBreak = tabulatorOptions.finalLineBreak || 'suppress';
        return this.toTabular(tabulatorOptions);
    };
    Dataset.type = 'DATASET';
    return Dataset;
}());
check = Dataset;














function nullMap(xs, fn) {
    if (!xs)
        return null;
    var res = [];
    for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {
        var x = xs_1[_i];
        var y = fn(x);
        if (y)
            res.push(y);
    }
    return res.length ? res : null;
}
function filterToAnds(filter) {
    if (filter.equals(Expression.TRUE))
        return [];
    return filter.getExpressionPattern('and') || [filter];
}
function filterDiff(strongerFilter, weakerFilter) {
    var strongerFilterAnds = filterToAnds(strongerFilter);
    var weakerFilterAnds = filterToAnds(weakerFilter);
    if (weakerFilterAnds.length > strongerFilterAnds.length)
        return null;
    for (var i = 0; i < weakerFilterAnds.length; i++) {
        if (!(weakerFilterAnds[i].equals(strongerFilterAnds[i])))
            return null;
    }
    return Expression.and(strongerFilterAnds.slice(weakerFilterAnds.length));
}
function getCommonFilter(filter1, filter2) {
    var filter1Ands = filterToAnds(filter1);
    var filter2Ands = filterToAnds(filter2);
    var minLength = Math.min(filter1Ands.length, filter2Ands.length);
    var commonExpressions = [];
    for (var i = 0; i < minLength; i++) {
        if (!filter1Ands[i].equals(filter2Ands[i]))
            break;
        commonExpressions.push(filter1Ands[i]);
    }
    return Expression.and(commonExpressions);
}
function mergeDerivedAttributes(derivedAttributes1, derivedAttributes2) {
    var derivedAttributes = Object.create(null);
    for (var k in derivedAttributes1) {
        derivedAttributes[k] = derivedAttributes1[k];
    }
    for (var k in derivedAttributes2) {
        if (hasOwnProperty(derivedAttributes, k) && !derivedAttributes[k].equals(derivedAttributes2[k])) {
            throw new Error("can not currently redefine conflicting " + k);
        }
        derivedAttributes[k] = derivedAttributes2[k];
    }
    return derivedAttributes;
}
function getSampleValue(valueType, ex) {
    switch (valueType) {
        case 'BOOLEAN':
            return true;
        case 'NUMBER':
            return 4;
        case 'NUMBER_RANGE':
            var numberBucketAction;
            if (ex instanceof ChainExpression && (numberBucketAction = ex.getSingleAction('numberBucket'))) {
                return new NumberRange({
                    start: numberBucketAction.offset,
                    end: numberBucketAction.offset + numberBucketAction.size
                });
            }
            else {
                return new NumberRange({ start: 0, end: 1 });
            }
        case 'TIME':
            return new Date('2015-03-14T00:00:00');
        case 'TIME_RANGE':
            var timeBucketAction;
            if (ex instanceof ChainExpression && (timeBucketAction = ex.getSingleAction('timeBucket'))) {
                var timezone = timeBucketAction.timezone || Timezone.UTC;
                var start = timeBucketAction.duration.floor(new Date('2015-03-14T00:00:00'), timezone);
                return new TimeRange({
                    start: start,
                    end: timeBucketAction.duration.shift(start, timezone, 1)
                });
            }
            else {
                return new TimeRange({ start: new Date('2015-03-14T00:00:00'), end: new Date('2015-03-15T00:00:00') });
            }
        case 'STRING':
            if (ex instanceof RefExpression) {
                return 'some_' + ex.name;
            }
            else {
                return 'something';
            }
        case 'SET/STRING':
            if (ex instanceof RefExpression) {
                return Set.fromJS([ex.name + '1']);
            }
            else {
                return Set.fromJS(['something']);
            }
        case 'STRING_RANGE':
            if (ex instanceof RefExpression) {
                return StringRange.fromJS({ start: 'some_' + ex.name, end: null });
            }
            else {
                return StringRange.fromJS({ start: 'something', end: null });
            }
        default:
            throw new Error("unsupported simulation on: " + valueType);
    }
}
function immutableAdd(obj, key, value) {
    var newObj = Object.create(null);
    for (var k in obj)
        newObj[k] = obj[k];
    newObj[key] = value;
    return newObj;
}
function findApplyByExpression(applies, expression) {
    for (var _i = 0, applies_1 = applies; _i < applies_1.length; _i++) {
        var apply = applies_1[_i];
        if (apply.expression.equals(expression))
            return apply;
    }
    return null;
}
var External = exports.External = (function () {
    function External(parameters, dummy) {
        if (dummy === void 0) { dummy = null; }
        this.attributes = null;
        this.attributeOverrides = null;
        this.rawAttributes = null;
        if (dummy !== dummyObject) {
            throw new TypeError("can not call `new External` directly use External.fromJS instead");
        }
        this.engine = parameters.engine;
        var version = null;
        if (parameters.version) {
            version = External.extractVersion(parameters.version);
            if (!version)
                throw new Error("invalid version " + parameters.version);
        }
        this.version = version;
        this.source = parameters.source;
        this.suppress = Boolean(parameters.suppress);
        this.rollup = Boolean(parameters.rollup);
        if (parameters.attributes) {
            this.attributes = parameters.attributes;
        }
        if (parameters.attributeOverrides) {
            this.attributeOverrides = parameters.attributeOverrides;
        }
        this.derivedAttributes = parameters.derivedAttributes || {};
        if (parameters.delegates) {
            this.delegates = parameters.delegates;
        }
        this.concealBuckets = parameters.concealBuckets;
        this.rawAttributes = parameters.rawAttributes;
        this.requester = parameters.requester;
        this.mode = parameters.mode || 'raw';
        this.filter = parameters.filter || Expression.TRUE;
        switch (this.mode) {
            case 'raw':
                this.select = parameters.select;
                this.sort = parameters.sort;
                this.limit = parameters.limit;
                break;
            case 'value':
                this.valueExpression = parameters.valueExpression;
                break;
            case 'total':
                this.applies = parameters.applies || [];
                break;
            case 'split':
                this.dataName = parameters.dataName;
                this.split = parameters.split;
                if (!this.split)
                    throw new Error('must have split action in split mode');
                this.applies = parameters.applies || [];
                this.sort = parameters.sort;
                this.limit = parameters.limit;
                this.havingFilter = parameters.havingFilter || Expression.TRUE;
                break;
        }
    }
    External.isExternal = function (candidate) {
        return isInstanceOf(candidate, External);
    };
    External.extractVersion = function (v) {
        if (!v)
            return null;
        var m = v.match(/^\d+\.\d+\.\d+(?:-[\w\-]+)?/);
        return m ? m[0] : null;
    };
    External.versionLessThan = function (va, vb) {
        var pa = va.split('-')[0].split('.');
        var pb = vb.split('-')[0].split('.');
        if (pa[0] !== pb[0])
            return pa[0] < pb[0];
        if (pa[1] !== pb[1])
            return pa[1] < pb[1];
        return pa[2] < pb[2];
    };
    External.deduplicateExternals = function (externals) {
        if (externals.length < 2)
            return externals;
        var uniqueExternals = [externals[0]];
        function addToUniqueExternals(external) {
            for (var _i = 0, uniqueExternals_1 = uniqueExternals; _i < uniqueExternals_1.length; _i++) {
                var uniqueExternal = uniqueExternals_1[_i];
                if (uniqueExternal.equalBase(external))
                    return;
            }
            uniqueExternals.push(external);
        }
        for (var i = 1; i < externals.length; i++)
            addToUniqueExternals(externals[i]);
        return uniqueExternals;
    };
    External.makeZeroDatum = function (applies) {
        var newDatum = Object.create(null);
        for (var _i = 0, applies_2 = applies; _i < applies_2.length; _i++) {
            var apply = applies_2[_i];
            var applyName = apply.name;
            if (applyName[0] === '_')
                continue;
            newDatum[applyName] = 0;
        }
        return newDatum;
    };
    External.normalizeAndAddApply = function (attributesAndApplies, apply) {
        var attributes = attributesAndApplies.attributes, applies = attributesAndApplies.applies;
        var expressions = Object.create(null);
        for (var _i = 0, applies_3 = applies; _i < applies_3.length; _i++) {
            var existingApply = applies_3[_i];
            expressions[existingApply.name] = existingApply.expression;
        }
        apply = apply.changeExpression(apply.expression.resolveWithExpressions(expressions, 'leave').simplify());
        return {
            attributes: overrideByName(attributes, new AttributeInfo({ name: apply.name, type: apply.expression.type })),
            applies: overrideByName(applies, apply)
        };
    };
    External.segregationAggregateApplies = function (applies) {
        var aggregateApplies = [];
        var postAggregateApplies = [];
        var nameIndex = 0;
        var appliesToSegregate = [];
        for (var _i = 0, applies_4 = applies; _i < applies_4.length; _i++) {
            var apply = applies_4[_i];
            var applyExpression = apply.expression;
            if (applyExpression instanceof ChainExpression) {
                var actions = applyExpression.actions;
                if (actions[actions.length - 1].isAggregate()) {
                    aggregateApplies.push(apply);
                    continue;
                }
            }
            appliesToSegregate.push(apply);
        }
        for (var _a = 0, appliesToSegregate_1 = appliesToSegregate; _a < appliesToSegregate_1.length; _a++) {
            var apply = appliesToSegregate_1[_a];
            var newExpression = apply.expression.substituteAction(function (action) {
                return action.isAggregate();
            }, function (preEx, action) {
                var aggregateChain = preEx.performAction(action);
                var existingApply = findApplyByExpression(aggregateApplies, aggregateChain);
                if (existingApply) {
                    return $(existingApply.name, existingApply.expression.type);
                }
                else {
                    var name = '!T_' + (nameIndex++);
                    aggregateApplies.push(new ApplyAction({
                        action: 'apply',
                        name: name,
                        expression: aggregateChain
                    }));
                    return $(name, aggregateChain.type);
                }
            });
            postAggregateApplies.push(apply.changeExpression(newExpression));
        }
        return {
            aggregateApplies: aggregateApplies,
            postAggregateApplies: postAggregateApplies
        };
    };
    External.getCommonFilterFromExternals = function (externals) {
        if (!externals.length)
            throw new Error('must have externals');
        var commonFilter = externals[0].filter;
        for (var i = 1; i < externals.length; i++) {
            commonFilter = getCommonFilter(commonFilter, externals[i].filter);
        }
        return commonFilter;
    };
    External.getMergedDerivedAttributesFromExternals = function (externals) {
        if (!externals.length)
            throw new Error('must have externals');
        var derivedAttributes = externals[0].derivedAttributes;
        for (var i = 1; i < externals.length; i++) {
            derivedAttributes = mergeDerivedAttributes(derivedAttributes, externals[i].derivedAttributes);
        }
        return derivedAttributes;
    };
    External.getSimpleInflater = function (splitExpression, label) {
        switch (splitExpression.type) {
            case 'BOOLEAN': return External.booleanInflaterFactory(label);
            case 'NUMBER': return External.numberInflaterFactory(label);
            case 'TIME': return External.timeInflaterFactory(label);
            default: return null;
        }
    };
    External.booleanInflaterFactory = function (label) {
        return function (d) {
            var v = '' + d[label];
            switch (v) {
                case 'null':
                    d[label] = null;
                    break;
                case '0':
                case 'false':
                    d[label] = false;
                    break;
                case '1':
                case 'true':
                    d[label] = true;
                    break;
                default:
                    throw new Error("got strange result from boolean: " + v);
            }
        };
    };
    External.timeRangeInflaterFactory = function (label, duration, timezone) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            var start = new Date(v);
            d[label] = new TimeRange({ start: start, end: duration.shift(start, timezone) });
        };
    };
    External.numberRangeInflaterFactory = function (label, rangeSize) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            var start = Number(v);
            d[label] = new NumberRange({
                start: start,
                end: safeAdd(start, rangeSize)
            });
        };
    };
    External.numberInflaterFactory = function (label) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            d[label] = Number(v);
        };
    };
    External.timeInflaterFactory = function (label) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            d[label] = new Date(v);
        };
    };
    External.setStringInflaterFactory = function (label) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            if (typeof v === 'string')
                v = [v];
            d[label] = Set.fromJS({
                setType: 'STRING',
                elements: v
            });
        };
    };
    External.setCardinalityInflaterFactory = function (label) {
        return function (d) {
            var v = d[label];
            d[label] = Array.isArray(v) ? v.length : 1;
        };
    };
    External.jsToValue = function (parameters, requester) {
        var value = {
            engine: parameters.engine,
            version: parameters.version,
            source: parameters.source,
            suppress: true,
            rollup: parameters.rollup,
            concealBuckets: Boolean(parameters.concealBuckets),
            requester: requester
        };
        if (parameters.attributes) {
            value.attributes = AttributeInfo.fromJSs(parameters.attributes);
        }
        if (parameters.attributeOverrides) {
            value.attributeOverrides = AttributeInfo.fromJSs(parameters.attributeOverrides);
        }
        if (parameters.derivedAttributes) {
            value.derivedAttributes = Expression.expressionLookupFromJS(parameters.derivedAttributes);
        }
        value.filter = parameters.filter ? Expression.fromJS(parameters.filter) : Expression.TRUE;
        return value;
    };
    External.register = function (ex, id) {
        if (id === void 0) { id = null; }
        if (!id)
            id = ex.name.replace('External', '').replace(/^\w/, function (s) { return s.toLowerCase(); });
        External.classMap[id] = ex;
    };
    External.getConstructorFor = function (engine) {
        var classFn = External.classMap[engine];
        if (!classFn)
            throw new Error("unsupported engine '" + engine + "'");
        return classFn;
    };
    External.fromJS = function (parameters, requester) {
        if (requester === void 0) { requester = null; }
        if (!hasOwnProperty(parameters, "engine")) {
            throw new Error("external `engine` must be defined");
        }
        var engine = parameters.engine;
        if (typeof engine !== "string")
            throw new Error("engine must be a string");
        var ClassFn = External.getConstructorFor(engine);
        if (!requester && hasOwnProperty(parameters, 'requester')) {
            console.warn("'requester' parameter should be passed as context (2nd argument)");
            requester = parameters.requester;
        }
        if (!parameters.source) {
            parameters.source = parameters.dataSource || parameters.table;
        }
        return ClassFn.fromJS(parameters, requester);
    };
    External.fromValue = function (parameters) {
        var engine = parameters.engine;
        var ClassFn = External.getConstructorFor(engine);
        return new ClassFn(parameters);
    };
    External.prototype._ensureEngine = function (engine) {
        if (!this.engine) {
            this.engine = engine;
            return;
        }
        if (this.engine !== engine) {
            throw new TypeError("incorrect engine '" + this.engine + "' (needs to be: '" + engine + "')");
        }
    };
    External.prototype._ensureMinVersion = function (minVersion) {
        if (this.version && External.versionLessThan(this.version, minVersion)) {
            throw new Error("only " + this.engine + " versions >= " + minVersion + " are supported");
        }
    };
    External.prototype.valueOf = function () {
        var value = {
            engine: this.engine,
            version: this.version,
            source: this.source,
            rollup: this.rollup,
            mode: this.mode
        };
        if (this.suppress)
            value.suppress = this.suppress;
        if (this.attributes)
            value.attributes = this.attributes;
        if (this.attributeOverrides)
            value.attributeOverrides = this.attributeOverrides;
        if (nonEmptyLookup(this.derivedAttributes))
            value.derivedAttributes = this.derivedAttributes;
        if (this.delegates)
            value.delegates = this.delegates;
        value.concealBuckets = this.concealBuckets;
        if (this.rawAttributes) {
            value.rawAttributes = this.rawAttributes;
        }
        if (this.requester) {
            value.requester = this.requester;
        }
        if (this.dataName) {
            value.dataName = this.dataName;
        }
        value.filter = this.filter;
        if (this.valueExpression) {
            value.valueExpression = this.valueExpression;
        }
        if (this.select) {
            value.select = this.select;
        }
        if (this.split) {
            value.split = this.split;
        }
        if (this.applies) {
            value.applies = this.applies;
        }
        if (this.sort) {
            value.sort = this.sort;
        }
        if (this.limit) {
            value.limit = this.limit;
        }
        if (this.havingFilter) {
            value.havingFilter = this.havingFilter;
        }
        return value;
    };
    External.prototype.toJS = function () {
        var js = {
            engine: this.engine,
            source: this.source
        };
        if (this.version)
            js.version = this.version;
        if (this.rollup)
            js.rollup = true;
        if (this.attributes)
            js.attributes = AttributeInfo.toJSs(this.attributes);
        if (this.attributeOverrides)
            js.attributeOverrides = AttributeInfo.toJSs(this.attributeOverrides);
        if (nonEmptyLookup(this.derivedAttributes))
            js.derivedAttributes = Expression.expressionLookupToJS(this.derivedAttributes);
        if (this.concealBuckets)
            js.concealBuckets = true;
        if (this.rawAttributes)
            js.rawAttributes = AttributeInfo.toJSs(this.rawAttributes);
        if (!this.filter.equals(Expression.TRUE)) {
            js.filter = this.filter.toJS();
        }
        return js;
    };
    External.prototype.toJSON = function () {
        return this.toJS();
    };
    External.prototype.toString = function () {
        var mode = this.mode;
        switch (mode) {
            case 'raw':
                return "ExternalRaw(" + this.filter + ")";
            case 'value':
                return "ExternalValue(" + this.valueExpression + ")";
            case 'total':
                return "ExternalTotal(" + this.applies.length + ")";
            case 'split':
                return "ExternalSplit(" + this.split + ", " + this.applies.length + ")";
            default:
                throw new Error("unknown mode: " + mode);
        }
    };
    External.prototype.equals = function (other) {
        return this.equalBase(other) &&
            immutableLookupsEqual(this.derivedAttributes, other.derivedAttributes) &&
            immutableArraysEqual(this.attributes, other.attributes) &&
            immutableArraysEqual(this.delegates, other.delegates) &&
            this.concealBuckets === other.concealBuckets &&
            Boolean(this.requester) === Boolean(other.requester);
    };
    External.prototype.equalBase = function (other) {
        return External.isExternal(other) &&
            this.engine === other.engine &&
            String(this.source) === String(other.source) &&
            this.version === other.version &&
            this.rollup === other.rollup &&
            this.mode === other.mode &&
            this.filter.equals(other.filter);
    };
    External.prototype.changeVersion = function (version) {
        var value = this.valueOf();
        value.version = version;
        return External.fromValue(value);
    };
    External.prototype.attachRequester = function (requester) {
        var value = this.valueOf();
        value.requester = requester;
        return External.fromValue(value);
    };
    External.prototype.versionBefore = function (neededVersion) {
        var version = this.version;
        return version && External.versionLessThan(version, neededVersion);
    };
    External.prototype.getAttributesInfo = function (attributeName) {
        var attributes = this.rawAttributes || this.attributes;
        return findByName(attributes, attributeName);
    };
    External.prototype.updateAttribute = function (newAttribute) {
        if (!this.attributes)
            return this;
        var value = this.valueOf();
        value.attributes = AttributeInfo.override(value.attributes, [newAttribute]);
        return External.fromValue(value);
    };
    External.prototype.show = function () {
        var value = this.valueOf();
        value.suppress = false;
        return External.fromValue(value);
    };
    External.prototype.hasAttribute = function (name) {
        var _a = this, attributes = _a.attributes, rawAttributes = _a.rawAttributes, derivedAttributes = _a.derivedAttributes;
        if (find(rawAttributes || attributes, function (a) { return a.name === name; }))
            return true;
        return hasOwnProperty(derivedAttributes, name);
    };
    External.prototype.expressionDefined = function (ex) {
        return ex.definedInTypeContext(this.getFullType());
    };
    External.prototype.bucketsConcealed = function (ex) {
        var _this = this;
        return ex.every(function (ex, index, depth, nestDiff) {
            if (nestDiff)
                return true;
            if (ex instanceof RefExpression) {
                var refAttributeInfo = _this.getAttributesInfo(ex.name);
                if (refAttributeInfo && refAttributeInfo.makerAction) {
                    return refAttributeInfo.makerAction.alignsWith([]);
                }
            }
            else if (ex instanceof ChainExpression) {
                var refExpression = ex.expression;
                if (refExpression instanceof RefExpression) {
                    var ref = refExpression.name;
                    var refAttributeInfo = _this.getAttributesInfo(ref);
                    if (refAttributeInfo && refAttributeInfo.makerAction) {
                        return refAttributeInfo.makerAction.alignsWith(ex.actions);
                    }
                }
            }
            return null;
        });
    };
    External.prototype.canHandleFilter = function (ex) {
        throw new Error("must implement canHandleFilter");
    };
    External.prototype.canHandleTotal = function () {
        throw new Error("must implement canHandleTotal");
    };
    External.prototype.canHandleSplit = function (ex) {
        throw new Error("must implement canHandleSplit");
    };
    External.prototype.canHandleApply = function (ex) {
        throw new Error("must implement canHandleApply");
    };
    External.prototype.canHandleSort = function (sortAction) {
        throw new Error("must implement canHandleSort");
    };
    External.prototype.canHandleLimit = function (limitAction) {
        throw new Error("must implement canHandleLimit");
    };
    External.prototype.canHandleHavingFilter = function (ex) {
        throw new Error("must implement canHandleHavingFilter");
    };
    External.prototype.addDelegate = function (delegate) {
        var value = this.valueOf();
        if (!value.delegates)
            value.delegates = [];
        value.delegates = value.delegates.concat(delegate);
        return External.fromValue(value);
    };
    External.prototype.getBase = function () {
        var value = this.valueOf();
        value.suppress = true;
        value.mode = 'raw';
        value.dataName = null;
        if (this.mode !== 'raw')
            value.attributes = value.rawAttributes;
        value.rawAttributes = null;
        value.filter = null;
        value.applies = [];
        value.split = null;
        value.sort = null;
        value.limit = null;
        value.delegates = nullMap(value.delegates, function (e) { return e.getBase(); });
        return External.fromValue(value);
    };
    External.prototype.getRaw = function () {
        if (this.mode === 'raw')
            return this;
        var value = this.valueOf();
        value.suppress = true;
        value.mode = 'raw';
        value.dataName = null;
        if (this.mode !== 'raw')
            value.attributes = value.rawAttributes;
        value.rawAttributes = null;
        value.applies = [];
        value.split = null;
        value.sort = null;
        value.limit = null;
        value.delegates = nullMap(value.delegates, function (e) { return e.getRaw(); });
        return External.fromValue(value);
    };
    External.prototype.makeTotal = function (applies) {
        if (this.mode !== 'raw')
            return null;
        if (!this.canHandleTotal())
            return null;
        if (!applies.length)
            throw new Error('must have applies');
        var externals = [];
        for (var _i = 0, applies_5 = applies; _i < applies_5.length; _i++) {
            var apply = applies_5[_i];
            var applyExpression = apply.expression;
            if (applyExpression instanceof ExternalExpression) {
                externals.push(applyExpression.external);
            }
        }
        var commonFilter = External.getCommonFilterFromExternals(externals);
        var value = this.valueOf();
        value.mode = 'total';
        value.suppress = false;
        value.rawAttributes = value.attributes;
        value.derivedAttributes = External.getMergedDerivedAttributesFromExternals(externals);
        value.filter = commonFilter;
        value.attributes = [];
        value.applies = [];
        value.delegates = nullMap(value.delegates, function (e) { return e.makeTotal(applies); });
        var totalExternal = External.fromValue(value);
        for (var _a = 0, applies_6 = applies; _a < applies_6.length; _a++) {
            var apply = applies_6[_a];
            totalExternal = totalExternal._addApplyAction(apply);
            if (!totalExternal)
                return null;
        }
        return totalExternal;
    };
    External.prototype.addAction = function (action) {
        if (action instanceof FilterAction) {
            return this._addFilterAction(action);
        }
        if (action instanceof SelectAction) {
            return this._addSelectAction(action);
        }
        if (action instanceof SplitAction) {
            return this._addSplitAction(action);
        }
        if (action instanceof ApplyAction) {
            return this._addApplyAction(action);
        }
        if (action instanceof SortAction) {
            return this._addSortAction(action);
        }
        if (action instanceof LimitAction) {
            return this._addLimitAction(action);
        }
        if (action.isAggregate()) {
            return this._addAggregateAction(action);
        }
        return this._addPostAggregateAction(action);
    };
    External.prototype._addFilterAction = function (action) {
        return this.addFilter(action.expression);
    };
    External.prototype.addFilter = function (expression) {
        if (!expression.resolved())
            return null;
        if (!this.expressionDefined(expression))
            return null;
        var value = this.valueOf();
        switch (this.mode) {
            case 'raw':
                if (this.concealBuckets && !this.bucketsConcealed(expression))
                    return null;
                if (!this.canHandleFilter(expression))
                    return null;
                if (value.filter.equals(Expression.TRUE)) {
                    value.filter = expression;
                }
                else {
                    value.filter = value.filter.and(expression);
                }
                break;
            case 'split':
                if (!this.canHandleHavingFilter(expression))
                    return null;
                value.havingFilter = value.havingFilter.and(expression).simplify();
                break;
            default:
                return null;
        }
        value.delegates = nullMap(value.delegates, function (e) { return e.addFilter(expression); });
        return External.fromValue(value);
    };
    External.prototype._addSelectAction = function (selectAction) {
        if (this.mode !== 'raw')
            return null;
        var datasetType = this.getFullType().datasetType;
        var attributes = selectAction.attributes;
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var attribute = attributes_1[_i];
            if (!datasetType[attribute])
                return null;
        }
        var value = this.valueOf();
        value.suppress = false;
        value.select = selectAction;
        value.delegates = nullMap(value.delegates, function (e) { return e._addSelectAction(selectAction); });
        return External.fromValue(value);
    };
    External.prototype._addSplitAction = function (splitAction) {
        if (this.mode !== 'raw')
            return null;
        var splitKeys = splitAction.keys;
        for (var _i = 0, splitKeys_1 = splitKeys; _i < splitKeys_1.length; _i++) {
            var splitKey = splitKeys_1[_i];
            var splitExpression = splitAction.splits[splitKey];
            if (!this.expressionDefined(splitExpression))
                return null;
            if (this.concealBuckets && !this.bucketsConcealed(splitExpression))
                return null;
            if (!this.canHandleSplit(splitExpression))
                return null;
        }
        var value = this.valueOf();
        value.suppress = false;
        value.mode = 'split';
        value.dataName = splitAction.dataName;
        value.split = splitAction;
        value.rawAttributes = value.attributes;
        value.attributes = splitAction.mapSplits(function (name, expression) { return new AttributeInfo({ name: name, type: expression.type }); });
        value.delegates = nullMap(value.delegates, function (e) { return e._addSplitAction(splitAction); });
        return External.fromValue(value);
    };
    External.prototype._addApplyAction = function (action) {
        var expression = action.expression;
        if (expression.type === 'DATASET')
            return null;
        if (!expression.contained())
            return null;
        if (!this.expressionDefined(expression))
            return null;
        if (!this.canHandleApply(action.expression))
            return null;
        if (this.mode === 'raw') {
            var value = this.valueOf();
            value.derivedAttributes = immutableAdd(value.derivedAttributes, action.name, action.expression);
        }
        else {
            if (this.split && this.split.hasKey(action.name))
                return null;
            var actionExpression = action.expression;
            if (actionExpression instanceof ExternalExpression) {
                action = action.changeExpression(actionExpression.external.valueExpressionWithinFilter(this.filter));
            }
            var value = this.valueOf();
            var added = External.normalizeAndAddApply(value, action);
            value.applies = added.applies;
            value.attributes = added.attributes;
        }
        value.delegates = nullMap(value.delegates, function (e) { return e._addApplyAction(action); });
        return External.fromValue(value);
    };
    External.prototype._addSortAction = function (action) {
        if (this.limit)
            return null;
        if (!this.canHandleSort(action))
            return null;
        var value = this.valueOf();
        value.sort = action;
        value.delegates = nullMap(value.delegates, function (e) { return e._addSortAction(action); });
        return External.fromValue(value);
    };
    External.prototype._addLimitAction = function (action) {
        if (!this.canHandleLimit(action))
            return null;
        var value = this.valueOf();
        value.suppress = false;
        if (!value.limit || action.limit < value.limit.limit) {
            value.limit = action;
        }
        value.delegates = nullMap(value.delegates, function (e) { return e._addLimitAction(action); });
        return External.fromValue(value);
    };
    External.prototype._addAggregateAction = function (action) {
        if (this.mode !== 'raw' || this.limit)
            return null;
        var actionExpression = action.expression;
        if (actionExpression && !this.expressionDefined(actionExpression))
            return null;
        var value = this.valueOf();
        value.mode = 'value';
        value.suppress = false;
        value.valueExpression = $(External.SEGMENT_NAME, 'DATASET').performAction(action);
        value.rawAttributes = value.attributes;
        value.attributes = null;
        value.delegates = nullMap(value.delegates, function (e) { return e._addAggregateAction(action); });
        return External.fromValue(value);
    };
    External.prototype._addPostAggregateAction = function (action) {
        if (this.mode !== 'value')
            throw new Error('must be in value mode to call addPostAggregateAction');
        var actionExpression = action.expression;
        var commonFilter = this.filter;
        var newValueExpression;
        if (actionExpression instanceof ExternalExpression) {
            var otherExternal = actionExpression.external;
            if (!this.getBase().equals(otherExternal.getBase()))
                return null;
            var commonFilter = getCommonFilter(commonFilter, otherExternal.filter);
            var newAction = action.changeExpression(otherExternal.valueExpressionWithinFilter(commonFilter));
            newValueExpression = this.valueExpressionWithinFilter(commonFilter).performAction(newAction);
        }
        else if (!actionExpression || !actionExpression.hasExternal()) {
            newValueExpression = this.valueExpression.performAction(action);
        }
        else {
            return null;
        }
        var value = this.valueOf();
        value.valueExpression = newValueExpression;
        value.filter = commonFilter;
        value.delegates = nullMap(value.delegates, function (e) { return e._addPostAggregateAction(action); });
        return External.fromValue(value);
    };
    External.prototype.prePack = function (prefix, myAction) {
        if (this.mode !== 'value')
            throw new Error('must be in value mode to call prePack');
        var value = this.valueOf();
        value.valueExpression = prefix.performAction(myAction.changeExpression(value.valueExpression));
        value.delegates = nullMap(value.delegates, function (e) { return e.prePack(prefix, myAction); });
        return External.fromValue(value);
    };
    External.prototype.valueExpressionWithinFilter = function (withinFilter) {
        if (this.mode !== 'value')
            return null;
        var extraFilter = filterDiff(this.filter, withinFilter);
        if (!extraFilter)
            throw new Error('not within the segment');
        var ex = this.valueExpression;
        if (!extraFilter.equals(Expression.TRUE)) {
            ex = ex.substitute(function (ex) {
                if (ex instanceof RefExpression && ex.type === 'DATASET' && ex.name === External.SEGMENT_NAME) {
                    return ex.filter(extraFilter);
                }
                return null;
            });
        }
        return ex;
    };
    External.prototype.toValueApply = function () {
        if (this.mode !== 'value')
            return null;
        return new ApplyAction({
            name: External.VALUE_NAME,
            expression: this.valueExpression
        });
    };
    External.prototype.sortOnLabel = function () {
        var sort = this.sort;
        if (!sort)
            return false;
        var sortOn = sort.expression.name;
        if (!this.split || !this.split.hasKey(sortOn))
            return false;
        var applies = this.applies;
        for (var _i = 0, applies_7 = applies; _i < applies_7.length; _i++) {
            var apply = applies_7[_i];
            if (apply.name === sortOn)
                return false;
        }
        return true;
    };
    External.prototype.inlineDerivedAttributes = function (expression) {
        var derivedAttributes = this.derivedAttributes;
        return expression.substitute(function (refEx) {
            if (refEx instanceof RefExpression) {
                var refName = refEx.name;
                return hasOwnProperty(derivedAttributes, refName) ? derivedAttributes[refName] : null;
            }
            else {
                return null;
            }
        });
    };
    External.prototype.inlineDerivedAttributesInAggregate = function (expression) {
        var _this = this;
        var derivedAttributes = this.derivedAttributes;
        return expression.substituteAction(function (action) {
            if (!action.isAggregate())
                return false;
            return action.getFreeReferences().some(function (ref) { return hasOwnProperty(derivedAttributes, ref); });
        }, function (preEx, action) {
            return preEx.performAction(action.changeExpression(_this.inlineDerivedAttributes(action.expression)));
        });
    };
    External.prototype.switchToRollupCount = function (expression) {
        var _this = this;
        if (!this.rollup)
            return expression;
        var countRef = null;
        return expression.substituteAction(function (action) {
            return action.action === 'count';
        }, function (preEx) {
            if (!countRef)
                countRef = $(_this.getRollupCountName(), 'NUMBER');
            return preEx.sum(countRef);
        });
    };
    External.prototype.getRollupCountName = function () {
        var rawAttributes = this.rawAttributes;
        for (var _i = 0, rawAttributes_1 = rawAttributes; _i < rawAttributes_1.length; _i++) {
            var attribute = rawAttributes_1[_i];
            var makerAction = attribute.makerAction;
            if (makerAction && makerAction.action === 'count')
                return attribute.name;
        }
        throw new Error("could not find rollup count");
    };
    External.prototype.getQuerySplit = function () {
        var _this = this;
        return this.split.transformExpressions(function (ex) {
            return _this.inlineDerivedAttributes(ex);
        });
    };
    External.prototype.getQueryFilter = function () {
        return this.inlineDerivedAttributes(this.filter).simplify();
    };
    External.prototype.getSelectedAttributes = function () {
        var _a = this, select = _a.select, attributes = _a.attributes, derivedAttributes = _a.derivedAttributes;
        attributes = attributes.slice();
        for (var k in derivedAttributes) {
            attributes.push(new AttributeInfo({ name: k, type: derivedAttributes[k].type }));
        }
        if (!select)
            return attributes;
        var selectAttributes = select.attributes;
        return attributes.filter(function (a) { return selectAttributes.indexOf(a.name) !== -1; });
    };
    External.prototype.addNextExternal = function (dataset) {
        var _this = this;
        var _a = this, mode = _a.mode, dataName = _a.dataName, split = _a.split;
        if (mode !== 'split')
            throw new Error('must be in split mode to addNextExternal');
        return dataset.apply(dataName, function (d) {
            return _this.getRaw().addFilter(split.filterFromDatum(d));
        }, 'DATASET', null);
    };
    External.prototype.getDelegate = function () {
        var _a = this, mode = _a.mode, delegates = _a.delegates;
        if (!delegates || !delegates.length || mode === 'raw')
            return null;
        return delegates[0];
    };
    External.prototype.simulateValue = function (lastNode, simulatedQueries, externalForNext) {
        if (externalForNext === void 0) { externalForNext = null; }
        var mode = this.mode;
        if (!externalForNext)
            externalForNext = this;
        var delegate = this.getDelegate();
        if (delegate) {
            return delegate.simulateValue(lastNode, simulatedQueries, externalForNext);
        }
        simulatedQueries.push(this.getQueryAndPostProcess().query);
        if (mode === 'value') {
            var valueExpression = this.valueExpression;
            return getSampleValue(valueExpression.type, valueExpression);
        }
        var datum = {};
        if (mode === 'raw') {
            var attributes = this.attributes;
            for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++) {
                var attribute = attributes_2[_i];
                datum[attribute.name] = getSampleValue(attribute.type, null);
            }
        }
        else {
            if (mode === 'split') {
                this.split.mapSplits(function (name, expression) {
                    datum[name] = getSampleValue(unwrapSetType(expression.type), expression);
                });
            }
            var applies = this.applies;
            for (var _a = 0, applies_8 = applies; _a < applies_8.length; _a++) {
                var apply = applies_8[_a];
                datum[apply.name] = getSampleValue(apply.expression.type, apply.expression);
            }
        }
        var dataset = new Dataset({ data: [datum] });
        if (!lastNode && mode === 'split')
            dataset = externalForNext.addNextExternal(dataset);
        return dataset;
    };
    External.prototype.getQueryAndPostProcess = function () {
        throw new Error("can not call getQueryAndPostProcess directly");
    };
    External.prototype.queryValue = function (lastNode, externalForNext) {
        if (externalForNext === void 0) { externalForNext = null; }
        var _a = this, mode = _a.mode, requester = _a.requester;
        if (!externalForNext)
            externalForNext = this;
        var delegate = this.getDelegate();
        if (delegate) {
            return delegate.queryValue(lastNode, externalForNext);
        }
        if (!requester) {
            return Q.reject(new Error('must have a requester to make queries'));
        }
        try {
            var queryAndPostProcess = this.getQueryAndPostProcess();
        }
        catch (e) {
            return Q.reject(e);
        }
        var query = queryAndPostProcess.query, postProcess = queryAndPostProcess.postProcess, next = queryAndPostProcess.next;
        if (!query || typeof postProcess !== 'function') {
            return Q.reject(new Error('no query or postProcess'));
        }
        var finalResult;
        if (next) {
            var results = [];
            finalResult = promiseWhile(function () { return query; }, function () {
                return requester({ query: query })
                    .then(function (result) {
                    results.push(result);
                    query = next(query, result);
                });
            })
                .then(function () {
                return queryAndPostProcess.postProcess(results);
            });
        }
        else {
            finalResult = requester({ query: query })
                .then(queryAndPostProcess.postProcess);
        }
        if (!lastNode && mode === 'split') {
            finalResult = finalResult.then(externalForNext.addNextExternal.bind(externalForNext));
        }
        return finalResult;
    };
    External.prototype.needsIntrospect = function () {
        return !this.attributes;
    };
    External.prototype.introspect = function () {
        var _this = this;
        if (!this.requester) {
            return Q.reject(new Error('must have a requester to introspect'));
        }
        if (!this.version) {
            return this.constructor.getVersion(this.requester).then(function (version) {
                version = External.extractVersion(version);
                if (!version)
                    throw new Error('external version not found, please specify explicitly');
                return _this.changeVersion(version).introspect();
            });
        }
        return this.getIntrospectAttributes()
            .then(function (attributes) {
            var value = _this.valueOf();
            if (value.attributeOverrides) {
                attributes = AttributeInfo.override(attributes, value.attributeOverrides);
            }
            if (value.attributes) {
                attributes = AttributeInfo.override(value.attributes, attributes);
            }
            value.attributes = attributes;
            return External.fromValue(value);
        });
    };
    External.prototype.getRawDatasetType = function () {
        var _a = this, attributes = _a.attributes, rawAttributes = _a.rawAttributes, derivedAttributes = _a.derivedAttributes;
        if (!attributes)
            throw new Error("dataset has not been introspected");
        if (!rawAttributes)
            rawAttributes = attributes;
        var myDatasetType = {};
        for (var _i = 0, rawAttributes_2 = rawAttributes; _i < rawAttributes_2.length; _i++) {
            var rawAttribute = rawAttributes_2[_i];
            var attrName = rawAttribute.name;
            myDatasetType[attrName] = {
                type: rawAttribute.type
            };
        }
        for (var name in derivedAttributes) {
            myDatasetType[name] = {
                type: derivedAttributes[name].type
            };
        }
        return myDatasetType;
    };
    External.prototype.getFullType = function () {
        var _a = this, mode = _a.mode, attributes = _a.attributes;
        if (mode === 'value')
            throw new Error('not supported for value mode yet');
        var myDatasetType = this.getRawDatasetType();
        if (mode !== 'raw') {
            var splitDatasetType = {};
            splitDatasetType[this.dataName || External.SEGMENT_NAME] = {
                type: 'DATASET',
                datasetType: myDatasetType,
                remote: true
            };
            for (var _i = 0, attributes_3 = attributes; _i < attributes_3.length; _i++) {
                var attribute = attributes_3[_i];
                var attrName = attribute.name;
                splitDatasetType[attrName] = {
                    type: attribute.type
                };
            }
            myDatasetType = splitDatasetType;
        }
        return {
            type: 'DATASET',
            datasetType: myDatasetType,
            remote: true
        };
    };
    External.type = 'EXTERNAL';
    External.SEGMENT_NAME = '__SEGMENT__';
    External.VALUE_NAME = '__VALUE__';
    External.classMap = {};
    return External;
}());
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};







var DUMMY_NAME = '!DUMMY';
var TIME_ATTRIBUTE = '__time';
var AGGREGATE_TO_DRUID = {
    count: "count",
    sum: "doubleSum",
    min: "doubleMin",
    max: "doubleMax"
};
var AGGREGATE_TO_FUNCTION = {
    sum: function (a, b) { return (a + "+" + b); },
    min: function (a, b) { return ("Math.min(" + a + "," + b + ")"); },
    max: function (a, b) { return ("Math.max(" + a + "," + b + ")"); }
};
var AGGREGATE_TO_ZERO = {
    sum: "0",
    min: "Infinity",
    max: "-Infinity"
};
var InvalidResultError = exports.InvalidResultError = (function (_super) {
    __extends(InvalidResultError, _super);
    function InvalidResultError(message, result) {
        _super.call(this, message);
        this.result = result;
    }
    return InvalidResultError;
}(ExtendableError));
function expressionNeedsAlphaNumericSort(ex) {
    var type = ex.type;
    return (type === 'NUMBER' || type === 'NUMBER_RANGE');
}
function customAggregationsEqual(customA, customB) {
    return JSON.stringify(customA) === JSON.stringify(customB);
}
function customTransformsEqual(customA, customB) {
    return JSON.stringify(customA) === JSON.stringify(customB);
}
var DruidExternal = exports.DruidExternal = (function (_super) {
    __extends(DruidExternal, _super);
    function DruidExternal(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureEngine("druid");
        this._ensureMinVersion("0.8.0");
        this.timeAttribute = parameters.timeAttribute || TIME_ATTRIBUTE;
        this.customAggregations = parameters.customAggregations;
        this.customTransforms = parameters.customTransforms;
        this.allowEternity = parameters.allowEternity;
        this.allowSelectQueries = parameters.allowSelectQueries;
        var introspectionStrategy = parameters.introspectionStrategy || DruidExternal.DEFAULT_INTROSPECTION_STRATEGY;
        if (DruidExternal.VALID_INTROSPECTION_STRATEGIES.indexOf(introspectionStrategy) === -1) {
            throw new Error("invalid introspectionStrategy '" + introspectionStrategy + "'");
        }
        this.introspectionStrategy = introspectionStrategy;
        this.exactResultsOnly = parameters.exactResultsOnly;
        this.context = parameters.context;
    }
    DruidExternal.fromJS = function (parameters, requester) {
        if (typeof parameters.druidVersion === 'string') {
            parameters.version = parameters.druidVersion;
            console.warn("'druidVersion' parameter is deprecated, use 'version: " + parameters.version + "' instead");
        }
        var value = External.jsToValue(parameters, requester);
        value.timeAttribute = parameters.timeAttribute;
        value.customAggregations = parameters.customAggregations || {};
        value.customTransforms = parameters.customTransforms || {};
        value.allowEternity = Boolean(parameters.allowEternity);
        value.allowSelectQueries = Boolean(parameters.allowSelectQueries);
        value.introspectionStrategy = parameters.introspectionStrategy;
        value.exactResultsOnly = Boolean(parameters.exactResultsOnly);
        value.context = parameters.context;
        return new DruidExternal(value);
    };
    DruidExternal.getSourceList = function (requester) {
        return requester({ query: { queryType: 'sourceList' } })
            .then(function (sources) {
            if (!Array.isArray(sources))
                throw new InvalidResultError('invalid sources response', sources);
            return sources.sort();
        });
    };
    DruidExternal.getVersion = function (requester) {
        return requester({
            query: {
                queryType: 'status'
            }
        })
            .then(function (res) {
            if (!DruidExternal.correctStatusResult(res))
                throw new InvalidResultError('unexpected result from /status', res);
            return res.version;
        });
    };
    DruidExternal.cleanDatumInPlace = function (datum) {
        for (var k in datum) {
            if (k[0] === '!')
                delete datum[k];
        }
    };
    DruidExternal.correctTimeBoundaryResult = function (result) {
        return Array.isArray(result) && result.length === 1 && typeof result[0].result === 'object';
    };
    DruidExternal.correctTimeseriesResult = function (result) {
        return Array.isArray(result) && (result.length === 0 || typeof result[0].result === 'object');
    };
    DruidExternal.correctTopNResult = function (result) {
        return Array.isArray(result) && (result.length === 0 || Array.isArray(result[0].result));
    };
    DruidExternal.correctGroupByResult = function (result) {
        return Array.isArray(result) && (result.length === 0 || typeof result[0].event === 'object');
    };
    DruidExternal.correctSelectResult = function (result) {
        return Array.isArray(result) && (result.length === 0 || typeof result[0].result === 'object');
    };
    DruidExternal.correctStatusResult = function (result) {
        return result && typeof result.version === 'string';
    };
    DruidExternal.timeBoundaryPostProcessFactory = function (applies) {
        return function (res) {
            if (!DruidExternal.correctTimeBoundaryResult(res))
                throw new InvalidResultError("unexpected result from Druid (timeBoundary)", res);
            var result = res[0].result;
            var datum = {};
            for (var _i = 0, applies_1 = applies; _i < applies_1.length; _i++) {
                var apply = applies_1[_i];
                var name_1 = apply.name;
                var aggregate = apply.expression.actions[0].action;
                if (typeof result === 'string') {
                    datum[name_1] = new Date(result);
                }
                else {
                    if (aggregate === 'max') {
                        datum[name_1] = new Date((result['maxIngestedEventTime'] || result['maxTime']));
                    }
                    else {
                        datum[name_1] = new Date((result['minTime']));
                    }
                }
            }
            return new Dataset({ data: [datum] });
        };
    };
    DruidExternal.valuePostProcess = function (res) {
        if (!DruidExternal.correctTimeseriesResult(res))
            throw new InvalidResultError("unexpected result from Druid (all / value)", res);
        if (!res.length)
            return 0;
        return res[0].result[External.VALUE_NAME];
    };
    DruidExternal.totalPostProcessFactory = function (applies) {
        return function (res) {
            if (!DruidExternal.correctTimeseriesResult(res))
                throw new InvalidResultError("unexpected result from Druid (all)", res);
            if (!res.length)
                return new Dataset({ data: [External.makeZeroDatum(applies)] });
            var datum = res[0].result;
            DruidExternal.cleanDatumInPlace(datum);
            return new Dataset({ data: [datum] });
        };
    };
    DruidExternal.wrapFunctionTryCatch = function (lines) {
        return 'function(s){try{\n' + lines.filter(Boolean).join('\n') + '\n}catch(e){return null;}}';
    };
    DruidExternal.timeseriesNormalizerFactory = function (timestampLabel) {
        if (timestampLabel === void 0) { timestampLabel = null; }
        return function (res) {
            if (!DruidExternal.correctTimeseriesResult(res))
                throw new InvalidResultError("unexpected result from Druid (timeseries)", res);
            return res.map(function (r) {
                var datum = r.result;
                DruidExternal.cleanDatumInPlace(datum);
                if (timestampLabel)
                    datum[timestampLabel] = r.timestamp;
                return datum;
            });
        };
    };
    DruidExternal.topNNormalizer = function (res) {
        if (!DruidExternal.correctTopNResult(res))
            throw new InvalidResultError("unexpected result from Druid (topN)", res);
        var data = res.length ? res[0].result : [];
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var d = data_1[_i];
            DruidExternal.cleanDatumInPlace(d);
        }
        return data;
    };
    DruidExternal.groupByNormalizerFactory = function (timestampLabel) {
        if (timestampLabel === void 0) { timestampLabel = null; }
        return function (res) {
            if (!DruidExternal.correctGroupByResult(res))
                throw new InvalidResultError("unexpected result from Druid (groupBy)", res);
            return res.map(function (r) {
                var datum = r.event;
                DruidExternal.cleanDatumInPlace(datum);
                if (timestampLabel)
                    datum[timestampLabel] = r.timestamp;
                return datum;
            });
        };
    };
    DruidExternal.selectNormalizerFactory = function (timestampLabel) {
        return function (results) {
            var data = [];
            for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
                var result = results_1[_i];
                if (!DruidExternal.correctSelectResult(result))
                    throw new InvalidResultError("unexpected result from Druid (select)", result);
                if (result.length === 0)
                    continue;
                var events = result[0].result.events;
                for (var _a = 0, events_1 = events; _a < events_1.length; _a++) {
                    var event = events_1[_a];
                    var datum = event.event;
                    if (timestampLabel != null) {
                        datum[timestampLabel] = datum['timestamp'];
                    }
                    delete datum['timestamp'];
                    DruidExternal.cleanDatumInPlace(datum);
                    data.push(datum);
                }
            }
            return data;
        };
    };
    DruidExternal.postProcessFactory = function (normalizer, inflaters, attributes) {
        return function (res) {
            var data = normalizer(res);
            var n = data.length;
            for (var _i = 0, inflaters_1 = inflaters; _i < inflaters_1.length; _i++) {
                var inflater = inflaters_1[_i];
                for (var i = 0; i < n; i++) {
                    inflater(data[i], i, data);
                }
            }
            return new Dataset({ data: data, attributes: attributes });
        };
    };
    DruidExternal.selectNextFactory = function (limit, descending) {
        var resultsSoFar = 0;
        return function (prevQuery, prevResult) {
            if (!DruidExternal.correctSelectResult(prevResult))
                throw new InvalidResultError("unexpected result from Druid (select / partial)", prevResult);
            if (prevResult.length === 0)
                return null;
            var _a = prevResult[0].result, pagingIdentifiers = _a.pagingIdentifiers, events = _a.events;
            if (events.length < prevQuery.pagingSpec.threshold)
                return null;
            resultsSoFar += events.length;
            if (resultsSoFar >= limit)
                return null;
            var pagingIdentifiers = DruidExternal.movePagingIdentifiers(pagingIdentifiers, descending ? -1 : 1);
            prevQuery.pagingSpec.pagingIdentifiers = pagingIdentifiers;
            prevQuery.pagingSpec.threshold = Math.min(limit - resultsSoFar, DruidExternal.SELECT_MAX_LIMIT);
            return prevQuery;
        };
    };
    DruidExternal.generateMakerAction = function (aggregation) {
        if (!aggregation)
            return null;
        var type = aggregation.type, fieldName = aggregation.fieldName;
        if (type === 'longSum' && fieldName === 'count') {
            return new CountAction({});
        }
        if (!fieldName) {
            var fieldNames = aggregation.fieldNames;
            if (!Array.isArray(fieldNames) || fieldNames.length !== 1)
                return null;
            fieldName = fieldNames[0];
        }
        var expression = $(fieldName);
        switch (type) {
            case "count":
                return new CountAction({});
            case "doubleSum":
            case "longSum":
                return new SumAction({ expression: expression });
            case "javascript":
                var fnAggregate = aggregation.fnAggregate, fnCombine = aggregation.fnCombine;
                if (fnAggregate !== fnCombine || fnCombine.indexOf('+') === -1)
                    return null;
                return new SumAction({ expression: expression });
            case "doubleMin":
            case "longMin":
                return new MinAction({ expression: expression });
            case "doubleMax":
            case "longMax":
                return new MaxAction({ expression: expression });
            default:
                return null;
        }
    };
    DruidExternal.segmentMetadataPostProcessFactory = function (timeAttribute) {
        return function (res) {
            var res0 = res[0];
            if (!res0 || !res0.columns)
                throw new InvalidResultError('malformed segmentMetadata response', res);
            var columns = res0.columns;
            var aggregators = res0.aggregators || {};
            var foundTime = false;
            var attributes = [];
            for (var name in columns) {
                if (!hasOwnProperty(columns, name))
                    continue;
                var columnData = columns[name];
                if (columnData.errorMessage || columnData.size < 0)
                    continue;
                if (name === TIME_ATTRIBUTE) {
                    attributes.push(new AttributeInfo({ name: timeAttribute, type: 'TIME' }));
                    foundTime = true;
                }
                else {
                    if (name === timeAttribute)
                        continue;
                    switch (columnData.type) {
                        case 'FLOAT':
                        case 'LONG':
                            attributes.push(new AttributeInfo({
                                name: name,
                                type: 'NUMBER',
                                unsplitable: true,
                                makerAction: DruidExternal.generateMakerAction(aggregators[name])
                            }));
                            break;
                        case 'STRING':
                            attributes.push(new AttributeInfo({
                                name: name,
                                type: columnData.hasMultipleValues ? 'SET/STRING' : 'STRING'
                            }));
                            break;
                        case 'hyperUnique':
                            attributes.push(new UniqueAttributeInfo({ name: name }));
                            break;
                        case 'approximateHistogram':
                            attributes.push(new HistogramAttributeInfo({ name: name }));
                            break;
                        case 'thetaSketch':
                            attributes.push(new ThetaAttributeInfo({ name: name }));
                            break;
                    }
                }
            }
            if (!foundTime)
                throw new Error("no valid " + TIME_ATTRIBUTE + " in segmentMetadata response");
            return attributes;
        };
    };
    DruidExternal.introspectPostProcessFactory = function (timeAttribute) {
        return function (res) {
            if (!Array.isArray(res.dimensions) || !Array.isArray(res.metrics)) {
                throw new InvalidResultError('malformed GET introspect response', res);
            }
            var attributes = [
                new AttributeInfo({ name: timeAttribute, type: 'TIME' })
            ];
            res.dimensions.forEach(function (dimension) {
                if (dimension === timeAttribute)
                    return;
                attributes.push(new AttributeInfo({ name: dimension, type: 'STRING' }));
            });
            res.metrics.forEach(function (metric) {
                if (metric === timeAttribute)
                    return;
                attributes.push(new AttributeInfo({ name: metric, type: 'NUMBER', unsplitable: true }));
            });
            return attributes;
        };
    };
    DruidExternal.movePagingIdentifiers = function (pagingIdentifiers, increment) {
        var newPagingIdentifiers = {};
        for (var key in pagingIdentifiers) {
            if (!hasOwnProperty(pagingIdentifiers, key))
                continue;
            newPagingIdentifiers[key] = pagingIdentifiers[key] + increment;
        }
        return newPagingIdentifiers;
    };
    DruidExternal.timePartToExtraction = function (part, timezone) {
        var format = DruidExternal.TIME_PART_TO_FORMAT[part];
        if (format) {
            return {
                "format": format,
                "locale": "en-US",
                "timeZone": timezone.toString(),
                "type": "timeFormat"
            };
        }
        else {
            var expr = DruidExternal.TIME_PART_TO_EXPR[part];
            if (!expr)
                throw new Error("can not part on " + part);
            return {
                type: 'javascript',
                'function': DruidExternal.wrapFunctionTryCatch([
                    'var d = new org.joda.time.DateTime(s);',
                    timezone.isUTC() ? null : "d = d.withZone(org.joda.time.DateTimeZone.forID(" + JSON.stringify(timezone) + "));",
                    ("d = " + expr + ";"),
                    'return d;'
                ])
            };
        }
    };
    DruidExternal.timeFloorToExtraction = function (duration, timezone) {
        var singleSpan = duration.getSingleSpan();
        var spanValue = duration.getSingleSpanValue();
        if (spanValue === 1 && DruidExternal.SPAN_TO_FLOOR_FORMAT[singleSpan]) {
            return {
                "format": DruidExternal.SPAN_TO_FLOOR_FORMAT[singleSpan],
                "locale": "en-US",
                "timeZone": timezone.toString(),
                "type": "timeFormat"
            };
        }
        else {
            var prop = DruidExternal.SPAN_TO_PROPERTY[singleSpan];
            if (!prop)
                throw new Error("can not floor on " + duration);
            return {
                type: 'javascript',
                'function': DruidExternal.wrapFunctionTryCatch([
                    'var d = new org.joda.time.DateTime(s);',
                    timezone.isUTC() ? null : "d = d.withZone(org.joda.time.DateTimeZone.forID(" + JSON.stringify(timezone) + "));",
                    ("d = d." + prop + "().roundFloorCopy();"),
                    ("d = d." + prop + "().setCopy(Math.floor(d." + prop + "().get() / " + spanValue + ") * " + spanValue + ");"),
                    'return d;'
                ])
            };
        }
    };
    DruidExternal.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.timeAttribute = this.timeAttribute;
        value.customAggregations = this.customAggregations;
        value.customTransforms = this.customTransforms;
        value.allowEternity = this.allowEternity;
        value.allowSelectQueries = this.allowSelectQueries;
        value.introspectionStrategy = this.introspectionStrategy;
        value.exactResultsOnly = this.exactResultsOnly;
        value.context = this.context;
        return value;
    };
    DruidExternal.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        if (this.timeAttribute !== TIME_ATTRIBUTE)
            js.timeAttribute = this.timeAttribute;
        if (nonEmptyLookup(this.customAggregations))
            js.customAggregations = this.customAggregations;
        if (nonEmptyLookup(this.customTransforms))
            js.customTransforms = this.customTransforms;
        if (this.allowEternity)
            js.allowEternity = true;
        if (this.allowSelectQueries)
            js.allowSelectQueries = true;
        if (this.introspectionStrategy !== DruidExternal.DEFAULT_INTROSPECTION_STRATEGY)
            js.introspectionStrategy = this.introspectionStrategy;
        if (this.exactResultsOnly)
            js.exactResultsOnly = true;
        if (this.context)
            js.context = this.context;
        return js;
    };
    DruidExternal.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.timeAttribute === other.timeAttribute &&
            customAggregationsEqual(this.customAggregations, other.customAggregations) &&
            customTransformsEqual(this.customTransforms, other.customTransforms) &&
            this.allowEternity === other.allowEternity &&
            this.allowSelectQueries === other.allowSelectQueries &&
            this.introspectionStrategy === other.introspectionStrategy &&
            this.exactResultsOnly === other.exactResultsOnly &&
            dictEqual(this.context, other.context);
    };
    DruidExternal.prototype.getSingleReferenceAttributeInfo = function (ex) {
        var freeReferences = ex.getFreeReferences();
        if (freeReferences.length !== 1)
            throw new Error("can not translate multi reference expression " + ex + " to Druid");
        var referenceName = freeReferences[0];
        return this.getAttributesInfo(referenceName);
    };
    DruidExternal.prototype.canHandleFilter = function (ex) {
        return !(ex instanceof ChainExpression &&
            ex.actions.some(function (a) { return a.action === 'cardinality'; }));
    };
    DruidExternal.prototype.canHandleTotal = function () {
        return true;
    };
    DruidExternal.prototype.canHandleSplit = function (ex) {
        return true;
    };
    DruidExternal.prototype.canHandleApply = function (ex) {
        return true;
    };
    DruidExternal.prototype.canHandleSort = function (sortAction) {
        if (this.isTimeseries()) {
            if (sortAction.direction !== 'ascending')
                return false;
            return sortAction.refName() === this.split.firstSplitName();
        }
        else if (this.mode === 'raw') {
            if (sortAction.refName() !== this.timeAttribute)
                return false;
            if (this.versionBefore('0.9.0'))
                return sortAction.direction === 'ascending';
            return true;
        }
        else {
            return true;
        }
    };
    DruidExternal.prototype.canHandleLimit = function (limitAction) {
        return !this.isTimeseries();
    };
    DruidExternal.prototype.canHandleHavingFilter = function (ex) {
        return !this.limit;
    };
    DruidExternal.prototype.isTimeseries = function () {
        var split = this.split;
        if (!split || split.isMultiSplit())
            return false;
        var splitExpression = split.firstSplitExpression();
        if (this.isTimeRef(splitExpression))
            return true;
        if (splitExpression instanceof ChainExpression) {
            var actions = splitExpression.actions;
            if (actions.length !== 1)
                return false;
            var action = actions[0].action;
            return action === 'timeBucket' || action === 'timeFloor';
        }
        return false;
    };
    DruidExternal.prototype.getDruidDataSource = function () {
        var source = this.source;
        if (Array.isArray(source)) {
            return {
                type: "union",
                dataSources: source
            };
        }
        else {
            return source;
        }
    };
    DruidExternal.prototype.getDimensionNameForAttribureInfo = function (attributeInfo) {
        return attributeInfo.name === this.timeAttribute ? TIME_ATTRIBUTE : attributeInfo.name;
    };
    DruidExternal.prototype.checkFilterExtractability = function (attributeInfo) {
        if (this.versionBefore('0.9.2') && attributeInfo.name === this.timeAttribute) {
            throw new Error('can not do secondary filtering on primary time dimension (https://github.com/druid-io/druid/issues/2816)');
        }
    };
    DruidExternal.prototype.makeJavaScriptFilter = function (ex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        this.checkFilterExtractability(attributeInfo);
        return {
            type: "javascript",
            dimension: this.getDimensionNameForAttribureInfo(attributeInfo),
            "function": ex.getJSFn('d')
        };
    };
    DruidExternal.prototype.makeExtractionFilter = function (ex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = this.expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        return {
            type: "extraction",
            dimension: this.getDimensionNameForAttribureInfo(attributeInfo),
            extractionFn: extractionFn,
            value: "true"
        };
    };
    DruidExternal.prototype.makeSelectorFilter = function (ex, value) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        if (attributeInfo.unsplitable) {
            throw new Error("can not convert " + ex + " = " + value + " to filter because it references an un-filterable metric '" + attributeInfo.name + "' which is most likely rolled up.");
        }
        var extractionFn = this.expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        if (Range.isRange(value))
            value = value.start;
        var druidFilter = {
            type: "selector",
            dimension: this.getDimensionNameForAttribureInfo(attributeInfo),
            value: attributeInfo.serialize(value)
        };
        if (extractionFn) {
            druidFilter.extractionFn = extractionFn;
            if (this.versionBefore('0.9.1'))
                druidFilter.type = "extraction";
            if (this.versionBefore('0.9.0') && druidFilter.value === null)
                druidFilter.value = '';
        }
        return druidFilter;
    };
    DruidExternal.prototype.makeInFilter = function (ex, valueSet) {
        var _this = this;
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = this.expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var elements = valueSet.elements;
        if (elements.length < 2 ||
            (this.versionBefore('0.9.1') && extractionFn) ||
            this.versionBefore('0.9.0')) {
            var fields = elements.map(function (value) {
                return _this.makeSelectorFilter(ex, value);
            });
            return fields.length === 1 ? fields[0] : { type: "or", fields: fields };
        }
        var inFilter = {
            type: 'in',
            dimension: this.getDimensionNameForAttribureInfo(attributeInfo),
            values: elements.map(function (value) { return attributeInfo.serialize(value); })
        };
        if (extractionFn)
            inFilter.extractionFn = extractionFn;
        return inFilter;
    };
    DruidExternal.prototype.makeBoundFilter = function (ex, range) {
        var r0 = range.start;
        var r1 = range.end;
        var bounds = range.bounds;
        if (this.versionBefore('0.9.0') || r0 < 0 || r1 < 0) {
            return this.makeJavaScriptFilter(ex.in(range));
        }
        if (ex instanceof ChainExpression && (ex.getSingleAction() instanceof IndexOfAction || ex.popAction() instanceof IndexOfAction)) {
            return this.makeJavaScriptFilter(ex.in(range));
        }
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = this.expressionToExtractionFn(ex);
        if (this.versionBefore('0.9.1') && extractionFn) {
            return this.makeJavaScriptFilter(ex.in(range));
        }
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var boundFilter = {
            type: "bound",
            dimension: this.getDimensionNameForAttribureInfo(attributeInfo)
        };
        if (extractionFn)
            boundFilter.extractionFn = extractionFn;
        if (NumberRange.isNumberRange(range))
            boundFilter.alphaNumeric = true;
        if (r0 != null) {
            boundFilter.lower = isDate(r0) ? r0.toISOString() : r0;
            if (bounds[0] === '(')
                boundFilter.lowerStrict = true;
        }
        if (r1 != null) {
            boundFilter.upper = isDate(r1) ? r1.toISOString() : r1;
            if (bounds[1] === ')')
                boundFilter.upperStrict = true;
        }
        return boundFilter;
    };
    DruidExternal.prototype.makeRegexFilter = function (ex, regex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = this.expressionToExtractionFn(ex);
        if (this.versionBefore('0.9.1') && extractionFn) {
            return this.makeExtractionFilter(ex.match(regex));
        }
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var regexFilter = {
            type: "regex",
            dimension: this.getDimensionNameForAttribureInfo(attributeInfo),
            pattern: regex
        };
        if (extractionFn)
            regexFilter.extractionFn = extractionFn;
        return regexFilter;
    };
    DruidExternal.prototype.makeContainsFilter = function (lhs, rhs, compare) {
        if (rhs instanceof LiteralExpression) {
            var attributeInfo = this.getSingleReferenceAttributeInfo(lhs);
            var extractionFn = this.expressionToExtractionFn(lhs);
            if (extractionFn)
                this.checkFilterExtractability(attributeInfo);
            if (this.versionBefore('0.9.0')) {
                if (compare === ContainsAction.IGNORE_CASE) {
                    return {
                        type: "search",
                        dimension: this.getDimensionNameForAttribureInfo(attributeInfo),
                        query: {
                            type: "insensitive_contains",
                            value: rhs.value
                        }
                    };
                }
                else {
                    return this.makeJavaScriptFilter(lhs.contains(rhs, compare));
                }
            }
            if (this.versionBefore('0.9.1') && extractionFn) {
                return this.makeExtractionFilter(lhs.contains(rhs, compare));
            }
            var searchFilter = {
                type: "search",
                dimension: this.getDimensionNameForAttribureInfo(attributeInfo),
                query: {
                    type: "contains",
                    value: rhs.value,
                    caseSensitive: compare === ContainsAction.NORMAL
                }
            };
            if (extractionFn)
                searchFilter.extractionFn = extractionFn;
            return searchFilter;
        }
        else {
            return this.makeJavaScriptFilter(lhs.contains(rhs, compare));
        }
    };
    DruidExternal.prototype.timelessFilterToDruid = function (filter, aggregatorFilter) {
        var _this = this;
        if (filter.type !== 'BOOLEAN')
            throw new Error("must be a BOOLEAN filter");
        if (filter instanceof RefExpression) {
            filter = filter.is(true);
        }
        if (filter instanceof LiteralExpression) {
            if (filter.value === true) {
                return null;
            }
            else {
                throw new Error("should never get here");
            }
        }
        else if (filter instanceof ChainExpression) {
            var pattern;
            if (pattern = filter.getExpressionPattern('and')) {
                return {
                    type: 'and',
                    fields: pattern.map(function (p) { return _this.timelessFilterToDruid(p, aggregatorFilter); })
                };
            }
            if (pattern = filter.getExpressionPattern('or')) {
                return {
                    type: 'or',
                    fields: pattern.map(function (p) { return _this.timelessFilterToDruid(p, aggregatorFilter); })
                };
            }
            var filterAction = filter.lastAction();
            var rhs = filterAction.expression;
            var lhs = filter.popAction();
            if (filterAction instanceof NotAction) {
                return {
                    type: 'not',
                    field: this.timelessFilterToDruid(lhs, aggregatorFilter)
                };
            }
            if (lhs instanceof LiteralExpression) {
                if (filterAction.action !== 'in')
                    throw new Error("can not convert " + filter + " to Druid filter");
                return this.makeSelectorFilter(rhs, lhs.value);
            }
            if (filterAction instanceof IsAction) {
                if (rhs instanceof LiteralExpression) {
                    return this.makeSelectorFilter(lhs, rhs.value);
                }
                else {
                    throw new Error("can not convert " + filter + " to Druid filter");
                }
            }
            var freeReferences = filter.getFreeReferences();
            if (freeReferences.length !== 1)
                throw new Error("can not convert multi reference filter " + filter + " to Druid filter");
            var referenceName = freeReferences[0];
            var attributeInfo = this.getAttributesInfo(referenceName);
            if (attributeInfo.unsplitable) {
                throw new Error("can not convert " + filter + " to filter because it references an un-filterable metric '" + referenceName + "' which is most likely rolled up.");
            }
            if (filterAction instanceof InAction || filterAction instanceof OverlapAction) {
                if (rhs instanceof LiteralExpression) {
                    var rhsType = rhs.type;
                    if (rhsType === 'SET/STRING' || rhsType === 'SET/NUMBER' || rhsType === 'SET/NULL') {
                        return this.makeInFilter(lhs, rhs.value);
                    }
                    else if (rhsType === 'NUMBER_RANGE' || rhsType === 'TIME_RANGE' || rhsType === 'STRING_RANGE') {
                        return this.makeBoundFilter(lhs, rhs.value);
                    }
                    else if (rhsType === 'SET/NUMBER_RANGE' || rhsType === 'SET/TIME_RANGE') {
                        var elements = rhs.value.elements;
                        var fields = elements.map(function (range) {
                            return _this.makeBoundFilter(lhs, range);
                        });
                        return fields.length === 1 ? fields[0] : { type: "or", fields: fields };
                    }
                    else {
                        throw new Error("not supported IN rhs type " + rhsType);
                    }
                }
                else {
                    throw new Error("can not convert " + filter + " to Druid filter");
                }
            }
            if (aggregatorFilter) {
                if (this.versionBefore('0.8.2'))
                    throw new Error("can not express aggregate filter " + filter + " in druid < 0.8.2");
                if (this.versionBefore('0.9.1'))
                    return this.makeExtractionFilter(filter);
            }
            if (filterAction instanceof MatchAction) {
                return this.makeRegexFilter(lhs, filterAction.regexp);
            }
            if (filterAction instanceof ContainsAction) {
                return this.makeContainsFilter(lhs, rhs, filterAction.compare);
            }
        }
        throw new Error("could not convert filter " + filter + " to Druid filter");
    };
    DruidExternal.prototype.timeFilterToIntervals = function (filter) {
        if (filter.type !== 'BOOLEAN')
            throw new Error("must be a BOOLEAN filter");
        if (filter instanceof LiteralExpression) {
            if (!filter.value)
                return DruidExternal.FALSE_INTERVAL;
            if (!this.allowEternity)
                throw new Error('must filter on time unless the allowEternity flag is set');
            return DruidExternal.TRUE_INTERVAL;
        }
        else if (filter instanceof ChainExpression) {
            var lhs = filter.expression;
            var actions = filter.actions;
            if (actions.length !== 1)
                throw new Error("can not convert " + filter + " to Druid interval");
            var filterAction = actions[0];
            var rhs = filterAction.expression;
            if (filterAction instanceof IsAction) {
                if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                    return TimeRange.intervalFromDate(rhs.value);
                }
                else {
                    throw new Error("can not convert " + filter + " to Druid interval");
                }
            }
            else if (filterAction instanceof InAction) {
                if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                    var timeRanges;
                    var rhsType = rhs.type;
                    if (rhsType === 'SET/TIME_RANGE') {
                        timeRanges = rhs.value.elements;
                    }
                    else if (rhsType === 'TIME_RANGE') {
                        timeRanges = [rhs.value];
                    }
                    else {
                        throw new Error("not supported " + rhsType + " for time filtering");
                    }
                    var intervals = timeRanges.map(function (timeRange) { return timeRange.toInterval(); });
                    return intervals.length === 1 ? intervals[0] : intervals;
                }
                else {
                    throw new Error("can not convert " + filter + " to Druid interval");
                }
            }
            else {
                throw new Error("can not convert " + filter + " to Druid interval");
            }
        }
        else {
            throw new Error("can not convert " + filter + " to Druid interval");
        }
    };
    DruidExternal.prototype.filterToDruid = function (filter) {
        if (filter.type !== 'BOOLEAN')
            throw new Error("must be a BOOLEAN filter");
        if (filter.equals(Expression.FALSE)) {
            return {
                intervals: DruidExternal.FALSE_INTERVAL,
                filter: null
            };
        }
        else {
            var timeAttribute_1 = this.timeAttribute;
            var _a = filter.extractFromAnd(function (ex) {
                if (ex instanceof ChainExpression) {
                    var op = ex.expression;
                    var actions = ex.actions;
                    if (op instanceof RefExpression) {
                        if (!(op.name === timeAttribute_1 && actions.length === 1))
                            return false;
                        var action = actions[0].action;
                        return action === 'is' || action === 'in';
                    }
                }
                return false;
            }), extract = _a.extract, rest = _a.rest;
            return {
                intervals: this.timeFilterToIntervals(extract),
                filter: this.timelessFilterToDruid(rest, false)
            };
        }
    };
    DruidExternal.prototype.isTimeRef = function (ex) {
        return ex instanceof RefExpression && ex.name === this.timeAttribute;
    };
    DruidExternal.prototype.splitExpressionToGranularityInflater = function (splitExpression, label) {
        if (this.isTimeRef(splitExpression)) {
            return {
                granularity: 'none',
                inflater: External.timeInflaterFactory(label)
            };
        }
        else if (splitExpression instanceof ChainExpression) {
            var splitActions = splitExpression.actions;
            if (this.isTimeRef(splitExpression.expression) && splitActions.length === 1) {
                var action = splitActions[0];
                if (action instanceof TimeBucketAction || action instanceof TimeFloorAction) {
                    var duration = action.duration;
                    var timezone = action.getTimezone();
                    return {
                        granularity: {
                            type: "period",
                            period: duration.toString(),
                            timeZone: timezone.toString()
                        },
                        inflater: action.action === 'timeBucket' ?
                            External.timeRangeInflaterFactory(label, duration, timezone) :
                            External.timeInflaterFactory(label)
                    };
                }
            }
        }
        return null;
    };
    DruidExternal.prototype.expressionToExtractionFn = function (expression) {
        var extractionFns = [];
        this._expressionToExtractionFns(expression, extractionFns);
        switch (extractionFns.length) {
            case 0: return null;
            case 1: return extractionFns[0];
            default:
                if (extractionFns.every(function (extractionFn) { return extractionFn.type === 'javascript'; })) {
                    return this.expressionToJavaScriptExtractionFn(expression);
                }
                if (this.versionBefore('0.9.0')) {
                    try {
                        return this.expressionToJavaScriptExtractionFn(expression);
                    }
                    catch (e) {
                        throw new Error("can not convert " + expression + " to filter in Druid < 0.9.0");
                    }
                }
                return { type: 'cascade', extractionFns: extractionFns };
        }
    };
    DruidExternal.prototype._expressionToExtractionFns = function (expression, extractionFns) {
        var freeReferences = expression.getFreeReferences();
        if (freeReferences.length !== 1) {
            throw new Error("must have 1 reference (has " + freeReferences.length + "): " + expression);
        }
        if (expression instanceof RefExpression) {
            this._processRefExtractionFn(expression, extractionFns);
            return;
        }
        if (expression instanceof ChainExpression) {
            var lead = expression.expression;
            var actions = expression.actions;
            var i = 0;
            var curAction = actions[0];
            var concatPrefix = [];
            if (curAction.action === 'concat') {
                concatPrefix.push(lead);
                while (curAction && curAction.action === 'concat') {
                    concatPrefix.push(curAction.expression);
                    curAction = actions[++i];
                }
                this._processConcatExtractionFn(concatPrefix, extractionFns);
            }
            else if (curAction.action === 'customTransform') {
                extractionFns.push(this.customTransformToExtractionFn(curAction));
                return;
            }
            else if (lead.type === 'NUMBER' && (expression.type === 'NUMBER' || expression.type === 'NUMBER_RANGE')) {
                extractionFns.push(this.expressionToJavaScriptExtractionFn(expression));
                return;
            }
            else if (!lead.isOp('ref')) {
                throw new Error("can not convert complex: " + lead);
            }
            var type = expression.expression.type;
            while (curAction) {
                var nextAction = actions[i + 1];
                var extractionFn;
                if (nextAction instanceof FallbackAction) {
                    extractionFn = this.actionToExtractionFn(curAction, nextAction);
                    i++;
                }
                else if (curAction instanceof CastAction && curAction.outputType === 'STRING' && !nextAction) {
                    break;
                }
                else {
                    extractionFn = this.actionToExtractionFn(curAction, null, type);
                }
                type = curAction.getOutputType(type);
                extractionFns.push(extractionFn);
                curAction = actions[++i];
            }
        }
    };
    DruidExternal.prototype._processRefExtractionFn = function (ref, extractionFns) {
        var attributeInfo = this.getAttributesInfo(ref.name);
        if (ref.type === 'BOOLEAN') {
            extractionFns.push({
                type: "lookup",
                lookup: {
                    type: "map",
                    map: {
                        "0": "false",
                        "1": "true",
                        "false": "false",
                        "true": "true"
                    }
                }
            });
            return;
        }
    };
    DruidExternal.prototype.actionToExtractionFn = function (action, fallbackAction, expressionType) {
        if (action.action === 'extract' || action.action === 'lookup') {
            var retainMissingValue = false;
            var replaceMissingValueWith = null;
            if (fallbackAction) {
                var fallbackExpression = fallbackAction.expression;
                if (fallbackExpression.isOp("ref")) {
                    retainMissingValue = true;
                }
                else if (fallbackExpression.isOp("literal")) {
                    replaceMissingValueWith = fallbackExpression.getLiteralValue();
                }
                else {
                    throw new Error("unsupported fallback expression: " + fallbackExpression);
                }
            }
            if (action instanceof ExtractAction) {
                if (this.versionBefore('0.9.0') && (retainMissingValue === false || replaceMissingValueWith !== null)) {
                    return this.actionToJavaScriptExtractionFn(action);
                }
                var regexExtractionFn = {
                    type: "regex",
                    expr: action.regexp
                };
                if (!retainMissingValue) {
                    regexExtractionFn.replaceMissingValue = true;
                }
                if (replaceMissingValueWith !== null) {
                    regexExtractionFn.replaceMissingValueWith = replaceMissingValueWith;
                }
                return regexExtractionFn;
            }
            if (action instanceof LookupAction) {
                var lookupExtractionFn = {
                    type: "registeredLookup",
                    lookup: action.lookup
                };
                if (this.versionBefore('0.9.1') || /-legacy-lookups/.test(this.version)) {
                    lookupExtractionFn = {
                        type: "lookup",
                        lookup: {
                            type: "namespace",
                            "namespace": action.lookup
                        }
                    };
                }
                if (retainMissingValue) {
                    lookupExtractionFn.retainMissingValue = true;
                }
                if (replaceMissingValueWith !== null) {
                    lookupExtractionFn.replaceMissingValueWith = replaceMissingValueWith;
                }
                return lookupExtractionFn;
            }
        }
        if (fallbackAction) {
            throw new Error("unsupported fallback after " + action.action + " action");
        }
        if (action.getOutputType(null) === 'BOOLEAN') {
            return this.actionToJavaScriptExtractionFn(action);
        }
        if (action instanceof SubstrAction) {
            if (this.versionBefore('0.9.0'))
                return this.actionToJavaScriptExtractionFn(action);
            return {
                type: "substring",
                index: action.position,
                length: action.length
            };
        }
        if (action instanceof TimeBucketAction || action instanceof TimeFloorAction) {
            return DruidExternal.timeFloorToExtraction(action.duration, action.getTimezone());
        }
        if (action instanceof TimePartAction) {
            return DruidExternal.timePartToExtraction(action.part, action.getTimezone());
        }
        if (action instanceof CustomTransformAction) {
            return this.customTransformToExtractionFn(action);
        }
        if (action instanceof TransformCaseAction) {
            var transformType = DruidExternal.caseToDruid[action.transformType];
            if (!transformType)
                throw new Error("unsupported case transformation '" + transformType + "'");
            return {
                type: transformType
            };
        }
        if (action instanceof NumberBucketAction) {
            return this.actionToJavaScriptExtractionFn(action);
        }
        if (action instanceof AbsoluteAction || action instanceof PowerAction || action instanceof LengthAction || action instanceof CardinalityAction || action instanceof CastAction || action instanceof IndexOfAction) {
            return this.actionToJavaScriptExtractionFn(action, expressionType);
        }
        if (action instanceof FallbackAction && action.expression.isOp('literal')) {
            return {
                type: "lookup",
                retainMissingValue: true,
                lookup: {
                    type: "map",
                    map: {
                        "": action.getLiteralValue()
                    }
                }
            };
        }
        throw new Error("can not covert " + action + " to extractionFn");
    };
    DruidExternal.prototype._processConcatExtractionFn = function (pattern, extractionFns) {
        var _this = this;
        if (this.versionBefore('0.9.1')) {
            extractionFns.push({
                type: "javascript",
                'function': Expression.concat(pattern).getJSFn('d'),
                injective: true
            });
            return;
        }
        var format = pattern.map(function (ex) {
            if (ex instanceof LiteralExpression) {
                return ex.value.replace(/%/g, '\\%');
            }
            if (!ex.isOp('ref')) {
                _this._expressionToExtractionFns(ex, extractionFns);
            }
            return '%s';
        }).join('');
        extractionFns.push({
            type: 'stringFormat',
            format: format,
            nullHandling: 'returnNull'
        });
    };
    DruidExternal.prototype.customTransformToExtractionFn = function (action) {
        var custom = action.custom;
        var customExtractionFn = this.customTransforms[custom];
        if (!customExtractionFn)
            throw new Error("could not find extraction function: '" + custom + "'");
        var extractionFn = customExtractionFn.extractionFn;
        if (typeof extractionFn.type !== 'string')
            throw new Error("must have type in custom extraction fn '" + custom + "'");
        try {
            JSON.parse(JSON.stringify(customExtractionFn));
        }
        catch (e) {
            throw new Error("must have JSON extraction Fn '" + custom + "'");
        }
        return extractionFn;
    };
    DruidExternal.prototype.actionToJavaScriptExtractionFn = function (action, type) {
        return this.expressionToJavaScriptExtractionFn($('x', type).performAction(action));
    };
    DruidExternal.prototype.expressionToJavaScriptExtractionFn = function (ex) {
        return {
            type: "javascript",
            'function': ex.getJSFn('d')
        };
    };
    DruidExternal.prototype.expressionToDimensionInflater = function (expression, label) {
        var freeReferences = expression.getFreeReferences();
        if (freeReferences.length !== 1) {
            throw new Error("must have 1 reference (has " + freeReferences.length + "): " + expression);
        }
        var referenceName = freeReferences[0];
        var attributeInfo = this.getAttributesInfo(referenceName);
        if (attributeInfo.unsplitable) {
            throw new Error("can not convert " + expression + " to split because it references an un-splitable metric '" + referenceName + "' which is most likely rolled up.");
        }
        var extractionFn = this.expressionToExtractionFn(expression);
        var simpleInflater = External.getSimpleInflater(expression, label);
        var dimension = {
            type: "default",
            dimension: this.getDimensionNameForAttribureInfo(attributeInfo),
            outputName: label
        };
        if (extractionFn) {
            dimension.type = "extraction";
            dimension.extractionFn = extractionFn;
        }
        if (expression instanceof RefExpression) {
            return {
                dimension: dimension,
                inflater: simpleInflater
            };
        }
        if (expression instanceof ChainExpression) {
            var splitAction = expression.lastAction();
            if (splitAction instanceof TimeBucketAction) {
                return {
                    dimension: dimension,
                    inflater: External.timeRangeInflaterFactory(label, splitAction.duration, splitAction.getTimezone())
                };
            }
            if (splitAction instanceof TimePartAction) {
                return {
                    dimension: dimension,
                    inflater: simpleInflater
                };
            }
            if (splitAction instanceof NumberBucketAction) {
                return {
                    dimension: dimension,
                    inflater: External.numberRangeInflaterFactory(label, splitAction.size)
                };
            }
            if (splitAction instanceof CardinalityAction) {
                return {
                    dimension: dimension,
                    inflater: External.setCardinalityInflaterFactory(label)
                };
            }
        }
        var effectiveType = unwrapSetType(expression.type);
        if (simpleInflater || effectiveType === 'STRING') {
            return {
                dimension: dimension,
                inflater: simpleInflater
            };
        }
        throw new Error("could not convert " + expression + " to a Druid dimension");
    };
    DruidExternal.prototype.splitToDruid = function (split) {
        var _this = this;
        if (split.isMultiSplit()) {
            var timestampLabel = null;
            var granularity = null;
            var dimensions = [];
            var inflaters = [];
            split.mapSplits(function (name, expression) {
                if (!granularity && !_this.limit && !_this.sort) {
                    var granularityInflater = _this.splitExpressionToGranularityInflater(expression, name);
                    if (granularityInflater) {
                        timestampLabel = name;
                        granularity = granularityInflater.granularity;
                        inflaters.push(granularityInflater.inflater);
                        return;
                    }
                }
                var _a = _this.expressionToDimensionInflater(expression, name), dimension = _a.dimension, inflater = _a.inflater;
                dimensions.push(dimension);
                if (inflater) {
                    inflaters.push(inflater);
                }
            });
            return {
                queryType: 'groupBy',
                dimensions: dimensions,
                timestampLabel: timestampLabel,
                granularity: granularity || 'all',
                postProcess: DruidExternal.postProcessFactory(DruidExternal.groupByNormalizerFactory(timestampLabel), inflaters, null)
            };
        }
        var splitExpression = split.firstSplitExpression();
        var label = split.firstSplitName();
        var granularityInflater = this.splitExpressionToGranularityInflater(splitExpression, label);
        if (granularityInflater) {
            return {
                queryType: 'timeseries',
                granularity: granularityInflater.granularity,
                postProcess: DruidExternal.postProcessFactory(DruidExternal.timeseriesNormalizerFactory(label), [granularityInflater.inflater], null)
            };
        }
        var dimensionInflater = this.expressionToDimensionInflater(splitExpression, label);
        var inflaters = [dimensionInflater.inflater].filter(Boolean);
        if (this.havingFilter.equals(Expression.TRUE) &&
            (this.limit || split.maxBucketNumber() < 1000) &&
            !this.exactResultsOnly) {
            return {
                queryType: 'topN',
                dimension: dimensionInflater.dimension,
                granularity: 'all',
                postProcess: DruidExternal.postProcessFactory(DruidExternal.topNNormalizer, inflaters, null)
            };
        }
        return {
            queryType: 'groupBy',
            dimensions: [dimensionInflater.dimension],
            granularity: 'all',
            postProcess: DruidExternal.postProcessFactory(DruidExternal.groupByNormalizerFactory(), inflaters, null)
        };
    };
    DruidExternal.prototype.getAccessTypeForAggregation = function (aggregationType) {
        if (aggregationType === 'hyperUnique' || aggregationType === 'cardinality')
            return 'hyperUniqueCardinality';
        var customAggregations = this.customAggregations;
        for (var customName in customAggregations) {
            if (!hasOwnProperty(customAggregations, customName))
                continue;
            var customAggregation = customAggregations[customName];
            if (customAggregation.aggregation.type === aggregationType) {
                return customAggregation.accessType || 'fieldAccess';
            }
        }
        return 'fieldAccess';
    };
    DruidExternal.prototype.getAccessType = function (aggregations, aggregationName) {
        for (var _i = 0, aggregations_1 = aggregations; _i < aggregations_1.length; _i++) {
            var aggregation = aggregations_1[_i];
            if (aggregation.name === aggregationName) {
                var aggregationType = aggregation.type;
                if (aggregationType === 'filtered')
                    aggregationType = aggregation.aggregator.type;
                return this.getAccessTypeForAggregation(aggregationType);
            }
        }
        return 'fieldAccess';
    };
    DruidExternal.prototype.expressionToPostAggregation = function (ex, aggregations, postAggregations) {
        var _this = this;
        if (ex instanceof RefExpression) {
            var refName = ex.name;
            return {
                type: this.getAccessType(aggregations, refName),
                fieldName: refName
            };
        }
        else if (ex instanceof LiteralExpression) {
            if (ex.type !== 'NUMBER')
                throw new Error("must be a NUMBER type");
            return {
                type: 'constant',
                value: ex.value
            };
        }
        else if (ex instanceof ChainExpression) {
            var lastAction = ex.lastAction();
            if (lastAction instanceof AbsoluteAction || lastAction instanceof PowerAction || lastAction instanceof FallbackAction || lastAction instanceof CastAction || lastAction instanceof IndexOfAction || lastAction instanceof TransformCaseAction) {
                var fieldNameRefs = ex.getFreeReferences();
                var fieldNames = fieldNameRefs.map(function (fieldNameRef) {
                    var accessType = _this.getAccessType(aggregations, fieldNameRef);
                    if (accessType === 'fieldAccess')
                        return fieldNameRef;
                    var fieldNameRefTemp = '!F_' + fieldNameRef;
                    postAggregations.push({
                        name: fieldNameRefTemp,
                        type: accessType,
                        fieldName: fieldNameRef
                    });
                    return fieldNameRefTemp;
                });
                return {
                    type: 'javascript',
                    fieldNames: fieldNames,
                    'function': "function(" + fieldNameRefs.map(RefExpression.toJavaScriptSafeName) + ") { return " + ex.getJS(null) + "; }"
                };
            }
            var pattern;
            if (pattern = ex.getExpressionPattern('add')) {
                return {
                    type: 'arithmetic',
                    fn: '+',
                    fields: pattern.map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
                };
            }
            if (pattern = ex.getExpressionPattern('subtract')) {
                return {
                    type: 'arithmetic',
                    fn: '-',
                    fields: pattern.map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
                };
            }
            if (pattern = ex.getExpressionPattern('multiply')) {
                return {
                    type: 'arithmetic',
                    fn: '*',
                    fields: pattern.map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
                };
            }
            if (pattern = ex.getExpressionPattern('divide')) {
                return {
                    type: 'arithmetic',
                    fn: '/',
                    fields: pattern.map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
                };
            }
            throw new Error("can not convert chain to post agg: " + ex);
        }
        else {
            throw new Error("can not convert expression to post agg: " + ex);
        }
    };
    DruidExternal.prototype.applyToPostAggregation = function (action, aggregations, postAggregations) {
        var postAgg = this.expressionToPostAggregation(action.expression, aggregations, postAggregations);
        postAgg.name = action.name;
        postAggregations.push(postAgg);
    };
    DruidExternal.prototype.makeNativeAggregateFilter = function (filterExpression, aggregator) {
        return {
            type: "filtered",
            name: aggregator.name,
            filter: this.timelessFilterToDruid(filterExpression, true),
            aggregator: aggregator
        };
    };
    DruidExternal.prototype.makeStandardAggregation = function (name, aggregateAction) {
        var fn = aggregateAction.action;
        var aggregateExpression = aggregateAction.expression;
        var aggregation = {
            name: name,
            type: AGGREGATE_TO_DRUID[fn]
        };
        if (fn !== 'count') {
            if (aggregateExpression instanceof RefExpression) {
                var refName = aggregateExpression.name;
                var attributeInfo = this.getAttributesInfo(refName);
                if (attributeInfo.unsplitable) {
                    aggregation.fieldName = refName;
                }
                else {
                    return this.makeJavaScriptAggregation(name, aggregateAction);
                }
            }
            else {
                return this.makeJavaScriptAggregation(name, aggregateAction);
            }
        }
        return aggregation;
    };
    DruidExternal.prototype.makeCountDistinctAggregation = function (name, action, postAggregations) {
        if (this.exactResultsOnly) {
            throw new Error("approximate query not allowed");
        }
        var attribute = action.expression;
        if (attribute instanceof RefExpression) {
            var attributeName = attribute.name;
        }
        else {
            throw new Error("can not compute countDistinct on derived attribute: " + attribute);
        }
        var attributeInfo = this.getAttributesInfo(attributeName);
        if (attributeInfo instanceof UniqueAttributeInfo) {
            return {
                name: name,
                type: "hyperUnique",
                fieldName: attributeName
            };
        }
        else if (attributeInfo instanceof ThetaAttributeInfo) {
            var tempName = '!Theta_' + name;
            postAggregations.push({
                type: "thetaSketchEstimate",
                name: name,
                field: { type: 'fieldAccess', fieldName: tempName }
            });
            return {
                name: tempName,
                type: "thetaSketch",
                fieldName: attributeName
            };
        }
        else {
            return {
                name: name,
                type: "cardinality",
                fieldNames: [attributeName],
                byRow: true
            };
        }
    };
    DruidExternal.prototype.makeCustomAggregation = function (name, action) {
        var customAggregationName = action.custom;
        var customAggregation = this.customAggregations[customAggregationName];
        if (!customAggregation)
            throw new Error("could not find '" + customAggregationName + "'");
        var aggregationObj = customAggregation.aggregation;
        if (typeof aggregationObj.type !== 'string')
            throw new Error("must have type in custom aggregation '" + customAggregationName + "'");
        try {
            aggregationObj = JSON.parse(JSON.stringify(aggregationObj));
        }
        catch (e) {
            throw new Error("must have JSON custom aggregation '" + customAggregationName + "'");
        }
        aggregationObj.name = name;
        return aggregationObj;
    };
    DruidExternal.prototype.makeQuantileAggregation = function (name, action, postAggregations) {
        if (this.exactResultsOnly) {
            throw new Error("approximate query not allowed");
        }
        var attribute = action.expression;
        if (attribute instanceof RefExpression) {
            var attributeName = attribute.name;
        }
        else {
            throw new Error("can not compute countDistinct on derived attribute: " + attribute);
        }
        var histogramAggregationName = "!H_" + name;
        var aggregation = {
            name: histogramAggregationName,
            type: "approxHistogramFold",
            fieldName: attributeName
        };
        postAggregations.push({
            name: name,
            type: "quantile",
            fieldName: histogramAggregationName,
            probability: action.quantile
        });
        return aggregation;
    };
    DruidExternal.prototype.makeJavaScriptAggregation = function (name, aggregateAction) {
        var aggregateActionType = aggregateAction.action;
        var aggregateExpression = aggregateAction.expression;
        var aggregateFunction = AGGREGATE_TO_FUNCTION[aggregateActionType];
        if (!aggregateFunction)
            throw new Error("Can not convert " + aggregateActionType + " to JS");
        var zero = AGGREGATE_TO_ZERO[aggregateActionType];
        var fieldNames = aggregateExpression.getFreeReferences();
        var simpleFieldNames = fieldNames.map(RefExpression.toJavaScriptSafeName);
        return {
            name: name,
            type: "javascript",
            fieldNames: fieldNames,
            fnAggregate: "function($$," + simpleFieldNames.join(',') + ") { return " + aggregateFunction('$$', aggregateExpression.getJS(null)) + "; }",
            fnCombine: "function(a,b) { return " + aggregateFunction('a', 'b') + "; }",
            fnReset: "function() { return " + zero + "; }"
        };
    };
    DruidExternal.prototype.applyToAggregation = function (action, aggregations, postAggregations) {
        var applyExpression = action.expression;
        if (applyExpression.op !== 'chain')
            throw new Error("can not convert apply: " + applyExpression);
        var actions = applyExpression.actions;
        var filterExpression = null;
        var aggregateAction = null;
        if (actions.length === 1) {
            aggregateAction = actions[0];
        }
        else if (actions.length === 2) {
            var filterAction = actions[0];
            if (filterAction instanceof FilterAction) {
                filterExpression = filterAction.expression;
            }
            else {
                throw new Error("first action not a filter in: " + applyExpression);
            }
            aggregateAction = actions[1];
        }
        else {
            throw new Error("can not convert strange apply: " + applyExpression);
        }
        var aggregation;
        switch (aggregateAction.action) {
            case "count":
            case "sum":
            case "min":
            case "max":
                aggregation = this.makeStandardAggregation(action.name, aggregateAction);
                break;
            case "countDistinct":
                aggregation = this.makeCountDistinctAggregation(action.name, aggregateAction, postAggregations);
                break;
            case "quantile":
                aggregation = this.makeQuantileAggregation(action.name, aggregateAction, postAggregations);
                break;
            case "customAggregate":
                aggregation = this.makeCustomAggregation(action.name, aggregateAction);
                break;
            default:
                throw new Error("unsupported aggregate action " + aggregateAction.action);
        }
        if (filterExpression) {
            aggregation = this.makeNativeAggregateFilter(filterExpression, aggregation);
        }
        aggregations.push(aggregation);
    };
    DruidExternal.prototype.getAggregationsAndPostAggregations = function (applies) {
        var _this = this;
        var _a = External.segregationAggregateApplies(applies.map(function (apply) {
            var expression = apply.expression;
            expression = _this.switchToRollupCount(_this.inlineDerivedAttributesInAggregate(expression).decomposeAverage()).distribute();
            return apply.changeExpression(expression);
        })), aggregateApplies = _a.aggregateApplies, postAggregateApplies = _a.postAggregateApplies;
        var aggregations = [];
        var postAggregations = [];
        for (var _i = 0, aggregateApplies_1 = aggregateApplies; _i < aggregateApplies_1.length; _i++) {
            var aggregateApply = aggregateApplies_1[_i];
            this.applyToAggregation(aggregateApply, aggregations, postAggregations);
        }
        for (var _b = 0, postAggregateApplies_1 = postAggregateApplies; _b < postAggregateApplies_1.length; _b++) {
            var postAggregateApply = postAggregateApplies_1[_b];
            this.applyToPostAggregation(postAggregateApply, aggregations, postAggregations);
        }
        return {
            aggregations: aggregations,
            postAggregations: postAggregations
        };
    };
    DruidExternal.prototype.makeHavingComparison = function (agg, op, value) {
        switch (op) {
            case '<':
                return { type: "lessThan", aggregation: agg, value: value };
            case '>':
                return { type: "greaterThan", aggregation: agg, value: value };
            case '<=':
                return { type: 'not', havingSpec: { type: "greaterThan", aggregation: agg, value: value } };
            case '>=':
                return { type: 'not', havingSpec: { type: "lessThan", aggregation: agg, value: value } };
            default:
                throw new Error("unknown op: " + op);
        }
    };
    DruidExternal.prototype.inToHavingFilter = function (agg, range) {
        var havingSpecs = [];
        if (range.start !== null) {
            havingSpecs.push(this.makeHavingComparison(agg, (range.bounds[0] === '[' ? '>=' : '>'), range.start));
        }
        if (range.end !== null) {
            havingSpecs.push(this.makeHavingComparison(agg, (range.bounds[1] === ']' ? '<=' : '<'), range.end));
        }
        return havingSpecs.length === 1 ? havingSpecs[0] : { type: 'and', havingSpecs: havingSpecs };
    };
    DruidExternal.prototype.havingFilterToDruid = function (filter) {
        var _this = this;
        if (filter instanceof LiteralExpression) {
            if (filter.value === true) {
                return null;
            }
            else {
                throw new Error("should never get here");
            }
        }
        else if (filter instanceof ChainExpression) {
            var pattern;
            if (pattern = filter.getExpressionPattern('and')) {
                return {
                    type: 'and',
                    havingSpecs: pattern.map(this.havingFilterToDruid, this)
                };
            }
            if (pattern = filter.getExpressionPattern('or')) {
                return {
                    type: 'or',
                    havingSpecs: pattern.map(this.havingFilterToDruid, this)
                };
            }
            if (filter.lastAction() instanceof NotAction) {
                return this.havingFilterToDruid(filter.popAction());
            }
            var lhs = filter.expression;
            var actions = filter.actions;
            if (actions.length !== 1)
                throw new Error("can not convert " + filter + " to Druid interval");
            var filterAction = actions[0];
            var rhs = filterAction.expression;
            if (filterAction instanceof IsAction) {
                if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                    return {
                        type: "equalTo",
                        aggregation: lhs.name,
                        value: rhs.value
                    };
                }
                else {
                    throw new Error("can not convert " + filter + " to Druid filter");
                }
            }
            else if (filterAction instanceof InAction) {
                if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                    var rhsType = rhs.type;
                    if (rhsType === 'SET/STRING') {
                        return {
                            type: "or",
                            havingSpecs: rhs.value.elements.map(function (value) {
                                return {
                                    type: "equalTo",
                                    aggregation: lhs.name,
                                    value: value
                                };
                            })
                        };
                    }
                    else if (rhsType === 'SET/NUMBER_RANGE') {
                        return {
                            type: "or",
                            havingSpecs: rhs.value.elements.map(function (value) {
                                return _this.inToHavingFilter(lhs.name, value);
                            }, this)
                        };
                    }
                    else if (rhsType === 'NUMBER_RANGE') {
                        return this.inToHavingFilter(lhs.name, rhs.value);
                    }
                    else if (rhsType === 'TIME_RANGE') {
                        throw new Error("can not compute having filter on time");
                    }
                    else {
                        throw new Error("not supported " + rhsType);
                    }
                }
                else {
                    throw new Error("can not convert " + filter + " to Druid having filter");
                }
            }
        }
        throw new Error("could not convert filter " + filter + " to Druid filter");
    };
    DruidExternal.prototype.isMinMaxTimeApply = function (apply) {
        var applyExpression = apply.expression;
        if (applyExpression instanceof ChainExpression) {
            var actions = applyExpression.actions;
            if (actions.length !== 1)
                return false;
            var minMaxAction = actions[0];
            return (minMaxAction.action === "min" || minMaxAction.action === "max") &&
                this.isTimeRef(minMaxAction.expression);
        }
        else {
            return false;
        }
    };
    DruidExternal.prototype.getTimeBoundaryQueryAndPostProcess = function () {
        var _a = this, applies = _a.applies, context = _a.context;
        var druidQuery = {
            queryType: "timeBoundary",
            dataSource: this.getDruidDataSource()
        };
        if (context) {
            druidQuery.context = context;
        }
        if (applies.length === 1) {
            var loneApplyExpression = applies[0].expression;
            druidQuery.bound = loneApplyExpression.actions[0].action + "Time";
        }
        return {
            query: druidQuery,
            postProcess: DruidExternal.timeBoundaryPostProcessFactory(applies)
        };
    };
    DruidExternal.prototype.getQueryAndPostProcess = function () {
        var _this = this;
        var _a = this, mode = _a.mode, applies = _a.applies, sort = _a.sort, limit = _a.limit, context = _a.context;
        if (applies && applies.length && applies.every(this.isMinMaxTimeApply, this)) {
            return this.getTimeBoundaryQueryAndPostProcess();
        }
        var druidQuery = {
            queryType: 'timeseries',
            dataSource: this.getDruidDataSource(),
            intervals: null,
            granularity: 'all'
        };
        if (context) {
            druidQuery.context = shallowCopy(context);
        }
        var filterAndIntervals = this.filterToDruid(this.getQueryFilter());
        druidQuery.intervals = filterAndIntervals.intervals;
        if (filterAndIntervals.filter) {
            druidQuery.filter = filterAndIntervals.filter;
        }
        switch (mode) {
            case 'raw':
                if (!this.allowSelectQueries) {
                    throw new Error("to issues 'select' queries allowSelectQueries flag must be set");
                }
                var selectDimensions = [];
                var selectMetrics = [];
                var inflaters = [];
                var timeAttribute = this.timeAttribute;
                var derivedAttributes = this.derivedAttributes;
                var selectedTimeAttribute = null;
                var selectedAttributes = this.getSelectedAttributes();
                selectedAttributes.forEach(function (attribute) {
                    var name = attribute.name, type = attribute.type, unsplitable = attribute.unsplitable;
                    if (name === timeAttribute) {
                        selectedTimeAttribute = name;
                    }
                    else {
                        if (unsplitable) {
                            selectMetrics.push(name);
                        }
                        else {
                            var derivedAttribute = derivedAttributes[name];
                            if (derivedAttribute) {
                                if (_this.versionBefore('0.9.1')) {
                                    throw new Error("can not have derived attributes in Druid select in " + _this.version + ", upgrade to 0.9.1");
                                }
                                var dimensionInflater = _this.expressionToDimensionInflater(derivedAttribute, name);
                                selectDimensions.push(dimensionInflater.dimension);
                                if (dimensionInflater.inflater)
                                    inflaters.push(dimensionInflater.inflater);
                                return;
                            }
                            else {
                                selectDimensions.push(name);
                            }
                        }
                    }
                    switch (type) {
                        case 'BOOLEAN':
                            inflaters.push(External.booleanInflaterFactory(name));
                            break;
                        case 'NUMBER':
                            inflaters.push(External.numberInflaterFactory(name));
                            break;
                        case 'TIME':
                            inflaters.push(External.timeInflaterFactory(name));
                            break;
                        case 'SET/STRING':
                            inflaters.push(External.setStringInflaterFactory(name));
                            break;
                    }
                });
                if (!selectDimensions.length)
                    selectDimensions.push(DUMMY_NAME);
                if (!selectMetrics.length)
                    selectMetrics.push(DUMMY_NAME);
                var resultLimit = limit ? limit.limit : Infinity;
                druidQuery.queryType = 'select';
                druidQuery.dimensions = selectDimensions;
                druidQuery.metrics = selectMetrics;
                druidQuery.pagingSpec = {
                    "pagingIdentifiers": {},
                    "threshold": Math.min(resultLimit, DruidExternal.SELECT_INIT_LIMIT)
                };
                var descending = sort && sort.direction === 'descending';
                if (descending) {
                    druidQuery.descending = true;
                }
                return {
                    query: druidQuery,
                    postProcess: DruidExternal.postProcessFactory(DruidExternal.selectNormalizerFactory(selectedTimeAttribute), inflaters, selectedAttributes),
                    next: DruidExternal.selectNextFactory(resultLimit, descending)
                };
            case 'value':
                var aggregationsAndPostAggregations = this.getAggregationsAndPostAggregations([this.toValueApply()]);
                if (aggregationsAndPostAggregations.aggregations.length) {
                    druidQuery.aggregations = aggregationsAndPostAggregations.aggregations;
                }
                if (aggregationsAndPostAggregations.postAggregations.length) {
                    druidQuery.postAggregations = aggregationsAndPostAggregations.postAggregations;
                }
                return {
                    query: druidQuery,
                    postProcess: DruidExternal.valuePostProcess
                };
            case 'total':
                var aggregationsAndPostAggregations = this.getAggregationsAndPostAggregations(this.applies);
                if (aggregationsAndPostAggregations.aggregations.length) {
                    druidQuery.aggregations = aggregationsAndPostAggregations.aggregations;
                }
                if (aggregationsAndPostAggregations.postAggregations.length) {
                    druidQuery.postAggregations = aggregationsAndPostAggregations.postAggregations;
                }
                return {
                    query: druidQuery,
                    postProcess: DruidExternal.totalPostProcessFactory(applies)
                };
            case 'split':
                var split = this.getQuerySplit();
                var splitSpec = this.splitToDruid(split);
                druidQuery.queryType = splitSpec.queryType;
                druidQuery.granularity = splitSpec.granularity;
                if (splitSpec.dimension)
                    druidQuery.dimension = splitSpec.dimension;
                if (splitSpec.dimensions)
                    druidQuery.dimensions = splitSpec.dimensions;
                var postProcess = splitSpec.postProcess;
                var aggregationsAndPostAggregations = this.getAggregationsAndPostAggregations(applies);
                if (aggregationsAndPostAggregations.aggregations.length) {
                    druidQuery.aggregations = aggregationsAndPostAggregations.aggregations;
                }
                else {
                    druidQuery.aggregations = [{ name: DUMMY_NAME, type: "count" }];
                }
                if (aggregationsAndPostAggregations.postAggregations.length) {
                    druidQuery.postAggregations = aggregationsAndPostAggregations.postAggregations;
                }
                switch (druidQuery.queryType) {
                    case 'timeseries':
                        if (sort && (sort.direction !== 'ascending' || !split.hasKey(sort.refName()))) {
                            throw new Error('can not sort within timeseries query');
                        }
                        if (limit) {
                            throw new Error('can not limit within timeseries query');
                        }
                        if (!druidQuery.context || !hasOwnProperty(druidQuery.context, 'skipEmptyBuckets')) {
                            druidQuery.context = druidQuery.context || {};
                            druidQuery.context.skipEmptyBuckets = "true";
                        }
                        break;
                    case 'topN':
                        var metric;
                        if (sort) {
                            var inverted;
                            if (this.sortOnLabel()) {
                                if (expressionNeedsAlphaNumericSort(split.firstSplitExpression())) {
                                    metric = { type: 'alphaNumeric' };
                                }
                                else {
                                    metric = { type: 'lexicographic' };
                                }
                                inverted = sort.direction === 'descending';
                            }
                            else {
                                metric = sort.refName();
                                inverted = sort.direction === 'ascending';
                            }
                            if (inverted) {
                                metric = { type: "inverted", metric: metric };
                            }
                        }
                        else {
                            metric = { type: 'lexicographic' };
                        }
                        druidQuery.metric = metric;
                        druidQuery.threshold = limit ? limit.limit : 1000;
                        break;
                    case 'groupBy':
                        var orderByColumn = null;
                        if (sort) {
                            var col = sort.refName();
                            orderByColumn = {
                                dimension: col,
                                direction: sort.direction
                            };
                            if (this.sortOnLabel()) {
                                if (expressionNeedsAlphaNumericSort(split.splits[col])) {
                                    orderByColumn.dimensionOrder = 'alphanumeric';
                                }
                            }
                        }
                        else {
                            var timestampLabel = splitSpec.timestampLabel;
                            var splitKeys = split.keys.filter(function (k) { return k !== timestampLabel; });
                            if (!splitKeys.length)
                                throw new Error('could not find order by column for group by');
                            var splitKey = splitKeys[0];
                            var keyExpression = split.splits[splitKey];
                            orderByColumn = {
                                dimension: splitKey,
                            };
                            if (expressionNeedsAlphaNumericSort(keyExpression)) {
                                orderByColumn.dimensionOrder = 'alphanumeric';
                            }
                        }
                        druidQuery.limitSpec = {
                            type: "default",
                            columns: [orderByColumn || split.firstSplitName()]
                        };
                        if (limit) {
                            druidQuery.limitSpec.limit = limit.limit;
                        }
                        if (!this.havingFilter.equals(Expression.TRUE)) {
                            druidQuery.having = this.havingFilterToDruid(this.havingFilter);
                        }
                        break;
                }
                return {
                    query: druidQuery,
                    postProcess: postProcess
                };
            default:
                throw new Error("can not get query for: " + this.mode);
        }
    };
    DruidExternal.prototype.getIntrospectAttributesWithSegmentMetadata = function () {
        var _a = this, requester = _a.requester, timeAttribute = _a.timeAttribute;
        var query = {
            queryType: 'segmentMetadata',
            dataSource: this.getDruidDataSource(),
            merge: true,
            analysisTypes: ['aggregators'],
            lenientAggregatorMerge: true
        };
        if (this.versionBefore('0.9.0')) {
            query.analysisTypes = [];
            delete query.lenientAggregatorMerge;
        }
        if (this.versionBefore('0.9.2') && query.dataSource.type === 'union') {
            query.dataSource = query.dataSource.dataSources[0];
        }
        return requester({ query: query }).then(DruidExternal.segmentMetadataPostProcessFactory(timeAttribute));
    };
    DruidExternal.prototype.getIntrospectAttributesWithGet = function () {
        var _a = this, requester = _a.requester, timeAttribute = _a.timeAttribute;
        return requester({
            query: {
                queryType: 'introspect',
                dataSource: this.getDruidDataSource()
            }
        })
            .then(DruidExternal.introspectPostProcessFactory(timeAttribute));
    };
    DruidExternal.prototype.getIntrospectAttributes = function () {
        var _this = this;
        switch (this.introspectionStrategy) {
            case 'segment-metadata-fallback':
                return this.getIntrospectAttributesWithSegmentMetadata()
                    .catch(function (err) {
                    if (err.message.indexOf("querySegmentSpec can't be null") === -1)
                        throw err;
                    return _this.getIntrospectAttributesWithGet();
                });
            case 'segment-metadata-only':
                return this.getIntrospectAttributesWithSegmentMetadata();
            case 'datasource-get':
                return this.getIntrospectAttributesWithGet();
            default:
                throw new Error('invalid introspectionStrategy');
        }
    };
    DruidExternal.type = 'DATASET';
    DruidExternal.TRUE_INTERVAL = "1000/3000";
    DruidExternal.FALSE_INTERVAL = "1000/1001";
    DruidExternal.VALID_INTROSPECTION_STRATEGIES = ['segment-metadata-fallback', 'segment-metadata-only', 'datasource-get'];
    DruidExternal.DEFAULT_INTROSPECTION_STRATEGY = 'segment-metadata-fallback';
    DruidExternal.SELECT_INIT_LIMIT = 50;
    DruidExternal.SELECT_MAX_LIMIT = 10000;
    DruidExternal.TIME_PART_TO_FORMAT = {
        SECOND_OF_MINUTE: "s",
        MINUTE_OF_HOUR: "m",
        HOUR_OF_DAY: "H",
        DAY_OF_WEEK: "e",
        DAY_OF_MONTH: "d",
        DAY_OF_YEAR: "D",
        WEEK_OF_YEAR: "w",
        MONTH_OF_YEAR: "M",
        YEAR: "Y"
    };
    DruidExternal.TIME_PART_TO_EXPR = {
        SECOND_OF_MINUTE: "d.getSecondOfMinute()",
        SECOND_OF_HOUR: "d.getSecondOfHour()",
        SECOND_OF_DAY: "d.getSecondOfDay()",
        SECOND_OF_WEEK: "d.getDayOfWeek()*86400 + d.getSecondOfMinute()",
        SECOND_OF_MONTH: "d.getDayOfMonth()*86400 + d.getSecondOfHour()",
        SECOND_OF_YEAR: "d.getDayOfYear()*86400 + d.getSecondOfDay()",
        MINUTE_OF_HOUR: "d.getMinuteOfHour()",
        MINUTE_OF_DAY: "d.getMinuteOfDay()",
        MINUTE_OF_WEEK: "d.getDayOfWeek()*1440 + d.getMinuteOfDay()",
        MINUTE_OF_MONTH: "d.getDayOfMonth()*1440 + d.getMinuteOfDay()",
        MINUTE_OF_YEAR: "d.getDayOfYear()*1440 + d.getMinuteOfDay()",
        HOUR_OF_DAY: "d.getHourOfDay()",
        HOUR_OF_WEEK: "d.getDayOfWeek()*24 + d.getHourOfDay()",
        HOUR_OF_MONTH: "d.getDayOfMonth()*24 + d.getHourOfDay()",
        HOUR_OF_YEAR: "d.getDayOfYear()*24 + d.getHourOfDay()",
        DAY_OF_WEEK: "d.getDayOfWeek()",
        DAY_OF_MONTH: "d.getDayOfMonth()",
        DAY_OF_YEAR: "d.getDayOfYear()",
        WEEK_OF_YEAR: "d.getWeekOfWeekyear()",
        MONTH_OF_YEAR: "d.getMonthOfYear()",
        YEAR: "d.getYearOfEra()"
    };
    DruidExternal.SPAN_TO_FLOOR_FORMAT = {
        second: "yyyy-MM-dd'T'HH:mm:ss'Z",
        minute: "yyyy-MM-dd'T'HH:mm'Z",
        hour: "yyyy-MM-dd'T'HH':00Z",
        day: "yyyy-MM-dd'Z",
        month: "yyyy-MM'-01Z",
        year: "yyyy'-01-01Z"
    };
    DruidExternal.SPAN_TO_PROPERTY = {
        second: 'secondOfMinute',
        minute: 'minuteOfHour',
        hour: 'hourOfDay',
        day: 'dayOfMonth',
        week: 'weekOfWeekyear',
        month: 'monthOfYear',
        year: 'yearOfEra'
    };
    DruidExternal.caseToDruid = {
        upperCase: 'upper',
        lowerCase: 'lower'
    };
    return DruidExternal;
}(External));
External.register(DruidExternal);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





function correctResult(result) {
    return Array.isArray(result) && (result.length === 0 || typeof result[0] === 'object');
}
function getSplitInflaters(split) {
    return split.mapSplits(function (label, splitExpression) {
        var simpleInflater = External.getSimpleInflater(splitExpression, label);
        if (simpleInflater)
            return simpleInflater;
        if (splitExpression instanceof ChainExpression) {
            var lastAction = splitExpression.lastAction();
            if (lastAction instanceof TimeBucketAction) {
                return External.timeRangeInflaterFactory(label, lastAction.duration, lastAction.getTimezone());
            }
            if (lastAction instanceof NumberBucketAction) {
                return External.numberRangeInflaterFactory(label, lastAction.size);
            }
        }
        return undefined;
    });
}
function valuePostProcess(data) {
    if (!correctResult(data)) {
        var err = new Error("unexpected result (value)");
        err.result = data;
        throw err;
    }
    return data.length ? data[0][External.VALUE_NAME] : 0;
}
function postProcessFactory(inflaters, zeroTotalApplies) {
    return function (data) {
        if (!correctResult(data)) {
            var err = new Error("unexpected result");
            err.result = data;
            throw err;
        }
        var n = data.length;
        for (var _i = 0, inflaters_1 = inflaters; _i < inflaters_1.length; _i++) {
            var inflater = inflaters_1[_i];
            for (var i = 0; i < n; i++) {
                inflater(data[i], i, data);
            }
        }
        if (n === 0 && zeroTotalApplies) {
            data = [External.makeZeroDatum(zeroTotalApplies)];
        }
        return new Dataset({ data: data });
    };
}
var SQLExternal = exports.SQLExternal = (function (_super) {
    __extends(SQLExternal, _super);
    function SQLExternal(parameters, dialect) {
        _super.call(this, parameters, dummyObject);
        this.dialect = dialect;
    }
    SQLExternal.prototype.canHandleFilter = function (ex) {
        return true;
    };
    SQLExternal.prototype.canHandleTotal = function () {
        return true;
    };
    SQLExternal.prototype.canHandleSplit = function (ex) {
        return true;
    };
    SQLExternal.prototype.canHandleApply = function (ex) {
        return true;
    };
    SQLExternal.prototype.canHandleSort = function (sortAction) {
        return true;
    };
    SQLExternal.prototype.canHandleLimit = function (limitAction) {
        return true;
    };
    SQLExternal.prototype.canHandleHavingFilter = function (ex) {
        return true;
    };
    SQLExternal.prototype.getQueryAndPostProcess = function () {
        var _a = this, source = _a.source, mode = _a.mode, applies = _a.applies, sort = _a.sort, limit = _a.limit, derivedAttributes = _a.derivedAttributes, dialect = _a.dialect;
        var query = ['SELECT'];
        var postProcess = null;
        var inflaters = [];
        var zeroTotalApplies = null;
        var from = "FROM " + this.dialect.escapeName(source);
        var filter = this.getQueryFilter();
        if (!filter.equals(Expression.TRUE)) {
            from += '\nWHERE ' + filter.getSQL(dialect);
        }
        switch (mode) {
            case 'raw':
                var selectedAttributes = this.getSelectedAttributes();
                selectedAttributes.forEach(function (attribute) {
                    var name = attribute.name, type = attribute.type;
                    switch (type) {
                        case 'BOOLEAN':
                            inflaters.push(External.booleanInflaterFactory(name));
                            break;
                        case 'SET/STRING':
                            inflaters.push(External.setStringInflaterFactory(name));
                            break;
                    }
                });
                query.push(selectedAttributes.map(function (a) {
                    var name = a.name;
                    if (derivedAttributes[name]) {
                        return new ApplyAction({ name: name, expression: derivedAttributes[name] }).getSQL(null, '', dialect);
                    }
                    else {
                        return dialect.escapeName(name);
                    }
                }).join(', '), from);
                if (sort) {
                    query.push(sort.getSQL(null, '', dialect));
                }
                if (limit) {
                    query.push(limit.getSQL(null, '', dialect));
                }
                break;
            case 'value':
                query.push(this.toValueApply().getSQL(null, '', dialect), from, dialect.constantGroupBy());
                postProcess = valuePostProcess;
                break;
            case 'total':
                zeroTotalApplies = applies;
                query.push(applies.map(function (apply) { return apply.getSQL(null, '', dialect); }).join(',\n'), from, dialect.constantGroupBy());
                break;
            case 'split':
                var split = this.getQuerySplit();
                query.push(split.getSelectSQL(dialect)
                    .concat(applies.map(function (apply) { return apply.getSQL(null, '', dialect); }))
                    .join(',\n'), from, split.getShortGroupBySQL());
                if (!(this.havingFilter.equals(Expression.TRUE))) {
                    query.push('HAVING ' + this.havingFilter.getSQL(dialect));
                }
                if (sort) {
                    query.push(sort.getSQL(null, '', dialect));
                }
                if (limit) {
                    query.push(limit.getSQL(null, '', dialect));
                }
                inflaters = getSplitInflaters(split);
                break;
            default:
                throw new Error("can not get query for mode: " + mode);
        }
        return {
            query: query.join('\n'),
            postProcess: postProcess || postProcessFactory(inflaters, zeroTotalApplies)
        };
    };
    SQLExternal.type = 'DATASET';
    return SQLExternal;
}(External));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var MySQLExternal = exports.MySQLExternal = (function (_super) {
    __extends(MySQLExternal, _super);
    function MySQLExternal(parameters) {
        _super.call(this, parameters, new MySQLDialect());
        this._ensureEngine("mysql");
    }
    MySQLExternal.fromJS = function (parameters, requester) {
        var value = External.jsToValue(parameters, requester);
        return new MySQLExternal(value);
    };
    MySQLExternal.postProcessIntrospect = function (columns) {
        return columns.map(function (column) {
            var name = column.Field;
            var sqlType = column.Type.toLowerCase();
            if (sqlType === "datetime" || sqlType === "timestamp") {
                return new AttributeInfo({ name: name, type: 'TIME' });
            }
            else if (sqlType.indexOf("varchar(") === 0 || sqlType.indexOf("blob") === 0) {
                return new AttributeInfo({ name: name, type: 'STRING' });
            }
            else if (sqlType.indexOf("int(") === 0 || sqlType.indexOf("bigint(") === 0) {
                return new AttributeInfo({ name: name, type: 'NUMBER' });
            }
            else if (sqlType.indexOf("decimal(") === 0 || sqlType.indexOf("float") === 0 || sqlType.indexOf("double") === 0) {
                return new AttributeInfo({ name: name, type: 'NUMBER' });
            }
            else if (sqlType.indexOf("tinyint(1)") === 0) {
                return new AttributeInfo({ name: name, type: 'BOOLEAN' });
            }
            return null;
        }).filter(Boolean);
    };
    MySQLExternal.getSourceList = function (requester) {
        return requester({ query: "SHOW TABLES" })
            .then(function (sources) {
            if (!Array.isArray(sources))
                throw new Error('invalid sources response');
            if (!sources.length)
                return sources;
            var key = Object.keys(sources[0])[0];
            if (!key)
                throw new Error('invalid sources response (no key)');
            return sources.map(function (s) { return s[key]; }).sort();
        });
    };
    MySQLExternal.getVersion = function (requester) {
        return requester({ query: 'SELECT @@version' })
            .then(function (res) {
            if (!Array.isArray(res) || res.length !== 1)
                throw new Error('invalid version response');
            var key = Object.keys(res[0])[0];
            if (!key)
                throw new Error('invalid version response (no key)');
            return res[0][key];
        });
    };
    MySQLExternal.prototype.getIntrospectAttributes = function () {
        return this.requester({ query: "DESCRIBE " + this.dialect.escapeName(this.source), }).then(MySQLExternal.postProcessIntrospect);
    };
    MySQLExternal.type = 'DATASET';
    return MySQLExternal;
}(SQLExternal));
External.register(MySQLExternal, 'mysql');
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var PostgresExternal = exports.PostgresExternal = (function (_super) {
    __extends(PostgresExternal, _super);
    function PostgresExternal(parameters) {
        _super.call(this, parameters, new PostgresDialect());
        this._ensureEngine("postgres");
    }
    PostgresExternal.fromJS = function (parameters, requester) {
        var value = External.jsToValue(parameters, requester);
        return new PostgresExternal(value);
    };
    PostgresExternal.postProcessIntrospect = function (columns) {
        return columns.map(function (column) {
            var name = column.name;
            var sqlType = column.sqlType.toLowerCase();
            if (sqlType.indexOf('timestamp') !== -1) {
                return new AttributeInfo({ name: name, type: 'TIME' });
            }
            else if (sqlType === 'character varying') {
                return new AttributeInfo({ name: name, type: 'STRING' });
            }
            else if (sqlType === 'integer' || sqlType === 'bigint') {
                return new AttributeInfo({ name: name, type: 'NUMBER' });
            }
            else if (sqlType === 'double precision' || sqlType === 'float') {
                return new AttributeInfo({ name: name, type: 'NUMBER' });
            }
            else if (sqlType === 'boolean') {
                return new AttributeInfo({ name: name, type: 'BOOLEAN' });
            }
            else if (sqlType === 'array') {
                var arrayType = column.arrayType.toLowerCase();
                if (arrayType === 'character')
                    return new AttributeInfo({ name: name, type: 'SET/STRING' });
                else if (arrayType === 'timestamp')
                    return new AttributeInfo({ name: name, type: 'SET/TIME' });
                else if (arrayType === 'integer' || arrayType === 'bigint' || sqlType === 'double precision' || sqlType === 'float')
                    return new AttributeInfo({ name: name, type: 'SET/NUMBER' });
                else if (arrayType === 'boolean')
                    return new AttributeInfo({ name: name, type: 'SET/BOOLEAN' });
                return null;
            }
            return null;
        }).filter(Boolean);
    };
    PostgresExternal.getSourceList = function (requester) {
        return requester({
            query: "SELECT table_name AS \"tab\" FROM INFORMATION_SCHEMA.TABLES WHERE table_type = 'BASE TABLE' AND table_schema = 'public'"
        })
            .then(function (sources) {
            if (!Array.isArray(sources))
                throw new Error('invalid sources response');
            if (!sources.length)
                return sources;
            return sources.map(function (s) { return s['tab']; }).sort();
        });
    };
    PostgresExternal.getVersion = function (requester) {
        return requester({ query: 'SELECT version()' })
            .then(function (res) {
            if (!Array.isArray(res) || res.length !== 1)
                throw new Error('invalid version response');
            var key = Object.keys(res[0])[0];
            if (!key)
                throw new Error('invalid version response (no key)');
            var versionString = res[0][key];
            var match;
            if (match = versionString.match(/^PostgreSQL (\S+) on/))
                versionString = match[1];
            return versionString;
        });
    };
    PostgresExternal.prototype.getIntrospectAttributes = function () {
        return this.requester({
            query: "SELECT c.column_name as \"name\", c.data_type as \"sqlType\", e.data_type AS \"arrayType\"\n       FROM information_schema.columns c LEFT JOIN information_schema.element_types e\n       ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)\n       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))\n       WHERE table_name = " + this.dialect.escapeLiteral(this.source),
        }).then(PostgresExternal.postProcessIntrospect);
    };
    PostgresExternal.type = 'DATASET';
    return PostgresExternal;
}(SQLExternal));
External.register(PostgresExternal, 'postgres');












function getDataName(ex) {
    if (ex instanceof RefExpression) {
        return ex.name;
    }
    else if (ex instanceof ChainExpression) {
        return getDataName(ex.expression);
    }
    else {
        return null;
    }
}
function getValue(param) {
    if (param instanceof LiteralExpression)
        return param.value;
    return param;
}
function getString(param) {
    if (typeof param === 'string')
        return param;
    if (param instanceof LiteralExpression && param.type === 'STRING') {
        return param.value;
    }
    if (param instanceof RefExpression && param.nest === 0) {
        return param.name;
    }
    throw new Error('could not extract a string out of ' + String(param));
}
function getNumber(param) {
    if (typeof param === 'number')
        return param;
    if (param instanceof LiteralExpression && param.type === 'NUMBER') {
        return param.value;
    }
    throw new Error('could not extract a number out of ' + String(param));
}
var ply = exports.ply = function(dataset) {
    if (!dataset)
        dataset = new Dataset({ data: [{}] });
    return r(dataset);
}
var $ = exports.$ = function(name, nest, type) {
    if (typeof name !== 'string')
        throw new TypeError('$() argument must be a string');
    if (typeof nest === 'string') {
        type = nest;
        nest = 0;
    }
    return new RefExpression({
        name: name,
        nest: nest != null ? nest : 0,
        type: type
    });
}
var r = exports.r = function(value) {
    if (External.isExternal(value))
        throw new TypeError('r can not accept externals');
    if (Array.isArray(value))
        value = Set.fromJS(value);
    return LiteralExpression.fromJS({ op: 'literal', value: value });
}
var toJS = exports.toJS = function(thing) {
    return (thing && typeof thing.toJS === 'function') ? thing.toJS() : thing;
}
function chainVia(op, expressions, zero) {
    var n = expressions.length;
    if (!n)
        return zero;
    var acc = expressions[0];
    if (!Expression.isExpression(acc))
        acc = Expression.fromJSLoose(acc);
    for (var i = 1; i < n; i++)
        acc = acc[op](expressions[i]);
    return acc;
}
var Expression = exports.Expression = (function () {
    function Expression(parameters, dummy) {
        if (dummy === void 0) { dummy = null; }
        this.op = parameters.op;
        if (dummy !== dummyObject) {
            throw new TypeError("can not call `new Expression` directly use Expression.fromJS instead");
        }
        if (parameters.simple)
            this.simple = true;
    }
    Expression.isExpression = function (candidate) {
        return isInstanceOf(candidate, Expression);
    };
    Expression.expressionLookupFromJS = function (expressionJSs) {
        var expressions = Object.create(null);
        for (var name in expressionJSs) {
            if (!hasOwnProperty(expressionJSs, name))
                continue;
            expressions[name] = Expression.fromJSLoose(expressionJSs[name]);
        }
        return expressions;
    };
    Expression.expressionLookupToJS = function (expressions) {
        var expressionsJSs = {};
        for (var name in expressions) {
            if (!hasOwnProperty(expressions, name))
                continue;
            expressionsJSs[name] = expressions[name].toJS();
        }
        return expressionsJSs;
    };
    Expression.parse = function (str, timezone) {
        if (str[0] === '{' && str[str.length - 1] === '}') {
            return Expression.fromJS(JSON.parse(str));
        }
        var original = Expression.defaultParserTimezone;
        if (timezone)
            Expression.defaultParserTimezone = timezone;
        try {
            return Expression.expressionParser.parse(str);
        }
        catch (e) {
            throw new Error("Expression parse error: " + e.message + " on '" + str + "'");
        }
        finally {
            Expression.defaultParserTimezone = original;
        }
    };
    Expression.parseSQL = function (str, timezone) {
        var original = Expression.defaultParserTimezone;
        if (timezone)
            Expression.defaultParserTimezone = timezone;
        try {
            return Expression.plyqlParser.parse(str);
        }
        catch (e) {
            throw new Error("SQL parse error: " + e.message + " on '" + str + "'");
        }
        finally {
            Expression.defaultParserTimezone = original;
        }
    };
    Expression.fromJSLoose = function (param) {
        var expressionJS;
        switch (typeof param) {
            case 'undefined':
                throw new Error('must have an expression');
            case 'object':
                if (param === null) {
                    return Expression.NULL;
                }
                else if (Expression.isExpression(param)) {
                    return param;
                }
                else if (isImmutableClass(param)) {
                    if (param.constructor.type) {
                        expressionJS = { op: 'literal', value: param };
                    }
                    else {
                        throw new Error("unknown object");
                    }
                }
                else if (param.op) {
                    expressionJS = param;
                }
                else if (param.toISOString) {
                    expressionJS = { op: 'literal', value: new Date(param) };
                }
                else if (Array.isArray(param)) {
                    expressionJS = { op: 'literal', value: Set.fromJS(param) };
                }
                else if (hasOwnProperty(param, 'start') && hasOwnProperty(param, 'end')) {
                    expressionJS = { op: 'literal', value: Range.fromJS(param) };
                }
                else {
                    throw new Error('unknown parameter');
                }
                break;
            case 'number':
            case 'boolean':
                expressionJS = { op: 'literal', value: param };
                break;
            case 'string':
                return Expression.parse(param);
            default:
                throw new Error("unrecognizable expression");
        }
        return Expression.fromJS(expressionJS);
    };
    Expression.inOrIs = function (lhs, value) {
        var literal = new LiteralExpression({
            op: 'literal',
            value: value
        });
        var literalType = literal.type;
        var returnExpression = null;
        if (literalType === 'NUMBER_RANGE' || literalType === 'TIME_RANGE' || literalType === 'STRING_RANGE' || isSetType(literalType)) {
            returnExpression = lhs.in(literal);
        }
        else {
            returnExpression = lhs.is(literal);
        }
        return returnExpression.simplify();
    };
    Expression.jsNullSafetyUnary = function (inputJS, ifNotNull) {
        return "(_=" + inputJS + ",(_==null?null:" + ifNotNull('_') + "))";
    };
    Expression.jsNullSafetyBinary = function (lhs, rhs, combine, lhsCantBeNull, rhsCantBeNull) {
        if (lhsCantBeNull) {
            if (rhsCantBeNull) {
                return "(" + combine(lhs, rhs) + ")";
            }
            else {
                return "(_=" + rhs + ",(_==null)?null:(" + combine(lhs, '_') + "))";
            }
        }
        else {
            if (rhsCantBeNull) {
                return "(_=" + lhs + ",(_==null)?null:(" + combine('_', rhs) + "))";
            }
            else {
                return "(_=" + rhs + ",_2=" + lhs + ",(_==null||_2==null)?null:(" + combine('_', '_2') + ")";
            }
        }
    };
    Expression.and = function (expressions) {
        return chainVia('and', expressions, Expression.TRUE);
    };
    Expression.or = function (expressions) {
        return chainVia('or', expressions, Expression.FALSE);
    };
    Expression.add = function (expressions) {
        return chainVia('add', expressions, Expression.ZERO);
    };
    Expression.subtract = function (expressions) {
        return chainVia('subtract', expressions, Expression.ZERO);
    };
    Expression.multiply = function (expressions) {
        return chainVia('multiply', expressions, Expression.ONE);
    };
    Expression.power = function (expressions) {
        return chainVia('power', expressions, Expression.ZERO);
    };
    Expression.concat = function (expressions) {
        return chainVia('concat', expressions, Expression.EMPTY_STRING);
    };
    Expression.register = function (ex) {
        var op = ex.name.replace('Expression', '').replace(/^\w/, function (s) { return s.toLowerCase(); });
        Expression.classMap[op] = ex;
    };
    Expression.fromJS = function (expressionJS) {
        if (!hasOwnProperty(expressionJS, "op")) {
            throw new Error("op must be defined");
        }
        var op = expressionJS.op;
        if (typeof op !== "string") {
            throw new Error("op must be a string");
        }
        var ClassFn = Expression.classMap[op];
        if (!ClassFn) {
            throw new Error("unsupported expression op '" + op + "'");
        }
        return ClassFn.fromJS(expressionJS);
    };
    Expression.prototype._ensureOp = function (op) {
        if (!this.op) {
            this.op = op;
            return;
        }
        if (this.op !== op) {
            throw new TypeError("incorrect expression op '" + this.op + "' (needs to be: '" + op + "')");
        }
    };
    Expression.prototype.valueOf = function () {
        var value = { op: this.op };
        if (this.simple)
            value.simple = true;
        return value;
    };
    Expression.prototype.toJS = function () {
        return {
            op: this.op
        };
    };
    Expression.prototype.toJSON = function () {
        return this.toJS();
    };
    Expression.prototype.toString = function (indent) {
        return 'BaseExpression';
    };
    Expression.prototype.equals = function (other) {
        return Expression.isExpression(other) &&
            this.op === other.op &&
            this.type === other.type;
    };
    Expression.prototype.canHaveType = function (wantedType) {
        var type = this.type;
        if (!type)
            return true;
        if (wantedType === 'SET') {
            return isSetType(type);
        }
        else {
            return type === wantedType;
        }
    };
    Expression.prototype.expressionCount = function () {
        return 1;
    };
    Expression.prototype.isOp = function (op) {
        return this.op === op;
    };
    Expression.prototype.containsOp = function (op) {
        return this.some(function (ex) { return ex.isOp(op) || null; });
    };
    Expression.prototype.hasExternal = function () {
        return this.some(function (ex) {
            if (ex instanceof ExternalExpression)
                return true;
            if (ex instanceof RefExpression)
                return ex.isRemote();
            return null;
        });
    };
    Expression.prototype.getBaseExternals = function () {
        var externals = [];
        this.forEach(function (ex) {
            if (ex instanceof ExternalExpression)
                externals.push(ex.external.getBase());
        });
        return External.deduplicateExternals(externals);
    };
    Expression.prototype.getRawExternals = function () {
        var externals = [];
        this.forEach(function (ex) {
            if (ex instanceof ExternalExpression)
                externals.push(ex.external.getRaw());
        });
        return External.deduplicateExternals(externals);
    };
    Expression.prototype.getFreeReferences = function () {
        var freeReferences = [];
        this.forEach(function (ex, index, depth, nestDiff) {
            if (ex instanceof RefExpression && nestDiff <= ex.nest) {
                freeReferences.push(repeat('^', ex.nest - nestDiff) + ex.name);
            }
        });
        return deduplicateSort(freeReferences);
    };
    Expression.prototype.getFreeReferenceIndexes = function () {
        var freeReferenceIndexes = [];
        this.forEach(function (ex, index, depth, nestDiff) {
            if (ex instanceof RefExpression && nestDiff <= ex.nest) {
                freeReferenceIndexes.push(index);
            }
        });
        return freeReferenceIndexes;
    };
    Expression.prototype.incrementNesting = function (by) {
        if (by === void 0) { by = 1; }
        var freeReferenceIndexes = this.getFreeReferenceIndexes();
        if (freeReferenceIndexes.length === 0)
            return this;
        return this.substitute(function (ex, index) {
            if (ex instanceof RefExpression && freeReferenceIndexes.indexOf(index) !== -1) {
                return ex.incrementNesting(by);
            }
            return null;
        });
    };
    Expression.prototype.simplify = function () {
        return this;
    };
    Expression.prototype.every = function (iter, thisArg) {
        return this._everyHelper(iter, thisArg, { index: 0 }, 0, 0);
    };
    Expression.prototype._everyHelper = function (iter, thisArg, indexer, depth, nestDiff) {
        var pass = iter.call(thisArg, this, indexer.index, depth, nestDiff);
        if (pass != null) {
            return pass;
        }
        else {
            indexer.index++;
        }
        return true;
    };
    Expression.prototype.some = function (iter, thisArg) {
        var _this = this;
        return !this.every(function (ex, index, depth, nestDiff) {
            var v = iter.call(_this, ex, index, depth, nestDiff);
            return (v == null) ? null : !v;
        }, thisArg);
    };
    Expression.prototype.forEach = function (iter, thisArg) {
        var _this = this;
        this.every(function (ex, index, depth, nestDiff) {
            iter.call(_this, ex, index, depth, nestDiff);
            return null;
        }, thisArg);
    };
    Expression.prototype.substitute = function (substitutionFn, thisArg) {
        return this._substituteHelper(substitutionFn, thisArg, { index: 0 }, 0, 0);
    };
    Expression.prototype._substituteHelper = function (substitutionFn, thisArg, indexer, depth, nestDiff) {
        var sub = substitutionFn.call(thisArg, this, indexer.index, depth, nestDiff);
        if (sub) {
            indexer.index += this.expressionCount();
            return sub;
        }
        else {
            indexer.index++;
        }
        return this;
    };
    Expression.prototype.substituteAction = function (actionMatchFn, actionSubstitutionFn, options, thisArg) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return this.substitute(function (ex) {
            if (ex instanceof ChainExpression) {
                var actions = ex.actions;
                for (var i = 0; i < actions.length; i++) {
                    var action = actions[i];
                    if (actionMatchFn.call(_this, action)) {
                        var newEx = actionSubstitutionFn.call(_this, ex.headActions(i), action);
                        for (var j = i + 1; j < actions.length; j++)
                            newEx = newEx.performAction(actions[j]);
                        if (options.onceInChain)
                            return newEx;
                        return newEx.substituteAction(actionMatchFn, actionSubstitutionFn, options, _this);
                    }
                }
            }
            return null;
        }, thisArg);
    };
    Expression.prototype.getJSFn = function (datumVar) {
        if (datumVar === void 0) { datumVar = 'd[]'; }
        var type = this.type;
        var jsEx = this.getJS(datumVar);
        var body;
        if (type === 'NUMBER' || type === 'NUMBER_RANGE' || type === 'TIME') {
            body = "_=" + jsEx + ";return isNaN(_)?null:_";
        }
        else {
            body = "return " + jsEx + ";";
        }
        return "function(" + datumVar.replace('[]', '') + "){var _,_2;" + body + "}";
    };
    Expression.prototype.extractFromAnd = function (matchFn) {
        if (this.type !== 'BOOLEAN')
            return null;
        if (matchFn(this)) {
            return {
                extract: this,
                rest: Expression.TRUE
            };
        }
        else {
            return {
                extract: Expression.TRUE,
                rest: this
            };
        }
    };
    Expression.prototype.breakdownByDataset = function (tempNamePrefix) {
        var nameIndex = 0;
        var singleDatasetActions = [];
        var externals = this.getBaseExternals();
        if (externals.length < 2) {
            throw new Error('not a multiple dataset expression');
        }
        var combine = this.substitute(function (ex) {
            var externals = ex.getBaseExternals();
            if (externals.length !== 1)
                return null;
            var existingApply = find(singleDatasetActions, function (apply) { return apply.expression.equals(ex); });
            var tempName;
            if (existingApply) {
                tempName = existingApply.name;
            }
            else {
                tempName = tempNamePrefix + (nameIndex++);
                singleDatasetActions.push(new ApplyAction({
                    action: 'apply',
                    name: tempName,
                    expression: ex
                }));
            }
            return new RefExpression({
                op: 'ref',
                name: tempName,
                nest: 0
            });
        });
        return {
            combineExpression: combine,
            singleDatasetActions: singleDatasetActions
        };
    };
    Expression.prototype.actionize = function (containingAction) {
        return null;
    };
    Expression.prototype.getExpressionPattern = function (actionType) {
        var actions = this.actionize(actionType);
        return actions ? actions.map(function (action) { return action.expression; }) : null;
    };
    Expression.prototype.firstAction = function () {
        return null;
    };
    Expression.prototype.lastAction = function () {
        return null;
    };
    Expression.prototype.headActions = function (n) {
        return this;
    };
    Expression.prototype.popAction = function () {
        return null;
    };
    Expression.prototype.getLiteralValue = function () {
        return null;
    };
    Expression.prototype.bumpStringLiteralToTime = function () {
        return this;
    };
    Expression.prototype.bumpStringLiteralToSetString = function () {
        return this;
    };
    Expression.prototype.upgradeToType = function (targetType) {
        return this;
    };
    Expression.prototype.performAction = function (action, markSimple) {
        return this.performActions([action], markSimple);
    };
    Expression.prototype.performActions = function (actions, markSimple) {
        if (!actions.length)
            return this;
        return new ChainExpression({
            expression: this,
            actions: actions,
            simple: Boolean(markSimple)
        });
    };
    Expression.prototype._performMultiAction = function (action, exs) {
        if (!exs.length)
            throw new Error(action + " action must have at least one argument");
        var ret = this;
        for (var _i = 0, exs_1 = exs; _i < exs_1.length; _i++) {
            var ex = exs_1[_i];
            if (!Expression.isExpression(ex))
                ex = Expression.fromJSLoose(ex);
            var ActionConstructor = Action.classMap[action];
            ret = ret.performAction(new ActionConstructor({ expression: ex }));
        }
        return ret;
    };
    Expression.prototype.add = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._performMultiAction('add', exs);
    };
    Expression.prototype.subtract = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._performMultiAction('subtract', exs);
    };
    Expression.prototype.negate = function () {
        return Expression.ZERO.subtract(this);
    };
    Expression.prototype.multiply = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._performMultiAction('multiply', exs);
    };
    Expression.prototype.divide = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._performMultiAction('divide', exs);
    };
    Expression.prototype.reciprocate = function () {
        return Expression.ONE.divide(this);
    };
    Expression.prototype.sqrt = function () {
        return this.power(0.5);
    };
    Expression.prototype.power = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._performMultiAction('power', exs);
    };
    Expression.prototype.fallback = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new FallbackAction({ expression: ex }));
    };
    Expression.prototype.is = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new IsAction({ expression: ex }));
    };
    Expression.prototype.isnt = function (ex) {
        return this.is(ex).not();
    };
    Expression.prototype.lessThan = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new LessThanAction({ expression: ex }));
    };
    Expression.prototype.lessThanOrEqual = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new LessThanOrEqualAction({ expression: ex }));
    };
    Expression.prototype.greaterThan = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new GreaterThanAction({ expression: ex }));
    };
    Expression.prototype.greaterThanOrEqual = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new GreaterThanOrEqualAction({ expression: ex }));
    };
    Expression.prototype.contains = function (ex, compare) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        if (compare)
            compare = getString(compare);
        return this.performAction(new ContainsAction({ expression: ex, compare: compare }));
    };
    Expression.prototype.match = function (re) {
        return this.performAction(new MatchAction({ regexp: getString(re) }));
    };
    Expression.prototype.in = function (ex, snd) {
        if (arguments.length === 2) {
            ex = getValue(ex);
            snd = getValue(snd);
            if (typeof ex === 'string') {
                var parse = parseISODate(ex, Expression.defaultParserTimezone);
                if (parse)
                    ex = parse;
            }
            if (typeof snd === 'string') {
                var parse = parseISODate(snd, Expression.defaultParserTimezone);
                if (parse)
                    snd = parse;
            }
            if (typeof ex === 'number' && typeof snd === 'number') {
                ex = new NumberRange({ start: ex, end: snd });
            }
            else if (ex.toISOString && snd.toISOString) {
                ex = new TimeRange({ start: ex, end: snd });
            }
            else if (typeof ex === 'string' && typeof snd === 'string') {
                ex = new StringRange({ start: ex, end: snd });
            }
            else {
                throw new Error('uninterpretable IN parameters');
            }
        }
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new InAction({ expression: ex }));
    };
    Expression.prototype.overlap = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.bumpStringLiteralToSetString().performAction(new OverlapAction({ expression: ex.bumpStringLiteralToSetString() }));
    };
    Expression.prototype.not = function () {
        return this.performAction(new NotAction({}));
    };
    Expression.prototype.and = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._performMultiAction('and', exs);
    };
    Expression.prototype.or = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._performMultiAction('or', exs);
    };
    Expression.prototype.substr = function (position, length) {
        return this.performAction(new SubstrAction({ position: getNumber(position), length: getNumber(length) }));
    };
    Expression.prototype.extract = function (re) {
        return this.performAction(new ExtractAction({ regexp: getString(re) }));
    };
    Expression.prototype.concat = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._performMultiAction('concat', exs);
    };
    Expression.prototype.lookup = function (lookup) {
        return this.performAction(new LookupAction({ lookup: getString(lookup) }));
    };
    Expression.prototype.indexOf = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new IndexOfAction({ expression: ex }));
    };
    Expression.prototype.transformCase = function (transformType) {
        return this.performAction(new TransformCaseAction({ transformType: getString(transformType) }));
    };
    Expression.prototype.customTransform = function (custom, outputType) {
        if (!custom)
            throw new Error("Must provide an extraction function name for custom transform");
        var outputType = outputType !== undefined ? getString(outputType) : null;
        return this.performAction(new CustomTransformAction({ custom: getString(custom), outputType: outputType }));
    };
    Expression.prototype.numberBucket = function (size, offset) {
        if (offset === void 0) { offset = 0; }
        return this.performAction(new NumberBucketAction({ size: getNumber(size), offset: getNumber(offset) }));
    };
    Expression.prototype.absolute = function () {
        return this.performAction(new AbsoluteAction({}));
    };
    Expression.prototype.length = function () {
        return this.performAction(new LengthAction({}));
    };
    Expression.prototype.timeBucket = function (duration, timezone) {
        if (!Duration.isDuration(duration))
            duration = Duration.fromJS(getString(duration));
        if (timezone && !Timezone.isTimezone(timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return this.bumpStringLiteralToTime().performAction(new TimeBucketAction({ duration: duration, timezone: timezone }));
    };
    Expression.prototype.timeFloor = function (duration, timezone) {
        if (!Duration.isDuration(duration))
            duration = Duration.fromJS(getString(duration));
        if (timezone && !Timezone.isTimezone(timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return this.bumpStringLiteralToTime().performAction(new TimeFloorAction({ duration: duration, timezone: timezone }));
    };
    Expression.prototype.timeShift = function (duration, step, timezone) {
        if (!Duration.isDuration(duration))
            duration = Duration.fromJS(getString(duration));
        if (timezone && !Timezone.isTimezone(timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return this.bumpStringLiteralToTime().performAction(new TimeShiftAction({ duration: duration, step: getNumber(step), timezone: timezone }));
    };
    Expression.prototype.timeRange = function (duration, step, timezone) {
        if (!Duration.isDuration(duration))
            duration = Duration.fromJS(getString(duration));
        if (timezone && !Timezone.isTimezone(timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return this.bumpStringLiteralToTime().performAction(new TimeRangeAction({ duration: duration, step: getNumber(step), timezone: timezone }));
    };
    Expression.prototype.timePart = function (part, timezone) {
        if (timezone && !Timezone.isTimezone(timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return this.bumpStringLiteralToTime().performAction(new TimePartAction({ part: getString(part), timezone: timezone }));
    };
    Expression.prototype.cast = function (outputType) {
        return this.performAction(new CastAction({ outputType: getString(outputType) }));
    };
    Expression.prototype.cardinality = function () {
        return this.performAction(new CardinalityAction({}));
    };
    Expression.prototype.filter = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new FilterAction({ expression: ex }));
    };
    Expression.prototype.split = function (splits, name, dataName) {
        if (arguments.length === 3 ||
            (arguments.length === 2 && splits && (typeof splits === 'string' || typeof splits.op === 'string'))) {
            name = getString(name);
            var realSplits = Object.create(null);
            realSplits[name] = splits;
            splits = realSplits;
        }
        else {
            dataName = name;
        }
        var parsedSplits = Object.create(null);
        for (var k in splits) {
            if (!hasOwnProperty(splits, k))
                continue;
            var ex = splits[k];
            parsedSplits[k] = Expression.isExpression(ex) ? ex : Expression.fromJSLoose(ex);
        }
        dataName = dataName ? getString(dataName) : getDataName(this);
        if (!dataName)
            throw new Error("could not guess data name in `split`, please provide one explicitly");
        return this.performAction(new SplitAction({ splits: parsedSplits, dataName: dataName }));
    };
    Expression.prototype.apply = function (name, ex) {
        if (arguments.length < 2)
            throw new Error('invalid arguments to .apply, did you forget to specify a name?');
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new ApplyAction({ name: getString(name), expression: ex }));
    };
    Expression.prototype.sort = function (ex, direction) {
        if (direction === void 0) { direction = 'ascending'; }
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new SortAction({ expression: ex, direction: getString(direction) }));
    };
    Expression.prototype.limit = function (limit) {
        return this.performAction(new LimitAction({ limit: getNumber(limit) }));
    };
    Expression.prototype.select = function () {
        var attributes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            attributes[_i - 0] = arguments[_i];
        }
        attributes = attributes.map(getString);
        return this.performAction(new SelectAction({ attributes: attributes }));
    };
    Expression.prototype.count = function () {
        if (arguments.length)
            throw new Error('.count() should not have arguments, did you want to .filter().count()?');
        return this.performAction(new CountAction({}));
    };
    Expression.prototype.sum = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new SumAction({ expression: ex }));
    };
    Expression.prototype.min = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new MinAction({ expression: ex }));
    };
    Expression.prototype.max = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new MaxAction({ expression: ex }));
    };
    Expression.prototype.average = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new AverageAction({ expression: ex }));
    };
    Expression.prototype.countDistinct = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new CountDistinctAction({ expression: ex }));
    };
    Expression.prototype.quantile = function (ex, quantile) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new QuantileAction({ expression: ex, quantile: getNumber(quantile) }));
    };
    Expression.prototype.custom = function (custom) {
        return this.performAction(new CustomAggregateAction({ custom: getString(custom) }));
    };
    Expression.prototype.customAggregate = function (custom) {
        return this.performAction(new CustomAggregateAction({ custom: getString(custom) }));
    };
    Expression.prototype.join = function (ex) {
        if (!Expression.isExpression(ex))
            ex = Expression.fromJSLoose(ex);
        return this.performAction(new JoinAction({ expression: ex }));
    };
    Expression.prototype.defineEnvironment = function (environment) {
        if (!environment.timezone)
            environment = { timezone: Timezone.UTC };
        if (typeof environment.timezone === 'string')
            environment = { timezone: Timezone.fromJS(environment.timezone) };
        return this.substituteAction(function (action) { return action.needsEnvironment(); }, function (preEx, action) { return preEx.performAction(action.defineEnvironment(environment)); });
    };
    Expression.prototype.referenceCheck = function (context) {
        return this.referenceCheckInTypeContext(getFullTypeFromDatum(context));
    };
    Expression.prototype.definedInTypeContext = function (typeContext) {
        try {
            var alterations = {};
            this._fillRefSubstitutions(typeContext, { index: 0 }, alterations);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    Expression.prototype.referenceCheckInTypeContext = function (typeContext) {
        var alterations = {};
        this._fillRefSubstitutions(typeContext, { index: 0 }, alterations);
        if (emptyLookup(alterations))
            return this;
        return this.substitute(function (ex, index) { return alterations[index] || null; });
    };
    Expression.prototype._fillRefSubstitutions = function (typeContext, indexer, alterations) {
        indexer.index++;
        return typeContext;
    };
    Expression.prototype.resolve = function (context, ifNotFound) {
        if (ifNotFound === void 0) { ifNotFound = 'throw'; }
        var expressions = Object.create(null);
        for (var k in context) {
            if (!hasOwnProperty(context, k))
                continue;
            var value = context[k];
            expressions[k] = External.isExternal(value) ?
                new ExternalExpression({ external: value }) :
                new LiteralExpression({ value: value });
        }
        return this.resolveWithExpressions(expressions, ifNotFound);
    };
    Expression.prototype.resolveWithExpressions = function (expressions, ifNotFound) {
        if (ifNotFound === void 0) { ifNotFound = 'throw'; }
        return this.substitute(function (ex, index, depth, nestDiff) {
            if (ex instanceof RefExpression) {
                var nest = ex.nest;
                if (nestDiff === nest) {
                    var foundExpression = null;
                    var valueFound = false;
                    if (hasOwnProperty(expressions, ex.name)) {
                        foundExpression = expressions[ex.name];
                        valueFound = true;
                    }
                    else {
                        valueFound = false;
                    }
                    if (valueFound) {
                        return foundExpression;
                    }
                    else if (ifNotFound === 'throw') {
                        throw new Error("could not resolve " + ex + " because is was not in the context");
                    }
                    else if (ifNotFound === 'null') {
                        return Expression.NULL;
                    }
                    else if (ifNotFound === 'leave') {
                        return ex;
                    }
                }
                else if (nestDiff < nest) {
                    throw new Error("went too deep during resolve on: " + ex);
                }
            }
            return null;
        });
    };
    Expression.prototype.resolved = function () {
        return this.every(function (ex) {
            return (ex instanceof RefExpression) ? ex.nest === 0 : null;
        });
    };
    Expression.prototype.contained = function () {
        return this.every(function (ex, index, depth, nestDiff) {
            if (ex instanceof RefExpression) {
                var nest = ex.nest;
                return nestDiff >= nest;
            }
            return null;
        });
    };
    Expression.prototype.decomposeAverage = function (countEx) {
        return this.substituteAction(function (action) {
            return action.action === 'average';
        }, function (preEx, action) {
            var expression = action.expression;
            return preEx.sum(expression).divide(countEx ? preEx.sum(countEx) : preEx.count());
        });
    };
    Expression.prototype.distribute = function () {
        return this.substituteAction(function (action) {
            return action.canDistribute();
        }, function (preEx, action) {
            var distributed = action.distribute(preEx);
            if (!distributed)
                throw new Error('distribute returned null');
            return distributed;
        });
    };
    Expression.prototype._initialPrepare = function (context, environment) {
        return this.defineEnvironment(environment)
            .referenceCheck(context)
            .resolve(context)
            .simplify();
    };
    Expression.prototype.simulate = function (context, environment) {
        if (context === void 0) { context = {}; }
        if (environment === void 0) { environment = {}; }
        var readyExpression = this._initialPrepare(context, environment);
        if (readyExpression instanceof ExternalExpression) {
            readyExpression = readyExpression.unsuppress();
        }
        return readyExpression._computeResolvedSimulate(true, []);
    };
    Expression.prototype.simulateQueryPlan = function (context, environment) {
        if (context === void 0) { context = {}; }
        if (environment === void 0) { environment = {}; }
        if (!datumHasExternal(context) && !this.hasExternal())
            return [];
        var readyExpression = this._initialPrepare(context, environment);
        if (readyExpression instanceof ExternalExpression) {
            readyExpression = readyExpression.unsuppress();
        }
        var simulatedQueries = [];
        readyExpression._computeResolvedSimulate(true, simulatedQueries);
        return simulatedQueries;
    };
    Expression.prototype.compute = function (context, environment) {
        var _this = this;
        if (context === void 0) { context = {}; }
        if (environment === void 0) { environment = {}; }
        if (!datumHasExternal(context) && !this.hasExternal()) {
            return Q.fcall(function () {
                var referenceChecked = _this.defineEnvironment(environment).referenceCheck(context);
                return referenceChecked.getFn()(context, null);
            });
        }
        return introspectDatum(context)
            .then(function (introspectedContext) {
            var readyExpression = _this._initialPrepare(introspectedContext, environment);
            if (readyExpression instanceof ExternalExpression) {
                readyExpression = readyExpression.unsuppress();
            }
            return readyExpression._computeResolved(true);
        });
    };
    Expression.defaultParserTimezone = Timezone.UTC;
    Expression.classMap = {};
    return Expression;
}());
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};







var LiteralExpression = exports.LiteralExpression = (function (_super) {
    __extends(LiteralExpression, _super);
    function LiteralExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        var value = parameters.value;
        this.value = value;
        this._ensureOp("literal");
        if (typeof this.value === 'undefined') {
            throw new TypeError("must have a `value`");
        }
        this.type = getValueType(value);
        this.simple = true;
    }
    LiteralExpression.fromJS = function (parameters) {
        var value = {
            op: parameters.op,
            type: parameters.type
        };
        if (!hasOwnProperty(parameters, 'value'))
            throw new Error('literal expression must have value');
        var v = parameters.value;
        if (isImmutableClass(v)) {
            value.value = v;
        }
        else {
            value.value = valueFromJS(v, parameters.type);
        }
        return new LiteralExpression(value);
    };
    LiteralExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.value = this.value;
        if (this.type)
            value.type = this.type;
        return value;
    };
    LiteralExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        if (this.value && this.value.toJS) {
            js.value = this.value.toJS();
            js.type = isSetType(this.type) ? 'SET' : this.type;
        }
        else {
            js.value = this.value;
            if (this.type === 'TIME')
                js.type = 'TIME';
        }
        return js;
    };
    LiteralExpression.prototype.toString = function () {
        var value = this.value;
        if (value instanceof Dataset && value.basis()) {
            return 'ply()';
        }
        else if (this.type === 'STRING') {
            return JSON.stringify(value);
        }
        else {
            return String(value);
        }
    };
    LiteralExpression.prototype.getFn = function () {
        var value = this.value;
        return function () { return value; };
    };
    LiteralExpression.prototype.getJS = function (datumVar) {
        return JSON.stringify(this.value);
    };
    LiteralExpression.prototype.getSQL = function (dialect) {
        var value = this.value;
        if (value === null)
            return 'NULL';
        switch (this.type) {
            case 'STRING':
                return dialect.escapeLiteral(value);
            case 'BOOLEAN':
                return dialect.booleanToSQL(value);
            case 'NUMBER':
                return dialect.numberToSQL(value);
            case 'NUMBER_RANGE':
                return "" + dialect.numberToSQL(value.start);
            case 'TIME':
                return dialect.timeToSQL(value);
            case 'TIME_RANGE':
                return "" + dialect.timeToSQL(value.start);
            case 'STRING_RANGE':
                return dialect.escapeLiteral(value.start);
            case 'SET/STRING':
            case 'SET/NUMBER':
                return '(' + value.elements.map(function (v) { return typeof v === 'number' ? v : dialect.escapeLiteral(v); }).join(',') + ')';
            case 'SET/NUMBER_RANGE':
            case 'SET/TIME_RANGE':
                return 'FALSE';
            default:
                throw new Error("currently unsupported type: " + this.type);
        }
    };
    LiteralExpression.prototype.equals = function (other) {
        if (!_super.prototype.equals.call(this, other) || this.type !== other.type)
            return false;
        if (this.value) {
            if (this.value.equals) {
                return this.value.equals(other.value);
            }
            else if (this.value.toISOString && other.value.toISOString) {
                return this.value.valueOf() === other.value.valueOf();
            }
            else {
                return this.value === other.value;
            }
        }
        else {
            return this.value === other.value;
        }
    };
    LiteralExpression.prototype._fillRefSubstitutions = function (typeContext, indexer, alterations) {
        indexer.index++;
        if (this.type == 'DATASET') {
            var newTypeContext = this.value.getFullType();
            newTypeContext.parent = typeContext;
            return newTypeContext;
        }
        else {
            return { type: this.type };
        }
    };
    LiteralExpression.prototype.getLiteralValue = function () {
        return this.value;
    };
    LiteralExpression.prototype._computeResolvedSimulate = function () {
        return this.value;
    };
    LiteralExpression.prototype._computeResolved = function () {
        return Q(this.value);
    };
    LiteralExpression.prototype.maxPossibleSplitValues = function () {
        var value = this.value;
        return Set.isSet(value) ? value.size() : 1;
    };
    LiteralExpression.prototype.bumpStringLiteralToTime = function () {
        if (this.type !== 'STRING')
            return this;
        var parse = parseISODate(this.value, Expression.defaultParserTimezone);
        if (!parse)
            throw new Error("could not parse '" + this.value + "' as time");
        return r(parse);
    };
    LiteralExpression.prototype.bumpStringLiteralToSetString = function () {
        if (this.type !== 'STRING')
            return this;
        return r(Set.fromJS([this.value]));
    };
    LiteralExpression.prototype.upgradeToType = function (targetType) {
        var _a = this, type = _a.type, value = _a.value;
        if (type === targetType || targetType !== 'TIME')
            return this;
        if (type === 'STRING') {
            var parse = parseISODate(value, Expression.defaultParserTimezone);
            return parse ? r(parse) : this;
        }
        else if (type === 'STRING_RANGE') {
            var parseStart = parseISODate(value.start, Expression.defaultParserTimezone);
            var parseEnd = parseISODate(value.end, Expression.defaultParserTimezone);
            if (parseStart || parseEnd) {
                return new LiteralExpression({
                    type: "TIME_RANGE",
                    value: TimeRange.fromJS({
                        start: parseStart, end: parseEnd, bounds: '[]'
                    })
                });
            }
        }
        return this;
    };
    return LiteralExpression;
}(Expression));
Expression.NULL = new LiteralExpression({ value: null });
Expression.ZERO = new LiteralExpression({ value: 0 });
Expression.ONE = new LiteralExpression({ value: 1 });
Expression.FALSE = new LiteralExpression({ value: false });
Expression.TRUE = new LiteralExpression({ value: true });
Expression.EMPTY_STRING = new LiteralExpression({ value: '' });
Expression.EMPTY_SET = new LiteralExpression({ value: Set.fromJS([]) });
Expression.register(LiteralExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var POSSIBLE_TYPES = exports.POSSIBLE_TYPES = {
    'NULL': 1,
    'BOOLEAN': 1,
    'NUMBER': 1,
    'TIME': 1,
    'STRING': 1,
    'NUMBER_RANGE': 1,
    'TIME_RANGE': 1,
    'SET': 1,
    'SET/NULL': 1,
    'SET/BOOLEAN': 1,
    'SET/NUMBER': 1,
    'SET/TIME': 1,
    'SET/STRING': 1,
    'SET/NUMBER_RANGE': 1,
    'SET/TIME_RANGE': 1,
    'DATASET': 1
};
var GENERATIONS_REGEXP = /^\^+/;
var TYPE_REGEXP = /:([A-Z\/_]+)$/;
var RefExpression = exports.RefExpression = (function (_super) {
    __extends(RefExpression, _super);
    function RefExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("ref");
        var name = parameters.name;
        if (typeof name !== 'string' || name.length === 0) {
            throw new TypeError("must have a nonempty `name`");
        }
        this.name = name;
        var nest = parameters.nest;
        if (typeof nest !== 'number') {
            throw new TypeError("must have nest");
        }
        if (nest < 0) {
            throw new Error("nest must be non-negative");
        }
        this.nest = nest;
        var myType = parameters.type;
        if (myType) {
            if (!RefExpression.validType(myType)) {
                throw new TypeError("unsupported type '" + myType + "'");
            }
            this.type = myType;
        }
        this.remote = Boolean(parameters.remote);
        this.simple = true;
    }
    RefExpression.fromJS = function (parameters) {
        var value;
        if (hasOwnProperty(parameters, 'nest')) {
            value = parameters;
        }
        else {
            value = {
                op: 'ref',
                nest: 0,
                name: parameters.name,
                type: parameters.type
            };
        }
        return new RefExpression(value);
    };
    RefExpression.parse = function (str) {
        var refValue = { op: 'ref' };
        var match;
        match = str.match(GENERATIONS_REGEXP);
        if (match) {
            var nest = match[0].length;
            refValue.nest = nest;
            str = str.substr(nest);
        }
        else {
            refValue.nest = 0;
        }
        match = str.match(TYPE_REGEXP);
        if (match) {
            refValue.type = match[1];
            str = str.substr(0, str.length - match[0].length);
        }
        if (str[0] === '{' && str[str.length - 1] === '}') {
            str = str.substr(1, str.length - 2);
        }
        refValue.name = str;
        return new RefExpression(refValue);
    };
    RefExpression.validType = function (typeName) {
        return hasOwnProperty(POSSIBLE_TYPES, typeName);
    };
    RefExpression.toJavaScriptSafeName = function (variableName) {
        if (!RefExpression.SIMPLE_NAME_REGEXP.test(variableName)) {
            variableName = variableName.replace(/\W/g, function (c) { return ("$" + c.charCodeAt(0)); });
        }
        return '_' + variableName;
    };
    RefExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.name = this.name;
        value.nest = this.nest;
        if (this.type)
            value.type = this.type;
        if (this.remote)
            value.remote = true;
        return value;
    };
    RefExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.name = this.name;
        if (this.nest)
            js.nest = this.nest;
        if (this.type)
            js.type = this.type;
        return js;
    };
    RefExpression.prototype.toString = function () {
        var str = this.name;
        if (!RefExpression.SIMPLE_NAME_REGEXP.test(str)) {
            str = '{' + str + '}';
        }
        if (this.nest) {
            str = repeat('^', this.nest) + str;
        }
        if (this.type) {
            str += ':' + this.type;
        }
        return '$' + str;
    };
    RefExpression.prototype.getFn = function () {
        var name = this.name;
        var nest = this.nest;
        return function (d, c) {
            if (nest) {
                return c[name];
            }
            else {
                if (hasOwnProperty(d, name)) {
                    return d[name];
                }
                else {
                    return null;
                }
            }
        };
    };
    RefExpression.prototype.getJS = function (datumVar) {
        if (this.nest)
            throw new Error("can not call getJS on unresolved expression");
        var name = this.name;
        var expr;
        if (datumVar) {
            expr = datumVar.replace('[]', "[" + JSON.stringify(name) + "]");
        }
        else {
            expr = RefExpression.toJavaScriptSafeName(name);
        }
        if (this.type === 'NUMBER')
            expr = "(+" + expr + ")";
        return expr;
    };
    RefExpression.prototype.getSQL = function (dialect, minimal) {
        if (minimal === void 0) { minimal = false; }
        if (this.nest)
            throw new Error("can not call getSQL on unresolved expression: " + this);
        return dialect.escapeName(this.name);
    };
    RefExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.name === other.name &&
            this.nest === other.nest &&
            this.remote === other.remote;
    };
    RefExpression.prototype.isRemote = function () {
        return this.remote;
    };
    RefExpression.prototype._fillRefSubstitutions = function (typeContext, indexer, alterations) {
        var myIndex = indexer.index;
        indexer.index++;
        var nest = this.nest;
        var myTypeContext = typeContext;
        while (nest--) {
            myTypeContext = myTypeContext.parent;
            if (!myTypeContext)
                throw new Error('went too deep on ' + this.toString());
        }
        var nestDiff = 0;
        while (myTypeContext && !myTypeContext.datasetType[this.name]) {
            myTypeContext = myTypeContext.parent;
            nestDiff++;
        }
        if (!myTypeContext) {
            throw new Error('could not resolve ' + this.toString());
        }
        var myFullType = myTypeContext.datasetType[this.name];
        var myType = myFullType.type;
        var myRemote = Boolean(myFullType.remote);
        if (this.type && this.type !== myType) {
            throw new TypeError("type mismatch in " + this + " (has: " + this.type + " needs: " + myType + ")");
        }
        if (!this.type || nestDiff > 0 || this.remote !== myRemote) {
            alterations[myIndex] = new RefExpression({
                name: this.name,
                nest: this.nest + nestDiff,
                type: myType,
                remote: myRemote
            });
        }
        if (myType === 'DATASET') {
            return {
                parent: typeContext,
                type: 'DATASET',
                datasetType: myFullType.datasetType,
                remote: myFullType.remote
            };
        }
        return myFullType;
    };
    RefExpression.prototype.incrementNesting = function (by) {
        if (by === void 0) { by = 1; }
        var value = this.valueOf();
        value.nest = by + value.nest;
        return new RefExpression(value);
    };
    RefExpression.prototype._computeResolvedSimulate = function () {
        throw new Error('should never get here');
    };
    RefExpression.prototype._computeResolved = function () {
        throw new Error('should never get here');
    };
    RefExpression.prototype.maxPossibleSplitValues = function () {
        return this.type === 'BOOLEAN' ? 3 : Infinity;
    };
    RefExpression.prototype.upgradeToType = function (targetType) {
        var type = this.type;
        if (targetType === 'TIME' && (!type || type === 'STRING')) {
            return this.changeType(targetType);
        }
        return this;
    };
    RefExpression.prototype.changeType = function (newType) {
        var value = this.valueOf();
        value.type = newType;
        return new RefExpression(value);
    };
    RefExpression.SIMPLE_NAME_REGEXP = /^([a-z_]\w*)$/i;
    return RefExpression;
}(Expression));
Expression.register(RefExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var ExternalExpression = exports.ExternalExpression = (function (_super) {
    __extends(ExternalExpression, _super);
    function ExternalExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        var external = parameters.external;
        if (!external)
            throw new Error('must have an external');
        this.external = external;
        this._ensureOp('external');
        this.type = external.mode === 'value' ? 'NUMBER' : 'DATASET';
        this.simple = true;
    }
    ExternalExpression.fromJS = function (parameters) {
        var value = {
            op: parameters.op
        };
        value.external = External.fromJS(parameters.external);
        return new ExternalExpression(value);
    };
    ExternalExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.external = this.external;
        return value;
    };
    ExternalExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.external = this.external.toJS();
        return js;
    };
    ExternalExpression.prototype.toString = function () {
        return "E:" + this.external;
    };
    ExternalExpression.prototype.getFn = function () {
        throw new Error('should not call getFn on External');
    };
    ExternalExpression.prototype.getJS = function (datumVar) {
        throw new Error('should not call getJS on External');
    };
    ExternalExpression.prototype.getSQL = function (dialect) {
        throw new Error('should not call getSQL on External');
    };
    ExternalExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.external.equals(other.external);
    };
    ExternalExpression.prototype._fillRefSubstitutions = function (typeContext, indexer, alterations) {
        indexer.index++;
        var external = this.external;
        if (external.mode === 'value') {
            return { type: 'NUMBER' };
        }
        else {
            var newTypeContext = this.external.getFullType();
            newTypeContext.parent = typeContext;
            return newTypeContext;
        }
    };
    ExternalExpression.prototype._computeResolvedSimulate = function (lastNode, simulatedQueries) {
        var external = this.external;
        if (external.suppress)
            return external;
        return external.simulateValue(lastNode, simulatedQueries);
    };
    ExternalExpression.prototype._computeResolved = function (lastNode) {
        var external = this.external;
        if (external.suppress)
            return Q(external);
        return external.queryValue(lastNode);
    };
    ExternalExpression.prototype.unsuppress = function () {
        var value = this.valueOf();
        value.external = this.external.show();
        return new ExternalExpression(value);
    };
    ExternalExpression.prototype.addAction = function (action) {
        var newExternal = this.external.addAction(action);
        if (!newExternal)
            return null;
        return new ExternalExpression({ external: newExternal });
    };
    ExternalExpression.prototype.maxPossibleSplitValues = function () {
        return Infinity;
    };
    return ExternalExpression;
}(Expression));
Expression.register(ExternalExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};







var ChainExpression = exports.ChainExpression = (function (_super) {
    __extends(ChainExpression, _super);
    function ChainExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        var expression = parameters.expression;
        var actions = parameters.actions;
        if (!actions.length)
            throw new Error('can not have empty actions');
        this._ensureOp('chain');
        var type = expression.type;
        for (var i = 0; i < actions.length; i++) {
            var action = actions[i];
            var upgradedAction = action.getUpgradedType(type);
            if (upgradedAction !== action) {
                actions = actions.slice();
                actions[i] = action = upgradedAction;
            }
            try {
                type = action.getOutputType(type);
            }
            catch (e) {
                var neededType = action.getNecessaryInputTypes();
                if (i === 0) {
                    expression = expression.upgradeToType(neededType);
                    type = expression.type;
                }
                else {
                    var upgradedChain = new ChainExpression({
                        expression: expression,
                        actions: actions.slice(0, i)
                    }).upgradeToType(neededType);
                    expression = upgradedChain.expression;
                    actions = upgradedChain.actions;
                    type = upgradedChain.type;
                }
                type = action.getOutputType(type);
            }
        }
        this.expression = expression;
        this.actions = actions;
        this.type = type;
    }
    ChainExpression.fromJS = function (parameters) {
        var value = {
            op: parameters.op
        };
        value.expression = Expression.fromJS(parameters.expression);
        if (hasOwnProperty(parameters, 'action')) {
            value.actions = [Action.fromJS(parameters.action)];
        }
        else {
            if (!Array.isArray(parameters.actions))
                throw new Error('chain `actions` must be an array');
            value.actions = parameters.actions.map(Action.fromJS);
        }
        return new ChainExpression(value);
    };
    ChainExpression.prototype.upgradeToType = function (neededType) {
        var actions = this.actions;
        var upgradedActions = [];
        for (var i = actions.length - 1; i >= 0; i--) {
            var action = actions[i];
            var upgradedAction = action.getUpgradedType(neededType);
            upgradedActions.unshift(upgradedAction);
            neededType = upgradedAction.getNeededType();
        }
        var value = this.valueOf();
        value.actions = upgradedActions;
        value.expression = this.expression.upgradeToType(neededType);
        return new ChainExpression(value);
    };
    ChainExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.expression = this.expression;
        value.actions = this.actions;
        return value;
    };
    ChainExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.expression = this.expression.toJS();
        var actions = this.actions;
        if (actions.length === 1) {
            js.action = actions[0].toJS();
        }
        else {
            js.actions = actions.map(function (action) { return action.toJS(); });
        }
        return js;
    };
    ChainExpression.prototype.toString = function (indent) {
        var expression = this.expression;
        var actions = this.actions;
        var joinStr = '.';
        var nextIndent = null;
        if (indent != null && (actions.length > 1 || expression.type === 'DATASET')) {
            joinStr = '\n' + repeat(' ', indent) + joinStr;
            nextIndent = indent + 2;
        }
        return [expression.toString()]
            .concat(actions.map(function (action) { return action.toString(nextIndent); }))
            .join(joinStr);
    };
    ChainExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.expression.equals(other.expression) &&
            immutableArraysEqual(this.actions, other.actions);
    };
    ChainExpression.prototype.expressionCount = function () {
        var expressionCount = 1 + this.expression.expressionCount();
        var actions = this.actions;
        for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
            var action = actions_1[_i];
            expressionCount += action.expressionCount();
        }
        return expressionCount;
    };
    ChainExpression.prototype.getFn = function () {
        var _a = this, expression = _a.expression, actions = _a.actions;
        var fn = expression.getFn();
        var type = expression.type;
        for (var _i = 0, actions_2 = actions; _i < actions_2.length; _i++) {
            var action = actions_2[_i];
            fn = action.getFn(type, fn);
            type = action.getOutputType(type);
        }
        return fn;
    };
    ChainExpression.prototype.getJS = function (datumVar) {
        var _a = this, expression = _a.expression, actions = _a.actions;
        var js = expression.getJS(datumVar);
        var type = expression.type;
        for (var _i = 0, actions_3 = actions; _i < actions_3.length; _i++) {
            var action = actions_3[_i];
            js = action.getJS(type, js, datumVar);
            type = action.getOutputType(type);
        }
        return js;
    };
    ChainExpression.prototype.getSQL = function (dialect) {
        var _a = this, expression = _a.expression, actions = _a.actions;
        var sql = expression.getSQL(dialect);
        var type = expression.type;
        for (var _i = 0, actions_4 = actions; _i < actions_4.length; _i++) {
            var action = actions_4[_i];
            sql = action.getSQL(type, sql, dialect);
            type = action.getOutputType(type);
        }
        return sql;
    };
    ChainExpression.prototype.getSingleAction = function (neededAction) {
        var actions = this.actions;
        if (actions.length !== 1)
            return null;
        var singleAction = actions[0];
        if (neededAction && singleAction.action !== neededAction)
            return null;
        return singleAction;
    };
    ChainExpression.prototype.foldIntoExternal = function () {
        var _a = this, expression = _a.expression, actions = _a.actions;
        var baseExternals = this.getBaseExternals();
        if (baseExternals.length === 0)
            return this;
        if (expression instanceof ExternalExpression) {
            var myExternal = expression;
            var undigestedActions = [];
            for (var _i = 0, actions_5 = actions; _i < actions_5.length; _i++) {
                var action = actions_5[_i];
                var newExternal = myExternal.addAction(action);
                if (newExternal) {
                    myExternal = newExternal;
                }
                else {
                    undigestedActions.push(action);
                }
            }
            if (undigestedActions.length) {
                return new ChainExpression({
                    expression: myExternal,
                    actions: undigestedActions,
                    simple: true
                });
            }
            else {
                return myExternal;
            }
        }
        var dataset = expression.getLiteralValue();
        if (Dataset.isDataset(dataset) && dataset.basis()) {
            if (baseExternals.length > 1) {
                throw new Error('multiple externals not supported for now');
            }
            var dataDefinitions = Object.create(null);
            var hasExternalValueApply = false;
            var applies = [];
            var undigestedActions = [];
            var allActions = [];
            for (var _b = 0, actions_6 = actions; _b < actions_6.length; _b++) {
                var action_1 = actions_6[_b];
                if (action_1 instanceof ApplyAction) {
                    var substitutedAction = action_1.substitute(function (ex, index, depth, nestDiff) {
                        if (ex instanceof RefExpression && ex.type === 'DATASET' && nestDiff === 1) {
                            return dataDefinitions[ex.name] || null;
                        }
                        return null;
                    }).simplify();
                    if (substitutedAction.expression instanceof ExternalExpression) {
                        var externalMode = substitutedAction.expression.external.mode;
                        if (externalMode === 'raw') {
                            dataDefinitions[substitutedAction.name] = substitutedAction.expression;
                        }
                        else if (externalMode === 'value') {
                            applies.push(substitutedAction);
                            allActions.push(substitutedAction);
                            hasExternalValueApply = true;
                        }
                        else {
                            undigestedActions.push(substitutedAction);
                            allActions.push(substitutedAction);
                        }
                    }
                    else if (substitutedAction.expression.type !== 'DATASET') {
                        applies.push(substitutedAction);
                        allActions.push(substitutedAction);
                    }
                    else {
                        undigestedActions.push(substitutedAction);
                        allActions.push(substitutedAction);
                    }
                }
                else {
                    undigestedActions.push(action_1);
                    allActions.push(action_1);
                }
            }
            var newExpression;
            if (hasExternalValueApply) {
                var combinedExternal = baseExternals[0].makeTotal(applies);
                if (!combinedExternal)
                    throw new Error('something went wrong');
                newExpression = new ExternalExpression({ external: combinedExternal });
                if (undigestedActions.length)
                    newExpression = newExpression.performActions(undigestedActions, true);
                return newExpression;
            }
            else {
                return ply().performActions(allActions);
            }
        }
        return this.substituteAction(function (action) {
            var expression = action.expression;
            return (expression instanceof ExternalExpression) && expression.external.mode === 'value';
        }, function (preEx, action) {
            var external = action.expression.external;
            return new ExternalExpression({
                external: external.prePack(preEx, action)
            });
        }, {
            onceInChain: true
        }).simplify();
    };
    ChainExpression.prototype.simplify = function () {
        if (this.simple)
            return this;
        var simpleExpression = this.expression.simplify();
        var actions = this.actions;
        if (simpleExpression instanceof ChainExpression) {
            return new ChainExpression({
                expression: simpleExpression.expression,
                actions: simpleExpression.actions.concat(actions)
            }).simplify();
        }
        for (var _i = 0, actions_7 = actions; _i < actions_7.length; _i++) {
            var action = actions_7[_i];
            simpleExpression = action.performOnSimple(simpleExpression);
        }
        if (!simpleExpression.isOp('chain'))
            return simpleExpression;
        return simpleExpression.foldIntoExternal();
    };
    ChainExpression.prototype._everyHelper = function (iter, thisArg, indexer, depth, nestDiff) {
        var pass = iter.call(thisArg, this, indexer.index, depth, nestDiff);
        if (pass != null) {
            return pass;
        }
        else {
            indexer.index++;
        }
        depth++;
        var expression = this.expression;
        if (!expression._everyHelper(iter, thisArg, indexer, depth, nestDiff))
            return false;
        var actions = this.actions;
        var every = true;
        for (var _i = 0, actions_8 = actions; _i < actions_8.length; _i++) {
            var action = actions_8[_i];
            if (every) {
                every = action._everyHelper(iter, thisArg, indexer, depth, nestDiff);
            }
            else {
                indexer.index += action.expressionCount();
            }
        }
        return every;
    };
    ChainExpression.prototype._substituteHelper = function (substitutionFn, thisArg, indexer, depth, nestDiff) {
        var sub = substitutionFn.call(thisArg, this, indexer.index, depth, nestDiff);
        if (sub) {
            indexer.index += this.expressionCount();
            return sub;
        }
        else {
            indexer.index++;
        }
        depth++;
        var expression = this.expression;
        var subExpression = expression._substituteHelper(substitutionFn, thisArg, indexer, depth, nestDiff);
        var actions = this.actions;
        var subActions = actions.map(function (action) { return action._substituteHelper(substitutionFn, thisArg, indexer, depth, nestDiff); });
        if (expression === subExpression && arraysEqual(actions, subActions))
            return this;
        var value = this.valueOf();
        value.expression = subExpression;
        value.actions = subActions;
        delete value.simple;
        return new ChainExpression(value);
    };
    ChainExpression.prototype.performAction = function (action, markSimple) {
        if (!action)
            throw new Error('must have action');
        return new ChainExpression({
            expression: this.expression,
            actions: this.actions.concat(action),
            simple: Boolean(markSimple)
        });
    };
    ChainExpression.prototype._fillRefSubstitutions = function (typeContext, indexer, alterations) {
        indexer.index++;
        var currentContext = typeContext;
        var outputContext = this.expression._fillRefSubstitutions(currentContext, indexer, alterations);
        currentContext = outputContext.type === 'DATASET' ? outputContext : typeContext;
        var actions = this.actions;
        for (var _i = 0, actions_9 = actions; _i < actions_9.length; _i++) {
            var action = actions_9[_i];
            outputContext = action._fillRefSubstitutions(currentContext, outputContext, indexer, alterations);
            currentContext = outputContext.type === 'DATASET' ? outputContext : typeContext;
        }
        return outputContext;
    };
    ChainExpression.prototype.actionize = function (containingAction) {
        var actions = this.actions;
        var k = actions.length - 1;
        for (; k >= 0; k--) {
            if (actions[k].action !== containingAction)
                break;
        }
        k++;
        if (k === actions.length)
            return null;
        var newExpression;
        if (k === 0) {
            newExpression = this.expression;
        }
        else {
            var value = this.valueOf();
            value.actions = actions.slice(0, k);
            newExpression = new ChainExpression(value);
        }
        var ActionConstructor = Action.classMap[containingAction];
        return [
            new ActionConstructor({
                expression: newExpression
            })
        ].concat(actions.slice(k));
    };
    ChainExpression.prototype.firstAction = function () {
        return this.actions[0] || null;
    };
    ChainExpression.prototype.lastAction = function () {
        var actions = this.actions;
        return actions[actions.length - 1] || null;
    };
    ChainExpression.prototype.headActions = function (n) {
        var actions = this.actions;
        if (actions.length <= n)
            return this;
        if (n <= 0)
            return this.expression;
        var value = this.valueOf();
        value.actions = actions.slice(0, n);
        return new ChainExpression(value);
    };
    ChainExpression.prototype.popAction = function () {
        var actions = this.actions;
        if (!actions.length)
            return null;
        actions = actions.slice(0, -1);
        if (!actions.length)
            return this.expression;
        var value = this.valueOf();
        value.actions = actions;
        return new ChainExpression(value);
    };
    ChainExpression.prototype._computeResolvedSimulate = function (lastNode, simulatedQueries) {
        var _a = this, expression = _a.expression, actions = _a.actions;
        if (expression.isOp('external')) {
            var exV = expression._computeResolvedSimulate(false, simulatedQueries);
            var newExpression = r(exV).performActions(actions).simplify();
            if (newExpression.hasExternal()) {
                return newExpression._computeResolvedSimulate(true, simulatedQueries);
            }
            else {
                return newExpression.getFn()(null, null);
            }
        }
        function execAction(i, dataset) {
            var action = actions[i];
            var actionExpression = action.expression;
            if (action instanceof FilterAction) {
                return dataset.filter(actionExpression.getFn(), null);
            }
            else if (action instanceof ApplyAction) {
                if (actionExpression.hasExternal()) {
                    return dataset.apply(action.name, function (d) {
                        var simpleExpression = actionExpression.resolve(d).simplify();
                        return simpleExpression._computeResolvedSimulate(simpleExpression.isOp('external'), simulatedQueries);
                    }, actionExpression.type, null);
                }
                else {
                    return dataset.apply(action.name, actionExpression.getFn(), actionExpression.type, null);
                }
            }
            else if (action instanceof SortAction) {
                return dataset.sort(actionExpression.getFn(), action.direction, null);
            }
            else if (action instanceof LimitAction) {
                return dataset.limit(action.limit);
            }
            else if (action instanceof SelectAction) {
                return dataset.select(action.attributes);
            }
            throw new Error("could not execute action " + action);
        }
        var value = expression._computeResolvedSimulate(false, simulatedQueries);
        for (var i = 0; i < actions.length; i++) {
            value = execAction(i, value);
        }
        return value;
    };
    ChainExpression.prototype._computeResolved = function () {
        var _a = this, expression = _a.expression, actions = _a.actions;
        if (expression.isOp('external')) {
            return expression._computeResolved(false).then(function (exV) {
                var newExpression = r(exV).performActions(actions).simplify();
                if (newExpression.hasExternal()) {
                    return newExpression._computeResolved(true);
                }
                else {
                    return newExpression.getFn()(null, null);
                }
            });
        }
        function execAction(i) {
            return function (dataset) {
                var action = actions[i];
                var actionExpression = action.expression;
                if (action instanceof FilterAction) {
                    return dataset.filter(actionExpression.getFn(), null);
                }
                else if (action instanceof ApplyAction) {
                    if (actionExpression.hasExternal()) {
                        return dataset.applyPromise(action.name, function (d) {
                            var simpleExpression = actionExpression.resolve(d).simplify();
                            return simpleExpression._computeResolved(simpleExpression.isOp('external'));
                        }, actionExpression.type, null);
                    }
                    else {
                        return dataset.apply(action.name, actionExpression.getFn(), actionExpression.type, null);
                    }
                }
                else if (action instanceof SortAction) {
                    return dataset.sort(actionExpression.getFn(), action.direction, null);
                }
                else if (action instanceof LimitAction) {
                    return dataset.limit(action.limit);
                }
                else if (action instanceof SelectAction) {
                    return dataset.select(action.attributes);
                }
                throw new Error("could not execute action " + action);
            };
        }
        var promise = expression._computeResolved(false);
        for (var i = 0; i < actions.length; i++) {
            promise = promise.then(execAction(i));
        }
        return promise;
    };
    ChainExpression.prototype.extractFromAnd = function (matchFn) {
        if (!this.simple)
            return this.simplify().extractFromAnd(matchFn);
        var andExpressions = this.getExpressionPattern('and');
        if (!andExpressions)
            return _super.prototype.extractFromAnd.call(this, matchFn);
        var includedExpressions = [];
        var excludedExpressions = [];
        for (var _i = 0, andExpressions_1 = andExpressions; _i < andExpressions_1.length; _i++) {
            var ex = andExpressions_1[_i];
            if (matchFn(ex)) {
                includedExpressions.push(ex);
            }
            else {
                excludedExpressions.push(ex);
            }
        }
        return {
            extract: Expression.and(includedExpressions).simplify(),
            rest: Expression.and(excludedExpressions).simplify()
        };
    };
    ChainExpression.prototype.maxPossibleSplitValues = function () {
        return this.type === 'BOOLEAN' ? 3 : this.lastAction().maxPossibleSplitValues();
    };
    return ChainExpression;
}(Expression));
Expression.register(ChainExpression);








var Action = exports.Action = (function () {
    function Action(parameters, dummy) {
        if (dummy === void 0) { dummy = null; }
        this._stringTransformInputType = ['STRING', 'SET/STRING'];
        if (dummy !== dummyObject) {
            throw new TypeError("can not call `new Action` directly use Action.fromJS instead");
        }
        this.action = parameters.action;
        this.expression = parameters.expression;
        this.simple = parameters.simple;
    }
    Action.jsToValue = function (parameters) {
        var value = {
            action: parameters.action
        };
        if (parameters.expression) {
            value.expression = Expression.fromJS(parameters.expression);
        }
        return value;
    };
    Action.actionsDependOn = function (actions, name) {
        for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
            var action = actions_1[_i];
            var freeReferences = action.getFreeReferences();
            if (freeReferences.indexOf(name) !== -1)
                return true;
            if (action.name === name)
                return false;
        }
        return false;
    };
    Action.isAction = function (candidate) {
        return isInstanceOf(candidate, Action);
    };
    Action.register = function (act) {
        var action = act.name.replace('Action', '').replace(/^\w/, function (s) { return s.toLowerCase(); });
        Action.classMap[action] = act;
    };
    Action.fromJS = function (actionJS) {
        if (!hasOwnProperty(actionJS, "action")) {
            throw new Error("action must be defined");
        }
        var action = actionJS.action;
        if (typeof action !== "string") {
            throw new Error("action must be a string");
        }
        if (action === 'custom')
            actionJS.action = action = 'customAggregate';
        var ClassFn = Action.classMap[action];
        if (!ClassFn) {
            throw new Error("unsupported action '" + action + "'");
        }
        return ClassFn.fromJS(actionJS);
    };
    Action.fromValue = function (value) {
        var ClassFn = Action.classMap[value.action];
        return new ClassFn(value);
    };
    Action.prototype._ensureAction = function (action) {
        if (!this.action) {
            this.action = action;
            return;
        }
        if (this.action !== action) {
            throw new TypeError("incorrect action '" + this.action + "' (needs to be: '" + action + "')");
        }
    };
    Action.prototype._toStringParameters = function (expressionString) {
        return expressionString ? [expressionString] : [];
    };
    Action.prototype.toString = function (indent) {
        var expression = this.expression;
        var spacer = '';
        var joinStr = indent != null ? ', ' : ',';
        var nextIndent = null;
        if (indent != null && expression && expression.type === 'DATASET') {
            var space = repeat(' ', indent);
            spacer = '\n' + space;
            joinStr = ',\n' + space;
            nextIndent = indent + 2;
        }
        return [
            this.action,
            '(',
            spacer,
            this._toStringParameters(expression ? expression.toString(nextIndent) : null).join(joinStr),
            spacer,
            ')'
        ].join('');
    };
    Action.prototype.valueOf = function () {
        var value = {
            action: this.action
        };
        if (this.expression)
            value.expression = this.expression;
        if (this.simple)
            value.simple = true;
        return value;
    };
    Action.prototype.toJS = function () {
        var js = {
            action: this.action
        };
        if (this.expression) {
            js.expression = this.expression.toJS();
        }
        return js;
    };
    Action.prototype.toJSON = function () {
        return this.toJS();
    };
    Action.prototype.equals = function (other) {
        return Action.isAction(other) &&
            this.action === other.action &&
            Boolean(this.expression) === Boolean(other.expression) &&
            (!this.expression || this.expression.equals(other.expression));
    };
    Action.prototype.isAggregate = function () {
        return false;
    };
    Action.prototype._checkInputTypes = function (inputType) {
        var neededTypes = this.getNecessaryInputTypes();
        if (typeof neededTypes === 'string')
            neededTypes = [neededTypes];
        if (inputType && inputType !== 'NULL' && neededTypes.indexOf(inputType) === -1) {
            if (neededTypes.length === 1) {
                throw new Error(this.action + " must have input of type " + neededTypes[0] + " (is " + inputType + ")");
            }
            else {
                throw new Error(this.action + " must have input of type " + neededTypes.join(' or ') + " (is " + inputType + ")");
            }
        }
    };
    Action.prototype._checkNoExpression = function () {
        if (this.expression) {
            throw new Error(this.action + " must no have an expression (is " + this.expression + ")");
        }
    };
    Action.prototype._checkExpressionTypes = function () {
        var neededTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            neededTypes[_i - 0] = arguments[_i];
        }
        var expressionType = this.expression.type;
        if (expressionType && expressionType !== 'NULL' && neededTypes.indexOf(expressionType) === -1) {
            if (neededTypes.length === 1) {
                throw new Error(this.action + " must have expression of type " + neededTypes[0] + " (is " + expressionType + ")");
            }
            else {
                throw new Error(this.action + " must have expression of type " + neededTypes.join(' or ') + " (is " + expressionType + ")");
            }
        }
    };
    Action.prototype._stringTransformOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return inputType;
    };
    Action.prototype.getNeededType = function () {
        var expression = this.expression;
        if (expression)
            return expression.type;
        return null;
    };
    Action.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        var action = this.action;
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV[action](expressionFn, foldContext(d, c)) : null;
        };
    };
    Action.prototype.getFn = function (inputType, inputFn) {
        var expression = this.expression;
        var expressionFn = expression ? expression.getFn() : null;
        return this._getFnHelper(inputType, inputFn, expressionFn);
    };
    Action.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        throw new Error('can not call this directly');
    };
    Action.prototype.getJS = function (inputType, inputJS, datumVar) {
        var expression = this.expression;
        var expressionJS = expression ? expression.getJS(datumVar) : null;
        return this._getJSHelper(inputType, inputJS, expressionJS);
    };
    Action.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        throw new Error('can not call this directly');
    };
    Action.prototype.getSQL = function (inputType, inputSQL, dialect) {
        var expression = this.expression;
        var expressionSQL = expression ? expression.getSQL(dialect) : null;
        return this._getSQLHelper(inputType, dialect, inputSQL, expressionSQL);
    };
    Action.prototype.expressionCount = function () {
        return this.expression ? this.expression.expressionCount() : 0;
    };
    Action.prototype.fullyDefined = function () {
        var expression = this.expression;
        return !expression || expression.isOp('literal');
    };
    Action.prototype._specialSimplify = function (simpleExpression) {
        return null;
    };
    Action.prototype.simplify = function () {
        if (this.simple)
            return this;
        var expression = this.expression;
        var simpleExpression = expression ? expression.simplify() : null;
        var special = this._specialSimplify(simpleExpression);
        if (special)
            return special;
        var value = this.valueOf();
        if (simpleExpression) {
            value.expression = simpleExpression;
        }
        value.simple = true;
        return Action.fromValue(value);
    };
    Action.prototype._removeAction = function (inputType) {
        return false;
    };
    Action.prototype._nukeExpression = function (precedingExpression) {
        return null;
    };
    Action.prototype._distributeAction = function () {
        return null;
    };
    Action.prototype._performOnLiteral = function (literalExpression) {
        return null;
    };
    Action.prototype._performOnRef = function (refExpression) {
        return null;
    };
    Action.prototype._foldWithPrevAction = function (prevAction) {
        return null;
    };
    Action.prototype._putBeforeLastAction = function (lastAction) {
        return null;
    };
    Action.prototype._performOnSimpleChain = function (chainExpression) {
        return null;
    };
    Action.prototype.performOnSimple = function (simpleExpression) {
        if (!this.simple)
            return this.simplify().performOnSimple(simpleExpression);
        if (!simpleExpression.simple)
            throw new Error('must get a simple expression');
        if (this._removeAction(simpleExpression.type))
            return simpleExpression;
        var nukedExpression = this._nukeExpression(simpleExpression);
        if (nukedExpression)
            return nukedExpression;
        var distributedActions = this._distributeAction();
        if (distributedActions) {
            for (var _i = 0, distributedActions_1 = distributedActions; _i < distributedActions_1.length; _i++) {
                var distributedAction = distributedActions_1[_i];
                simpleExpression = distributedAction.performOnSimple(simpleExpression);
            }
            return simpleExpression;
        }
        if (simpleExpression instanceof LiteralExpression) {
            if (this.fullyDefined()) {
                return new LiteralExpression({
                    value: this.getFn(simpleExpression.type, simpleExpression.getFn())(null, null)
                });
            }
            var special = this._performOnLiteral(simpleExpression);
            if (special)
                return special;
        }
        else if (simpleExpression instanceof RefExpression) {
            var special = this._performOnRef(simpleExpression);
            if (special)
                return special;
        }
        else if (simpleExpression instanceof ChainExpression) {
            var actions = simpleExpression.actions;
            var lastAction = actions[actions.length - 1];
            var foldedAction = this._foldWithPrevAction(lastAction);
            if (foldedAction) {
                return foldedAction.performOnSimple(simpleExpression.popAction());
            }
            var beforeAction = this._putBeforeLastAction(lastAction);
            if (beforeAction) {
                return lastAction.performOnSimple(beforeAction.performOnSimple(simpleExpression.popAction()));
            }
            var special = this._performOnSimpleChain(simpleExpression);
            if (special)
                return special;
        }
        return simpleExpression.performAction(this, true);
    };
    Action.prototype.getExpressions = function () {
        return this.expression ? [this.expression] : [];
    };
    Action.prototype.getFreeReferences = function () {
        var freeReferences = [];
        this.getExpressions().forEach(function (ex) {
            freeReferences = freeReferences.concat(ex.getFreeReferences());
        });
        return deduplicateSort(freeReferences);
    };
    Action.prototype._everyHelper = function (iter, thisArg, indexer, depth, nestDiff) {
        var nestDiffNext = nestDiff + Number(this.isNester());
        return this.getExpressions().every(function (ex) { return ex._everyHelper(iter, thisArg, indexer, depth, nestDiffNext); });
    };
    Action.prototype.substitute = function (substitutionFn, thisArg) {
        return this._substituteHelper(substitutionFn, thisArg, { index: 0 }, 0, 0);
    };
    Action.prototype._substituteHelper = function (substitutionFn, thisArg, indexer, depth, nestDiff) {
        var expression = this.expression;
        if (!expression)
            return this;
        var subExpression = expression._substituteHelper(substitutionFn, thisArg, indexer, depth, nestDiff + Number(this.isNester()));
        if (expression === subExpression)
            return this;
        var value = this.valueOf();
        value.simple = false;
        value.expression = subExpression;
        return Action.fromValue(value);
    };
    Action.prototype.canDistribute = function () {
        return false;
    };
    Action.prototype.distribute = function (preEx) {
        return null;
    };
    Action.prototype.changeExpression = function (newExpression) {
        var expression = this.expression;
        if (!expression || expression.equals(newExpression))
            return this;
        var value = this.valueOf();
        value.expression = newExpression;
        return Action.fromValue(value);
    };
    Action.prototype.isNester = function () {
        return false;
    };
    Action.prototype.getLiteralValue = function () {
        var expression = this.expression;
        if (expression instanceof LiteralExpression) {
            return expression.value;
        }
        return null;
    };
    Action.prototype.maxPossibleSplitValues = function () {
        return Infinity;
    };
    Action.prototype.getUpgradedType = function (type) {
        return this;
    };
    Action.prototype.needsEnvironment = function () {
        return false;
    };
    Action.prototype.defineEnvironment = function (environment) {
        return this;
    };
    Action.prototype.getTimezone = function () {
        return Timezone.UTC;
    };
    Action.prototype.alignsWith = function (actions) {
        return true;
    };
    Action.classMap = {};
    return Action;
}());
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var AbsoluteAction = exports.AbsoluteAction = (function (_super) {
    __extends(AbsoluteAction, _super);
    function AbsoluteAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("absolute");
        this._checkNoExpression();
    }
    AbsoluteAction.fromJS = function (parameters) {
        return new AbsoluteAction(Action.jsToValue(parameters));
    };
    AbsoluteAction.prototype.getNecessaryInputTypes = function () {
        return 'NUMBER';
    };
    AbsoluteAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    AbsoluteAction.prototype._fillRefSubstitutions = function (typeContext, inputType) {
        return inputType;
    };
    AbsoluteAction.prototype._getFnHelper = function (inputType, inputFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            return Math.abs(inV);
        };
    };
    AbsoluteAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction.equals(this)) {
            return this;
        }
        return null;
    };
    AbsoluteAction.prototype._getJSHelper = function (inputType, inputJS) {
        return "Math.abs(" + inputJS + ")";
    };
    AbsoluteAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "ABS(" + inputSQL + ")";
    };
    return AbsoluteAction;
}(Action));
Action.register(AbsoluteAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var AddAction = exports.AddAction = (function (_super) {
    __extends(AddAction, _super);
    function AddAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("add");
        this._checkExpressionTypes('NUMBER');
    }
    AddAction.fromJS = function (parameters) {
        return new AddAction(Action.jsToValue(parameters));
    };
    AddAction.prototype.getNecessaryInputTypes = function () {
        return 'NUMBER';
    };
    AddAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    AddAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    AddAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return (inputFn(d, c) || 0) + (expressionFn(d, c) || 0);
        };
    };
    AddAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "+" + expressionJS + ")";
    };
    AddAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + "+" + expressionSQL + ")";
    };
    AddAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.ZERO);
    };
    AddAction.prototype._distributeAction = function () {
        return this.expression.actionize(this.action);
    };
    AddAction.prototype._performOnLiteral = function (literalExpression) {
        if (literalExpression.equals(Expression.ZERO)) {
            return this.expression;
        }
        return null;
    };
    AddAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction instanceof AddAction) {
            var prevValue = prevAction.expression.getLiteralValue();
            var myValue = this.expression.getLiteralValue();
            if (typeof prevValue === 'number' && typeof myValue === 'number') {
                return new AddAction({
                    expression: r(prevValue + myValue)
                });
            }
        }
        return null;
    };
    return AddAction;
}(Action));
Action.register(AddAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var IS_OR_IN_ACTION = {
    'is': true,
    'in': true
};
function mergeAnd(ex1, ex2) {
    if (!ex1.isOp('chain') ||
        !ex2.isOp('chain') ||
        !ex1.expression.isOp('ref') ||
        !ex2.expression.isOp('ref') ||
        !arraysEqual(ex1.getFreeReferences(), ex2.getFreeReferences()))
        return null;
    var ex1Actions = ex1.actions;
    var ex2Actions = ex2.actions;
    if (ex1Actions.length !== 1 || ex2Actions.length !== 1)
        return null;
    var ex1Action = ex1Actions[0];
    var ex2Action = ex2Actions[0];
    if (!IS_OR_IN_ACTION[ex1Action.action] || !IS_OR_IN_ACTION[ex2Action.action])
        return null;
    var firstActionExpression1 = ex1Action.expression;
    var firstActionExpression2 = ex2Action.expression;
    if (!firstActionExpression1 || !firstActionExpression2 || !firstActionExpression1.isOp('literal') || !firstActionExpression2.isOp('literal'))
        return null;
    var intersect = Set.generalIntersect(firstActionExpression1.getLiteralValue(), firstActionExpression2.getLiteralValue());
    if (intersect === null)
        return null;
    return Expression.inOrIs(ex1.expression, intersect);
}
var AndAction = exports.AndAction = (function (_super) {
    __extends(AndAction, _super);
    function AndAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("and");
    }
    AndAction.fromJS = function (parameters) {
        return new AndAction(Action.jsToValue(parameters));
    };
    AndAction.prototype.getNecessaryInputTypes = function () {
        return 'BOOLEAN';
    };
    AndAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    AndAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    AndAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) { return inputFn(d, c) && expressionFn(d, c); };
    };
    AndAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "&&" + expressionJS + ")";
    };
    AndAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + " AND " + expressionSQL + ")";
    };
    AndAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.TRUE);
    };
    AndAction.prototype._nukeExpression = function () {
        if (this.expression.equals(Expression.FALSE))
            return Expression.FALSE;
        return null;
    };
    AndAction.prototype._distributeAction = function () {
        return this.expression.actionize(this.action);
    };
    AndAction.prototype._performOnLiteral = function (literalExpression) {
        if (literalExpression.equals(Expression.TRUE)) {
            return this.expression;
        }
        if (literalExpression.equals(Expression.FALSE)) {
            return Expression.FALSE;
        }
        return null;
    };
    AndAction.prototype._performOnSimpleChain = function (chainExpression) {
        var expression = this.expression;
        var andExpressions = chainExpression.getExpressionPattern('and');
        if (andExpressions) {
            for (var i = 0; i < andExpressions.length; i++) {
                var andExpression = andExpressions[i];
                var mergedExpression = mergeAnd(andExpression, expression);
                if (mergedExpression) {
                    andExpressions[i] = mergedExpression;
                    return Expression.and(andExpressions).simplify();
                }
            }
        }
        return mergeAnd(chainExpression, expression);
    };
    return AndAction;
}(Action));
Action.register(AndAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var ApplyAction = exports.ApplyAction = (function (_super) {
    __extends(ApplyAction, _super);
    function ApplyAction(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this.name = parameters.name;
        this._ensureAction("apply");
    }
    ApplyAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.name = parameters.name;
        return new ApplyAction(value);
    };
    ApplyAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.name = this.name;
        return value;
    };
    ApplyAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.name = this.name;
        return js;
    };
    ApplyAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    ApplyAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'DATASET';
    };
    ApplyAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        typeContext.datasetType[this.name] = this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return typeContext;
    };
    ApplyAction.prototype._toStringParameters = function (expressionString) {
        var name = this.name;
        if (!RefExpression.SIMPLE_NAME_REGEXP.test(name))
            name = JSON.stringify(name);
        return [name, expressionString];
    };
    ApplyAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.name === other.name;
    };
    ApplyAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        var name = this.name;
        var type = this.expression.type;
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV.apply(name, expressionFn, type, foldContext(d, c)) : null;
        };
    };
    ApplyAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return expressionSQL + " AS " + dialect.escapeName(this.name);
    };
    ApplyAction.prototype.isSimpleAggregate = function () {
        var expression = this.expression;
        if (expression instanceof ChainExpression) {
            var actions = expression.actions;
            return actions.length === 1 && actions[0].isAggregate();
        }
        return false;
    };
    ApplyAction.prototype.isNester = function () {
        return true;
    };
    ApplyAction.prototype._removeAction = function () {
        var _a = this, name = _a.name, expression = _a.expression;
        if (expression instanceof RefExpression) {
            return expression.name === name && expression.nest === 0;
        }
        return false;
    };
    ApplyAction.prototype._putBeforeLastAction = function (lastAction) {
        if (this.isSimpleAggregate() &&
            lastAction instanceof ApplyAction &&
            !lastAction.isSimpleAggregate() &&
            this.expression.getFreeReferences().indexOf(lastAction.name) === -1) {
            return this;
        }
        return null;
    };
    return ApplyAction;
}(Action));
Action.register(ApplyAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var AverageAction = exports.AverageAction = (function (_super) {
    __extends(AverageAction, _super);
    function AverageAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("average");
        this._checkExpressionTypes('NUMBER');
    }
    AverageAction.fromJS = function (parameters) {
        return new AverageAction(Action.jsToValue(parameters));
    };
    AverageAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    AverageAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    AverageAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'NUMBER',
        };
    };
    AverageAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "AVG(" + dialect.aggregateFilterIfNeeded(inputSQL, expressionSQL) + ")";
    };
    AverageAction.prototype.isAggregate = function () {
        return true;
    };
    AverageAction.prototype.isNester = function () {
        return true;
    };
    return AverageAction;
}(Action));
Action.register(AverageAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var CardinalityAction = exports.CardinalityAction = (function (_super) {
    __extends(CardinalityAction, _super);
    function CardinalityAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("cardinality");
        this._checkNoExpression();
    }
    CardinalityAction.fromJS = function (parameters) {
        return new CardinalityAction(Action.jsToValue(parameters));
    };
    CardinalityAction.prototype.getNecessaryInputTypes = function () {
        return getAllSetTypes();
    };
    CardinalityAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    CardinalityAction.prototype._fillRefSubstitutions = function (typeContext, inputType) {
        return inputType;
    };
    CardinalityAction.prototype._getFnHelper = function (inputType, inputFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            if (Array.isArray(inV))
                return inV.length;
            return inV.cardinality();
        };
    };
    CardinalityAction.prototype._getJSHelper = function (inputType, inputJS) {
        return Expression.jsNullSafetyUnary(inputJS, function (input) { return (input + ".length"); });
    };
    CardinalityAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "cardinality(" + inputSQL + ")";
    };
    return CardinalityAction;
}(Action));
Action.register(CardinalityAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var CAST_TYPE_TO_FN = {
    TIME: {
        NUMBER: function (n) { return new Date(n); }
    },
    NUMBER: {
        TIME: function (n) { return Date.parse(n.toString()); },
        UNIVERSAL: function (s) { return Number(s); }
    },
    STRING: {
        UNIVERSAL: function (v) { return '' + v; }
    }
};
var CAST_TYPE_TO_JS = {
    TIME: {
        NUMBER: function (inputJS) { return ("new Date(" + inputJS + ")"); }
    },
    NUMBER: {
        UNIVERSAL: function (s) { return ("+(" + s + ")"); }
    },
    STRING: {
        UNIVERSAL: function (inputJS) { return ("('' + " + inputJS + ")"); }
    }
};
var CastAction = exports.CastAction = (function (_super) {
    __extends(CastAction, _super);
    function CastAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.outputType = parameters.outputType;
        this._ensureAction("cast");
        if (typeof this.outputType !== 'string') {
            throw new Error("`outputType` must be a string");
        }
    }
    CastAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        var outputType = parameters.outputType;
        if (!outputType && hasOwnProperty(parameters, 'castType')) {
            outputType = parameters.castType;
        }
        value.outputType = outputType;
        return new CastAction(value);
    };
    CastAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.outputType = this.outputType;
        return value;
    };
    CastAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.outputType = this.outputType;
        return js;
    };
    CastAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.outputType === other.outputType;
    };
    CastAction.prototype._toStringParameters = function (expressionString) {
        return [this.outputType];
    };
    CastAction.prototype.getNecessaryInputTypes = function () {
        var castType = this.outputType;
        return Object.keys(CAST_TYPE_TO_FN[castType]);
    };
    CastAction.prototype.getOutputType = function (inputType) {
        return this.outputType;
    };
    CastAction.prototype._fillRefSubstitutions = function () {
        var outputType = this.outputType;
        return {
            type: outputType
        };
    };
    CastAction.prototype._removeAction = function (inputType) {
        return this.outputType === inputType;
    };
    CastAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction.equals(this)) {
            return this;
        }
        return null;
    };
    CastAction.prototype._getFnHelper = function (inputType, inputFn) {
        var outputType = this.outputType;
        var caster = CAST_TYPE_TO_FN[outputType];
        var castFn = caster[inputType] || caster['UNIVERSAL'];
        if (!castFn)
            throw new Error("unsupported cast from " + inputType + " to '" + outputType + "'");
        return function (d, c) {
            var inV = inputFn(d, c);
            if (!inV)
                return null;
            return castFn(inV);
        };
    };
    CastAction.prototype._getJSHelper = function (inputType, inputJS) {
        var outputType = this.outputType;
        var castJS = CAST_TYPE_TO_JS[outputType];
        if (!castJS)
            throw new Error("unsupported cast type in getJS '" + outputType + "'");
        var js = castJS[inputType] || castJS['UNIVERSAL'];
        if (!js)
            throw new Error("unsupported combo in getJS of cast action: " + inputType + " to " + outputType);
        return js(inputJS);
    };
    CastAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.castExpression(inputType, inputSQL, this.outputType);
    };
    return CastAction;
}(Action));
Action.register(CastAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var ConcatAction = exports.ConcatAction = (function (_super) {
    __extends(ConcatAction, _super);
    function ConcatAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("concat");
        this._checkExpressionTypes('STRING');
    }
    ConcatAction.fromJS = function (parameters) {
        return new ConcatAction(Action.jsToValue(parameters));
    };
    ConcatAction.prototype.getNecessaryInputTypes = function () {
        return this._stringTransformInputType;
    };
    ConcatAction.prototype.getOutputType = function (inputType) {
        return this._stringTransformOutputType(inputType);
    };
    ConcatAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    ConcatAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            var exV = expressionFn(d, c);
            if (exV === null)
                return null;
            return '' + inV + exV;
        };
    };
    ConcatAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return Expression.jsNullSafetyBinary(inputJS, expressionJS, function (a, b) { return a + "+" + b; }, inputJS[0] === '"', expressionJS[0] === '"');
    };
    ConcatAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.concatExpression(inputSQL, expressionSQL);
    };
    ConcatAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.EMPTY_STRING);
    };
    ConcatAction.prototype._performOnLiteral = function (literalExpression) {
        if (literalExpression.equals(Expression.EMPTY_STRING)) {
            return this.expression;
        }
        return null;
    };
    ConcatAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction instanceof ConcatAction) {
            var prevValue = prevAction.expression.getLiteralValue();
            var myValue = this.expression.getLiteralValue();
            if (typeof prevValue === 'string' && typeof myValue === 'string') {
                return new ConcatAction({
                    expression: r(prevValue + myValue)
                });
            }
        }
        return null;
    };
    return ConcatAction;
}(Action));
Action.register(ConcatAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var ContainsAction = exports.ContainsAction = (function (_super) {
    __extends(ContainsAction, _super);
    function ContainsAction(parameters) {
        _super.call(this, parameters, dummyObject);
        var compare = parameters.compare;
        if (!compare) {
            compare = ContainsAction.NORMAL;
        }
        else if (compare !== ContainsAction.NORMAL && compare !== ContainsAction.IGNORE_CASE) {
            throw new Error("compare must be '" + ContainsAction.NORMAL + "' or '" + ContainsAction.IGNORE_CASE + "'");
        }
        this.compare = compare;
        this._ensureAction("contains");
        this._checkExpressionTypes('STRING');
    }
    ContainsAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.compare = parameters.compare;
        return new ContainsAction(value);
    };
    ContainsAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.compare = this.compare;
        return value;
    };
    ContainsAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.compare = this.compare;
        return js;
    };
    ContainsAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.compare === other.compare;
    };
    ContainsAction.prototype._toStringParameters = function (expressionString) {
        return [expressionString, this.compare];
    };
    ContainsAction.prototype.getNecessaryInputTypes = function () {
        return ['STRING', 'SET/STRING'];
    };
    ContainsAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    ContainsAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    ContainsAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        if (this.compare === ContainsAction.NORMAL) {
            return function (d, c) {
                return String(inputFn(d, c)).indexOf(expressionFn(d, c)) > -1;
            };
        }
        else {
            return function (d, c) {
                return String(inputFn(d, c)).toLowerCase().indexOf(String(expressionFn(d, c)).toLowerCase()) > -1;
            };
        }
    };
    ContainsAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        var combine;
        if (this.compare === ContainsAction.NORMAL) {
            combine = function (lhs, rhs) { return ("(''+" + lhs + ").indexOf(" + rhs + ")>-1"); };
        }
        else {
            combine = function (lhs, rhs) { return ("(''+" + lhs + ").toLowerCase().indexOf((''+" + rhs + ").toLowerCase())>-1"); };
        }
        return Expression.jsNullSafetyBinary(inputJS, expressionJS, combine, inputJS[0] === '"', expressionJS[0] === '"');
    };
    ContainsAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        if (this.compare === ContainsAction.IGNORE_CASE) {
            expressionSQL = "LOWER(" + expressionSQL + ")";
            inputSQL = "LOWER(" + inputSQL + ")";
        }
        return dialect.containsExpression(expressionSQL, inputSQL);
    };
    ContainsAction.prototype._performOnSimpleChain = function (chainExpression) {
        var expression = this.expression;
        if (expression instanceof ChainExpression) {
            var precedingAction = chainExpression.lastAction();
            var succeedingAction = expression.lastAction();
            if (precedingAction instanceof TransformCaseAction && succeedingAction instanceof TransformCaseAction) {
                if (precedingAction.transformType === succeedingAction.transformType) {
                    var precedingExpression = chainExpression.expression;
                    return precedingExpression.contains(expression.expression, ContainsAction.IGNORE_CASE).simplify();
                }
            }
        }
        return null;
    };
    ContainsAction.NORMAL = 'normal';
    ContainsAction.IGNORE_CASE = 'ignoreCase';
    return ContainsAction;
}(Action));
Action.register(ContainsAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var CountAction = exports.CountAction = (function (_super) {
    __extends(CountAction, _super);
    function CountAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("count");
        this._checkNoExpression();
    }
    CountAction.fromJS = function (parameters) {
        return new CountAction(Action.jsToValue(parameters));
    };
    CountAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    CountAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    CountAction.prototype._fillRefSubstitutions = function () {
        return {
            type: 'NUMBER',
        };
    };
    CountAction.prototype.getFn = function (inputType, inputFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV.count() : 0;
        };
    };
    CountAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return inputSQL.indexOf(' WHERE ') === -1 ? "COUNT(*)" : "SUM(" + dialect.aggregateFilterIfNeeded(inputSQL, '1') + ")";
    };
    CountAction.prototype.isAggregate = function () {
        return true;
    };
    return CountAction;
}(Action));
Action.register(CountAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var CountDistinctAction = exports.CountDistinctAction = (function (_super) {
    __extends(CountDistinctAction, _super);
    function CountDistinctAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("countDistinct");
    }
    CountDistinctAction.fromJS = function (parameters) {
        return new CountDistinctAction(Action.jsToValue(parameters));
    };
    CountDistinctAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    CountDistinctAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    CountDistinctAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'NUMBER',
        };
    };
    CountDistinctAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "COUNT(DISTINCT " + dialect.aggregateFilterIfNeeded(inputSQL, expressionSQL, 'NULL') + ")";
    };
    CountDistinctAction.prototype.isAggregate = function () {
        return true;
    };
    CountDistinctAction.prototype.isNester = function () {
        return true;
    };
    return CountDistinctAction;
}(Action));
Action.register(CountDistinctAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var CustomAggregateAction = exports.CustomAggregateAction = (function (_super) {
    __extends(CustomAggregateAction, _super);
    function CustomAggregateAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.custom = parameters.custom;
        this._ensureAction("customAggregate");
    }
    CustomAggregateAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.custom = parameters.custom;
        if (value.action === 'custom')
            value.action = 'customAggregate';
        return new CustomAggregateAction(value);
    };
    CustomAggregateAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.custom = this.custom;
        return value;
    };
    CustomAggregateAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.custom = this.custom;
        return js;
    };
    CustomAggregateAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.custom === other.custom;
    };
    CustomAggregateAction.prototype._toStringParameters = function (expressionString) {
        return [this.custom];
    };
    CustomAggregateAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    CustomAggregateAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    CustomAggregateAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        return {
            type: 'NUMBER',
        };
    };
    CustomAggregateAction.prototype.getFn = function (inputType, inputFn) {
        throw new Error('can not getFn on custom action');
    };
    CustomAggregateAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        throw new Error('custom action not implemented');
    };
    CustomAggregateAction.prototype.isAggregate = function () {
        return true;
    };
    return CustomAggregateAction;
}(Action));
Action.register(CustomAggregateAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var CustomTransformAction = exports.CustomTransformAction = (function (_super) {
    __extends(CustomTransformAction, _super);
    function CustomTransformAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.custom = parameters.custom;
        if (parameters.outputType)
            this.outputType = parameters.outputType;
        this._ensureAction("customTransform");
    }
    CustomTransformAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.custom = parameters.custom;
        if (parameters.outputType)
            value.outputType = parameters.outputType;
        return new CustomTransformAction(value);
    };
    CustomTransformAction.prototype.getNecessaryInputTypes = function () {
        return ['NULL', 'BOOLEAN', 'NUMBER', 'TIME', 'STRING'];
    };
    CustomTransformAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.custom = this.custom;
        if (this.outputType)
            value.outputType = this.outputType;
        return value;
    };
    CustomTransformAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.custom = this.custom;
        if (this.outputType)
            js.outputType = this.outputType;
        return js;
    };
    CustomTransformAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.custom === other.custom &&
            this.outputType === other.outputType;
    };
    CustomTransformAction.prototype._toStringParameters = function (expressionString) {
        var param = [(this.custom + " }")];
        if (this.outputType)
            param.push(this.outputType);
        return param;
    };
    CustomTransformAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return this.outputType || inputType;
    };
    CustomTransformAction.prototype._fillRefSubstitutions = function (typeContext, inputType) {
        return inputType;
    };
    CustomTransformAction.prototype.getFn = function (inputType, inputFn) {
        throw new Error('can not getFn on custom transform action');
    };
    CustomTransformAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        throw new Error("Custom transform not supported in SQL");
    };
    CustomTransformAction.prototype._getJSHelper = function (inputType, inputJS) {
        throw new Error("Custom transform can't yet be expressed as JS");
    };
    return CustomTransformAction;
}(Action));
Action.register(CustomTransformAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var DivideAction = exports.DivideAction = (function (_super) {
    __extends(DivideAction, _super);
    function DivideAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("divide");
        this._checkExpressionTypes('NUMBER');
    }
    DivideAction.fromJS = function (parameters) {
        return new DivideAction(Action.jsToValue(parameters));
    };
    DivideAction.prototype.getNecessaryInputTypes = function () {
        return 'NUMBER';
    };
    DivideAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    DivideAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    DivideAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            var v = (inputFn(d, c) || 0) / (expressionFn(d, c) || 0);
            return isNaN(v) ? null : v;
        };
    };
    DivideAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "/" + expressionJS + ")";
    };
    DivideAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + "/" + expressionSQL + ")";
    };
    DivideAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.ONE);
    };
    return DivideAction;
}(Action));
Action.register(DivideAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var ExtractAction = exports.ExtractAction = (function (_super) {
    __extends(ExtractAction, _super);
    function ExtractAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.regexp = parameters.regexp;
        this._ensureAction("extract");
    }
    ExtractAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.regexp = parameters.regexp;
        return new ExtractAction(value);
    };
    ExtractAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.regexp = this.regexp;
        return value;
    };
    ExtractAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.regexp = this.regexp;
        return js;
    };
    ExtractAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.regexp === other.regexp;
    };
    ExtractAction.prototype._toStringParameters = function (expressionString) {
        return [this.regexp];
    };
    ExtractAction.prototype.getNecessaryInputTypes = function () {
        return this._stringTransformInputType;
    };
    ExtractAction.prototype.getOutputType = function (inputType) {
        return this._stringTransformOutputType(inputType);
    };
    ExtractAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        return inputType;
    };
    ExtractAction.prototype._getFnHelper = function (inputType, inputFn) {
        var re = new RegExp(this.regexp);
        return function (d, c) {
            return (String(inputFn(d, c)).match(re) || [])[1] || null;
        };
    };
    ExtractAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "((''+" + inputJS + ").match(/" + this.regexp + "/) || [])[1] || null";
    };
    ExtractAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.extractExpression(inputSQL, this.regexp);
    };
    return ExtractAction;
}(Action));
Action.register(ExtractAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var FallbackAction = exports.FallbackAction = (function (_super) {
    __extends(FallbackAction, _super);
    function FallbackAction(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this._ensureAction("fallback");
    }
    FallbackAction.fromJS = function (parameters) {
        return new FallbackAction(Action.jsToValue(parameters));
    };
    FallbackAction.prototype.getNecessaryInputTypes = function () {
        return this.expression.type;
    };
    FallbackAction.prototype.getOutputType = function (inputType) {
        var expressionType = this.expression.type;
        if (expressionType && expressionType !== 'NULL')
            this._checkInputTypes(inputType);
        return expressionType;
    };
    FallbackAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    FallbackAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            var val = inputFn(d, c);
            if (val === null) {
                return expressionFn(d, c);
            }
            return val;
        };
    };
    FallbackAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(_ = " + inputJS + ", (_ === null ? " + expressionJS + " : _))";
    };
    FallbackAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "COALESCE(" + inputSQL + ", " + expressionSQL + ")";
    };
    FallbackAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.NULL);
    };
    return FallbackAction;
}(Action));
Action.register(FallbackAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






var FilterAction = exports.FilterAction = (function (_super) {
    __extends(FilterAction, _super);
    function FilterAction(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this._ensureAction("filter");
        this._checkExpressionTypes('BOOLEAN');
    }
    FilterAction.fromJS = function (parameters) {
        return new FilterAction({
            action: parameters.action,
            name: parameters.name,
            expression: Expression.fromJS(parameters.expression)
        });
    };
    FilterAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    FilterAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'DATASET';
    };
    FilterAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    FilterAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return inputSQL + " WHERE " + expressionSQL;
    };
    FilterAction.prototype.isNester = function () {
        return true;
    };
    FilterAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction instanceof FilterAction) {
            return new FilterAction({
                expression: prevAction.expression.and(this.expression)
            });
        }
        return null;
    };
    FilterAction.prototype._putBeforeLastAction = function (lastAction) {
        if (lastAction instanceof ApplyAction) {
            var freeReferences = this.getFreeReferences();
            return freeReferences.indexOf(lastAction.name) === -1 ? this : null;
        }
        if (lastAction instanceof SplitAction) {
            var splits = lastAction.splits;
            return new FilterAction({
                expression: this.expression.substitute(function (ex) {
                    if (ex instanceof RefExpression && splits[ex.name])
                        return splits[ex.name];
                    return null;
                })
            });
        }
        if (lastAction instanceof SortAction) {
            return this;
        }
        return null;
    };
    return FilterAction;
}(Action));
Action.register(FilterAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var GreaterThanAction = exports.GreaterThanAction = (function (_super) {
    __extends(GreaterThanAction, _super);
    function GreaterThanAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("greaterThan");
        this._checkExpressionTypes('NUMBER', 'TIME', 'STRING');
    }
    GreaterThanAction.fromJS = function (parameters) {
        return new GreaterThanAction(Action.jsToValue(parameters));
    };
    GreaterThanAction.prototype.getNecessaryInputTypes = function () {
        return this.expression.type;
    };
    GreaterThanAction.prototype.getOutputType = function (inputType) {
        var expressionType = this.expression.type;
        if (expressionType)
            this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    GreaterThanAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'BOOLEAN'
        };
    };
    GreaterThanAction.prototype.getUpgradedType = function (type) {
        return this.changeExpression(this.expression.upgradeToType(type));
    };
    GreaterThanAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return inputFn(d, c) > expressionFn(d, c);
        };
    };
    GreaterThanAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + ">" + expressionJS + ")";
    };
    GreaterThanAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + ">" + expressionSQL + ")";
    };
    GreaterThanAction.prototype._specialSimplify = function (simpleExpression) {
        if (simpleExpression instanceof LiteralExpression) {
            return new InAction({
                expression: new LiteralExpression({
                    value: Range.fromJS({ start: simpleExpression.value, end: null, bounds: '()' })
                })
            });
        }
        return null;
    };
    GreaterThanAction.prototype._performOnLiteral = function (literalExpression) {
        return (new InAction({
            expression: new LiteralExpression({
                value: Range.fromJS({ start: null, end: literalExpression.value, bounds: '()' })
            })
        })).performOnSimple(this.expression);
    };
    return GreaterThanAction;
}(Action));
Action.register(GreaterThanAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var GreaterThanOrEqualAction = exports.GreaterThanOrEqualAction = (function (_super) {
    __extends(GreaterThanOrEqualAction, _super);
    function GreaterThanOrEqualAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("greaterThanOrEqual");
        this._checkExpressionTypes('NUMBER', 'TIME', 'STRING');
    }
    GreaterThanOrEqualAction.fromJS = function (parameters) {
        return new GreaterThanOrEqualAction(Action.jsToValue(parameters));
    };
    GreaterThanOrEqualAction.prototype.getNecessaryInputTypes = function () {
        return this.expression.type;
    };
    GreaterThanOrEqualAction.prototype.getOutputType = function (inputType) {
        var expressionType = this.expression.type;
        if (expressionType)
            this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    GreaterThanOrEqualAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'BOOLEAN'
        };
    };
    GreaterThanOrEqualAction.prototype.getUpgradedType = function (type) {
        return this.changeExpression(this.expression.upgradeToType(type));
    };
    GreaterThanOrEqualAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return inputFn(d, c) >= expressionFn(d, c);
        };
    };
    GreaterThanOrEqualAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + ">=" + expressionJS + ")";
    };
    GreaterThanOrEqualAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + ">=" + expressionSQL + ")";
    };
    GreaterThanOrEqualAction.prototype._specialSimplify = function (simpleExpression) {
        if (simpleExpression instanceof LiteralExpression) {
            return new InAction({
                expression: new LiteralExpression({
                    value: Range.fromJS({ start: simpleExpression.value, end: null, bounds: '[)' })
                })
            });
        }
        return null;
    };
    GreaterThanOrEqualAction.prototype._performOnLiteral = function (literalExpression) {
        return (new InAction({
            expression: new LiteralExpression({
                value: Range.fromJS({ start: null, end: literalExpression.value, bounds: '(]' })
            })
        })).performOnSimple(this.expression);
    };
    return GreaterThanOrEqualAction;
}(Action));
Action.register(GreaterThanOrEqualAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};







var InAction = exports.InAction = (function (_super) {
    __extends(InAction, _super);
    function InAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("in");
    }
    InAction.fromJS = function (parameters) {
        return new InAction(Action.jsToValue(parameters));
    };
    InAction.prototype.getNecessaryInputTypes = function () {
        return this.expression.type;
    };
    InAction.prototype.getOutputType = function (inputType) {
        var expression = this.expression;
        if (inputType) {
            if (!((!isSetType(inputType) && expression.canHaveType('SET')) ||
                (inputType === 'NUMBER' && expression.canHaveType('NUMBER_RANGE')) ||
                (inputType === 'STRING' && expression.canHaveType('STRING_RANGE')) ||
                (inputType === 'TIME' && expression.canHaveType('TIME_RANGE')))) {
                throw new TypeError("in action has a bad type combination " + inputType + " IN " + (expression.type || '*'));
            }
        }
        else {
            if (!(expression.canHaveType('NUMBER_RANGE') || expression.canHaveType('STRING_RANGE') || expression.canHaveType('TIME_RANGE') || expression.canHaveType('SET'))) {
                throw new TypeError("in action has invalid expression type " + expression.type);
            }
        }
        return 'BOOLEAN';
    };
    InAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'BOOLEAN'
        };
    };
    InAction.prototype.getUpgradedType = function (type) {
        return this.changeExpression(this.expression.upgradeToType(type));
    };
    InAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            var exV = expressionFn(d, c);
            if (!exV)
                return null;
            return exV.contains(inV);
        };
    };
    InAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        var expression = this.expression;
        if (expression instanceof LiteralExpression) {
            switch (expression.type) {
                case 'NUMBER_RANGE':
                case 'STRING_RANGE':
                case 'TIME_RANGE':
                    var range = expression.value;
                    var r0 = range.start;
                    var r1 = range.end;
                    var bounds = range.bounds;
                    var cmpStrings = [];
                    if (r0 != null) {
                        cmpStrings.push(JSON.stringify(r0) + " " + (bounds[0] === '(' ? '<' : '<=') + " _");
                    }
                    if (r1 != null) {
                        cmpStrings.push("_ " + (bounds[1] === ')' ? '<' : '<=') + " " + JSON.stringify(r1));
                    }
                    return "(_=" + inputJS + ", " + cmpStrings.join(' && ') + ")";
                case 'SET/STRING':
                    var valueSet = expression.value;
                    return JSON.stringify(valueSet.elements) + ".indexOf(" + inputJS + ")>-1";
                default:
                    throw new Error("can not convert " + this + " to JS function, unsupported type " + expression.type);
            }
        }
        throw new Error("can not convert " + this + " to JS function");
    };
    InAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        var expression = this.expression;
        var expressionType = expression.type;
        switch (expressionType) {
            case 'NUMBER_RANGE':
            case 'TIME_RANGE':
                if (expression instanceof LiteralExpression) {
                    var range = expression.value;
                    return dialect.inExpression(inputSQL, dialect.numberOrTimeToSQL(range.start), dialect.numberOrTimeToSQL(range.end), range.bounds);
                }
                throw new Error("can not convert action to SQL " + this);
            case 'STRING_RANGE':
                if (expression instanceof LiteralExpression) {
                    var stringRange = expression.value;
                    return dialect.inExpression(inputSQL, dialect.escapeLiteral(stringRange.start), dialect.escapeLiteral(stringRange.end), stringRange.bounds);
                }
                throw new Error("can not convert action to SQL " + this);
            case 'SET/STRING':
            case 'SET/NUMBER':
                return inputSQL + " IN " + expressionSQL;
            case 'SET/NUMBER_RANGE':
            case 'SET/TIME_RANGE':
                if (expression instanceof LiteralExpression) {
                    var setOfRange = expression.value;
                    return setOfRange.elements.map(function (range) {
                        return dialect.inExpression(inputSQL, dialect.numberOrTimeToSQL(range.start), dialect.numberOrTimeToSQL(range.end), range.bounds);
                    }).join(' OR ');
                }
                throw new Error("can not convert action to SQL " + this);
            default:
                throw new Error("can not convert action to SQL " + this);
        }
    };
    InAction.prototype._nukeExpression = function () {
        var expression = this.expression;
        if (expression instanceof LiteralExpression &&
            isSetType(expression.type) &&
            expression.value.empty())
            return Expression.FALSE;
        return null;
    };
    InAction.prototype._performOnSimpleWhatever = function (ex) {
        var expression = this.expression;
        var setValue = expression.getLiteralValue();
        if (setValue && 'SET/' + ex.type === expression.type && setValue.size() === 1) {
            return new IsAction({ expression: r(setValue.elements[0]) }).performOnSimple(ex);
        }
        if (ex instanceof ChainExpression) {
            var indexOfAction = ex.getSingleAction('indexOf');
            var range = expression.getLiteralValue();
            if (indexOfAction && ((range.start < 0 && range.end === null) || (range.start === 0 && range.end === null && range.bounds[0] === '['))) {
                return new ContainsAction({ expression: indexOfAction.expression }).performOnSimple(ex.expression);
            }
        }
        return null;
    };
    InAction.prototype._performOnLiteral = function (literalExpression) {
        return this._performOnSimpleWhatever(literalExpression);
    };
    InAction.prototype._performOnRef = function (refExpression) {
        return this._performOnSimpleWhatever(refExpression);
    };
    InAction.prototype._performOnSimpleChain = function (chainExpression) {
        return this._performOnSimpleWhatever(chainExpression);
    };
    return InAction;
}(Action));
Action.register(InAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};









var IsAction = exports.IsAction = (function (_super) {
    __extends(IsAction, _super);
    function IsAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("is");
    }
    IsAction.fromJS = function (parameters) {
        return new IsAction(Action.jsToValue(parameters));
    };
    IsAction.prototype.getNecessaryInputTypes = function () {
        return this.expression.type;
    };
    IsAction.prototype.getOutputType = function (inputType) {
        var expressionType = this.expression.type;
        if (expressionType && expressionType !== 'NULL')
            this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    IsAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'BOOLEAN'
        };
    };
    IsAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return inputFn(d, c) === expressionFn(d, c);
        };
    };
    IsAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "===" + expressionJS + ")";
    };
    IsAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.isNotDistinctFromExpression(inputSQL, expressionSQL);
    };
    IsAction.prototype._nukeExpression = function (precedingExpression) {
        var prevAction = precedingExpression.lastAction();
        var literalValue = this.getLiteralValue();
        if (prevAction instanceof TimeBucketAction && literalValue instanceof TimeRange && prevAction.timezone) {
            if (literalValue.start !== null && TimeRange.timeBucket(literalValue.start, prevAction.duration, prevAction.timezone).equals(literalValue))
                return null;
            return Expression.FALSE;
        }
        if (prevAction instanceof NumberBucketAction && literalValue instanceof NumberRange) {
            if (literalValue.start !== null && NumberRange.numberBucket(literalValue.start, prevAction.size, prevAction.offset).equals(literalValue))
                return null;
            return Expression.FALSE;
        }
        return null;
    };
    IsAction.prototype._foldWithPrevAction = function (prevAction) {
        var literalValue = this.getLiteralValue();
        if (prevAction instanceof TimeBucketAction && literalValue instanceof TimeRange && prevAction.timezone) {
            if (!(literalValue.start !== null && TimeRange.timeBucket(literalValue.start, prevAction.duration, prevAction.timezone).equals(literalValue)))
                return null;
            return new InAction({ expression: this.expression });
        }
        if (prevAction instanceof NumberBucketAction && literalValue instanceof NumberRange) {
            if (!(literalValue.start !== null && NumberRange.numberBucket(literalValue.start, prevAction.size, prevAction.offset).equals(literalValue)))
                return null;
            return new InAction({ expression: this.expression });
        }
        if (prevAction instanceof FallbackAction && prevAction.expression.isOp('literal') && this.expression.isOp('literal') && !prevAction.expression.equals(this.expression)) {
            return this;
        }
        return null;
    };
    IsAction.prototype._performOnLiteral = function (literalExpression) {
        var expression = this.expression;
        if (!expression.isOp('literal')) {
            return new IsAction({ expression: literalExpression }).performOnSimple(expression);
        }
        return null;
    };
    IsAction.prototype._performOnRef = function (refExpression) {
        if (this.expression.equals(refExpression)) {
            return Expression.TRUE;
        }
        return null;
    };
    IsAction.prototype._performOnSimpleChain = function (chainExpression) {
        if (this.expression.equals(chainExpression)) {
            return Expression.TRUE;
        }
        var prevAction = chainExpression.lastAction();
        var literalValue = this.getLiteralValue();
        if (prevAction instanceof IndexOfAction && literalValue === -1) {
            var precedingExpression = chainExpression.expression;
            var actionExpression = prevAction.expression;
            return precedingExpression.contains(actionExpression).not().simplify();
        }
        return null;
    };
    return IsAction;
}(Action));
Action.register(IsAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var JoinAction = exports.JoinAction = (function (_super) {
    __extends(JoinAction, _super);
    function JoinAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("join");
        if (!this.expression.canHaveType('DATASET'))
            throw new TypeError('expression must be a DATASET');
    }
    JoinAction.fromJS = function (parameters) {
        return new JoinAction(Action.jsToValue(parameters));
    };
    JoinAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    JoinAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'DATASET';
    };
    JoinAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        var typeContextParent = typeContext.parent;
        var expressionFullType = this.expression._fillRefSubstitutions(typeContextParent, indexer, alterations);
        var inputDatasetType = typeContext.datasetType;
        var expressionDatasetType = expressionFullType.datasetType;
        var newDatasetType = Object.create(null);
        for (var k in inputDatasetType) {
            newDatasetType[k] = inputDatasetType[k];
        }
        for (var k in expressionDatasetType) {
            var ft = expressionDatasetType[k];
            if (hasOwnProperty(newDatasetType, k)) {
                if (newDatasetType[k].type !== ft.type) {
                    throw new Error("incompatible types of joins on " + k + " between " + newDatasetType[k].type + " and " + ft.type);
                }
            }
            else {
                newDatasetType[k] = ft;
            }
        }
        return {
            parent: typeContextParent,
            type: 'DATASET',
            datasetType: newDatasetType,
            remote: typeContext.remote || expressionFullType.remote
        };
    };
    JoinAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV.join(expressionFn(d, c)) : inV;
        };
    };
    JoinAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        throw new Error('not possible');
    };
    return JoinAction;
}(Action));
Action.register(JoinAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var LengthAction = exports.LengthAction = (function (_super) {
    __extends(LengthAction, _super);
    function LengthAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("length");
        this._checkNoExpression();
    }
    LengthAction.fromJS = function (parameters) {
        return new LengthAction(Action.jsToValue(parameters));
    };
    LengthAction.prototype.getNecessaryInputTypes = function () {
        return 'STRING';
    };
    LengthAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    LengthAction.prototype._fillRefSubstitutions = function (typeContext, inputType) {
        return inputType;
    };
    LengthAction.prototype._getFnHelper = function (inputType, inputFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            return inV.length;
        };
    };
    LengthAction.prototype._getJSHelper = function (inputType, inputJS) {
        return Expression.jsNullSafetyUnary(inputJS, function (input) { return (input + ".length"); });
    };
    LengthAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.lengthExpression(inputSQL);
    };
    return LengthAction;
}(Action));
Action.register(LengthAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var LessThanAction = exports.LessThanAction = (function (_super) {
    __extends(LessThanAction, _super);
    function LessThanAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("lessThan");
        this._checkExpressionTypes('NUMBER', 'TIME', 'STRING');
    }
    LessThanAction.fromJS = function (parameters) {
        return new LessThanAction(Action.jsToValue(parameters));
    };
    LessThanAction.prototype.getNecessaryInputTypes = function () {
        return this.expression.type;
    };
    LessThanAction.prototype.getOutputType = function (inputType) {
        var expressionType = this.expression.type;
        if (expressionType)
            this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    LessThanAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'BOOLEAN'
        };
    };
    LessThanAction.prototype.getUpgradedType = function (type) {
        return this.changeExpression(this.expression.upgradeToType(type));
    };
    LessThanAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return inputFn(d, c) < expressionFn(d, c);
        };
    };
    LessThanAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "<" + expressionJS + ")";
    };
    LessThanAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + "<" + expressionSQL + ")";
    };
    LessThanAction.prototype._specialSimplify = function (simpleExpression) {
        if (simpleExpression instanceof LiteralExpression) {
            return new InAction({
                expression: new LiteralExpression({
                    value: Range.fromJS({ start: null, end: simpleExpression.value, bounds: '()' })
                })
            });
        }
        return null;
    };
    LessThanAction.prototype._performOnLiteral = function (literalExpression) {
        return (new InAction({
            expression: new LiteralExpression({
                value: Range.fromJS({ start: literalExpression.value, end: null, bounds: '()' })
            })
        })).performOnSimple(this.expression);
    };
    return LessThanAction;
}(Action));
Action.register(LessThanAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var LessThanOrEqualAction = exports.LessThanOrEqualAction = (function (_super) {
    __extends(LessThanOrEqualAction, _super);
    function LessThanOrEqualAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("lessThanOrEqual");
        this._checkExpressionTypes('NUMBER', 'TIME', 'STRING');
    }
    LessThanOrEqualAction.fromJS = function (parameters) {
        return new LessThanOrEqualAction(Action.jsToValue(parameters));
    };
    LessThanOrEqualAction.prototype.getNecessaryInputTypes = function () {
        return this.expression.type;
    };
    LessThanOrEqualAction.prototype.getOutputType = function (inputType) {
        var expressionType = this.expression.type;
        if (expressionType)
            this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    LessThanOrEqualAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'BOOLEAN'
        };
    };
    LessThanOrEqualAction.prototype.getUpgradedType = function (type) {
        return this.changeExpression(this.expression.upgradeToType(type));
    };
    LessThanOrEqualAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return inputFn(d, c) <= expressionFn(d, c);
        };
    };
    LessThanOrEqualAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "<=" + expressionJS + ")";
    };
    LessThanOrEqualAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + "<=" + expressionSQL + ")";
    };
    LessThanOrEqualAction.prototype._specialSimplify = function (simpleExpression) {
        if (simpleExpression instanceof LiteralExpression) {
            return new InAction({
                expression: new LiteralExpression({
                    value: Range.fromJS({ start: null, end: simpleExpression.value, bounds: '(]' })
                })
            });
        }
        return null;
    };
    LessThanOrEqualAction.prototype._performOnLiteral = function (literalExpression) {
        return (new InAction({
            expression: new LiteralExpression({
                value: Range.fromJS({ start: literalExpression.value, end: null, bounds: '[)' })
            })
        })).performOnSimple(this.expression);
    };
    return LessThanOrEqualAction;
}(Action));
Action.register(LessThanOrEqualAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var IndexOfAction = exports.IndexOfAction = (function (_super) {
    __extends(IndexOfAction, _super);
    function IndexOfAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("indexOf");
        this._checkExpressionTypes('STRING');
    }
    IndexOfAction.fromJS = function (parameters) {
        return new IndexOfAction(Action.jsToValue(parameters));
    };
    IndexOfAction.prototype.getNecessaryInputTypes = function () {
        return 'STRING';
    };
    IndexOfAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    IndexOfAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    IndexOfAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            return inV.indexOf(expressionFn(d, c));
        };
    };
    IndexOfAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return Expression.jsNullSafetyBinary(inputJS, expressionJS, function (a, b) { return a + ".indexOf(" + b + ")"; }, inputJS[0] === '"', expressionJS[0] === '"');
    };
    IndexOfAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.indexOfExpression(inputSQL, expressionSQL);
    };
    return IndexOfAction;
}(Action));
Action.register(IndexOfAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var LookupAction = exports.LookupAction = (function (_super) {
    __extends(LookupAction, _super);
    function LookupAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.lookup = parameters.lookup;
        this._ensureAction("lookup");
    }
    LookupAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.lookup = parameters.lookup;
        return new LookupAction(value);
    };
    LookupAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.lookup = this.lookup;
        return value;
    };
    LookupAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.lookup = this.lookup;
        return js;
    };
    LookupAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.lookup === other.lookup;
    };
    LookupAction.prototype._toStringParameters = function (expressionString) {
        return [String(this.lookup)];
    };
    LookupAction.prototype.getNecessaryInputTypes = function () {
        return this._stringTransformInputType;
    };
    LookupAction.prototype.getOutputType = function (inputType) {
        return this._stringTransformOutputType(inputType);
    };
    LookupAction.prototype._fillRefSubstitutions = function (typeContext, inputType) {
        return inputType;
    };
    LookupAction.prototype.fullyDefined = function () {
        return false;
    };
    LookupAction.prototype._getFnHelper = function (inputType, inputFn) {
        throw new Error('can not express as JS');
    };
    LookupAction.prototype._getJSHelper = function (inputType, inputJS) {
        throw new Error('can not express as JS');
    };
    LookupAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        throw new Error('can not express as SQL');
    };
    return LookupAction;
}(Action));
Action.register(LookupAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var LimitAction = exports.LimitAction = (function (_super) {
    __extends(LimitAction, _super);
    function LimitAction(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this.limit = parameters.limit;
        this._ensureAction("limit");
    }
    LimitAction.fromJS = function (parameters) {
        return new LimitAction({
            action: parameters.action,
            limit: parameters.limit
        });
    };
    LimitAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.limit = this.limit;
        return value;
    };
    LimitAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.limit = this.limit;
        return js;
    };
    LimitAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.limit === other.limit;
    };
    LimitAction.prototype._toStringParameters = function (expressionString) {
        return [String(this.limit)];
    };
    LimitAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    LimitAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'DATASET';
    };
    LimitAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        return inputType;
    };
    LimitAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        var limit = this.limit;
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV.limit(limit) : null;
        };
    };
    LimitAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "LIMIT " + this.limit;
    };
    LimitAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction instanceof LimitAction) {
            return new LimitAction({
                limit: Math.min(prevAction.limit, this.limit)
            });
        }
        return null;
    };
    LimitAction.prototype._putBeforeLastAction = function (lastAction) {
        if (lastAction instanceof ApplyAction) {
            return this;
        }
        return null;
    };
    return LimitAction;
}(Action));
Action.register(LimitAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var REGEXP_SPECIAL = "\\^$.|?*+()[{";

var MatchAction = exports.MatchAction = (function (_super) {
    __extends(MatchAction, _super);
    function MatchAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.regexp = parameters.regexp;
        this._ensureAction("match");
    }
    MatchAction.likeToRegExp = function (like, escapeChar) {
        if (escapeChar === void 0) { escapeChar = '\\'; }
        var regExp = ['^'];
        for (var i = 0; i < like.length; i++) {
            var char = like[i];
            if (char === escapeChar) {
                var nextChar = like[i + 1];
                if (!nextChar)
                    throw new Error("invalid LIKE string '" + like + "'");
                char = nextChar;
                i++;
            }
            else if (char === '%') {
                regExp.push('.*');
                continue;
            }
            else if (char === '_') {
                regExp.push('.');
                continue;
            }
            if (REGEXP_SPECIAL.indexOf(char) !== -1) {
                regExp.push('\\');
            }
            regExp.push(char);
        }
        regExp.push('$');
        return regExp.join('');
    };
    MatchAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.regexp = parameters.regexp;
        return new MatchAction(value);
    };
    MatchAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.regexp = this.regexp;
        return value;
    };
    MatchAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.regexp = this.regexp;
        return js;
    };
    MatchAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.regexp === other.regexp;
    };
    MatchAction.prototype._toStringParameters = function (expressionString) {
        return [this.regexp];
    };
    MatchAction.prototype.getNecessaryInputTypes = function () {
        return this._stringTransformInputType;
    };
    MatchAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    MatchAction.prototype._fillRefSubstitutions = function () {
        return {
            type: 'BOOLEAN',
        };
    };
    MatchAction.prototype._getFnHelper = function (inputType, inputFn) {
        var re = new RegExp(this.regexp);
        return function (d, c) {
            var inV = inputFn(d, c);
            if (!inV)
                return null;
            if (inV === null)
                return null;
            return re.test(inV);
        };
    };
    MatchAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "/" + this.regexp + "/.test(" + inputJS + ")";
    };
    MatchAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.regexpExpression(inputSQL, this.regexp);
    };
    return MatchAction;
}(Action));
Action.register(MatchAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var MaxAction = exports.MaxAction = (function (_super) {
    __extends(MaxAction, _super);
    function MaxAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("max");
        this._checkExpressionTypes('NUMBER', 'TIME');
    }
    MaxAction.fromJS = function (parameters) {
        return new MaxAction(Action.jsToValue(parameters));
    };
    MaxAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    MaxAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    MaxAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'NUMBER',
        };
    };
    MaxAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "MAX(" + dialect.aggregateFilterIfNeeded(inputSQL, expressionSQL) + ")";
    };
    MaxAction.prototype.isAggregate = function () {
        return true;
    };
    MaxAction.prototype.isNester = function () {
        return true;
    };
    return MaxAction;
}(Action));
Action.register(MaxAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var MinAction = exports.MinAction = (function (_super) {
    __extends(MinAction, _super);
    function MinAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("min");
        this._checkExpressionTypes('NUMBER', 'TIME');
    }
    MinAction.fromJS = function (parameters) {
        return new MinAction(Action.jsToValue(parameters));
    };
    MinAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    MinAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    MinAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'NUMBER',
        };
    };
    MinAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "MIN(" + dialect.aggregateFilterIfNeeded(inputSQL, expressionSQL) + ")";
    };
    MinAction.prototype.isAggregate = function () {
        return true;
    };
    MinAction.prototype.isNester = function () {
        return true;
    };
    return MinAction;
}(Action));
Action.register(MinAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var MultiplyAction = exports.MultiplyAction = (function (_super) {
    __extends(MultiplyAction, _super);
    function MultiplyAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("multiply");
        this._checkExpressionTypes('NUMBER');
    }
    MultiplyAction.fromJS = function (parameters) {
        return new MultiplyAction(Action.jsToValue(parameters));
    };
    MultiplyAction.prototype.getNecessaryInputTypes = function () {
        return 'NUMBER';
    };
    MultiplyAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    MultiplyAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    MultiplyAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return (inputFn(d, c) || 0) * (expressionFn(d, c) || 0);
        };
    };
    MultiplyAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "*" + expressionJS + ")";
    };
    MultiplyAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + "*" + expressionSQL + ")";
    };
    MultiplyAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.ONE);
    };
    MultiplyAction.prototype._nukeExpression = function () {
        if (this.expression.equals(Expression.ZERO))
            return Expression.ZERO;
        return null;
    };
    MultiplyAction.prototype._distributeAction = function () {
        return this.expression.actionize(this.action);
    };
    MultiplyAction.prototype._performOnLiteral = function (literalExpression) {
        if (literalExpression.equals(Expression.ONE)) {
            return this.expression;
        }
        else if (literalExpression.equals(Expression.ZERO)) {
            return Expression.ZERO;
        }
        return null;
    };
    return MultiplyAction;
}(Action));
Action.register(MultiplyAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var NotAction = exports.NotAction = (function (_super) {
    __extends(NotAction, _super);
    function NotAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("not");
        this._checkNoExpression();
    }
    NotAction.fromJS = function (parameters) {
        return new NotAction(Action.jsToValue(parameters));
    };
    NotAction.prototype.getNecessaryInputTypes = function () {
        return 'BOOLEAN';
    };
    NotAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    NotAction.prototype._fillRefSubstitutions = function (typeContext, inputType) {
        return inputType;
    };
    NotAction.prototype._getFnHelper = function (inputType, inputFn) {
        return function (d, c) {
            return !inputFn(d, c);
        };
    };
    NotAction.prototype._getJSHelper = function (inputType, inputJS) {
        return "!(" + inputJS + ")";
    };
    NotAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "NOT(" + inputSQL + ")";
    };
    NotAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction instanceof NotAction) {
            return new AndAction({ expression: Expression.TRUE });
        }
        return null;
    };
    return NotAction;
}(Action));
Action.register(NotAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var NumberBucketAction = exports.NumberBucketAction = (function (_super) {
    __extends(NumberBucketAction, _super);
    function NumberBucketAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.size = parameters.size;
        this.offset = parameters.offset;
        this._ensureAction("numberBucket");
    }
    NumberBucketAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.size = parameters.size;
        value.offset = hasOwnProperty(parameters, 'offset') ? parameters.offset : 0;
        return new NumberBucketAction(value);
    };
    NumberBucketAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.size = this.size;
        value.offset = this.offset;
        return value;
    };
    NumberBucketAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.size = this.size;
        if (this.offset)
            js.offset = this.offset;
        return js;
    };
    NumberBucketAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.size === other.size &&
            this.offset === other.offset;
    };
    NumberBucketAction.prototype._toStringParameters = function (expressionString) {
        var params = [String(this.size)];
        if (this.offset)
            params.push(String(this.offset));
        return params;
    };
    NumberBucketAction.prototype.getNecessaryInputTypes = function () {
        return ['NUMBER', 'NUMBER_RANGE'];
    };
    NumberBucketAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER_RANGE';
    };
    NumberBucketAction.prototype._fillRefSubstitutions = function () {
        return {
            type: 'NUMBER_RANGE',
        };
    };
    NumberBucketAction.prototype._getFnHelper = function (inputType, inputFn) {
        var size = this.size;
        var offset = this.offset;
        return function (d, c) {
            var num = inputFn(d, c);
            if (num === null)
                return null;
            return NumberRange.numberBucket(num, size, offset);
        };
    };
    NumberBucketAction.prototype._getJSHelper = function (inputType, inputJS) {
        var _this = this;
        return Expression.jsNullSafetyUnary(inputJS, function (n) { return continuousFloorExpression(n, "Math.floor", _this.size, _this.offset); });
    };
    NumberBucketAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return continuousFloorExpression(inputSQL, "FLOOR", this.size, this.offset);
    };
    return NumberBucketAction;
}(Action));
Action.register(NumberBucketAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




function mergeOr(ex1, ex2) {
    if (!ex1.isOp('chain') ||
        !ex2.isOp('chain') ||
        !ex1.expression.isOp('ref') ||
        !ex2.expression.isOp('ref') ||
        !arraysEqual(ex1.getFreeReferences(), ex2.getFreeReferences()))
        return null;
    var ex1Actions = ex1.actions;
    var ex2Actions = ex2.actions;
    if (ex1Actions.length !== 1 || ex2Actions.length !== 1)
        return null;
    var firstActionExpression1 = ex1Actions[0].expression;
    var firstActionExpression2 = ex2Actions[0].expression;
    if (!firstActionExpression1.isOp('literal') || !firstActionExpression2.isOp('literal'))
        return null;
    var intersect = Set.generalUnion(firstActionExpression1.getLiteralValue(), firstActionExpression2.getLiteralValue());
    if (intersect === null)
        return null;
    return Expression.inOrIs(ex1.expression, intersect);
}
var OrAction = exports.OrAction = (function (_super) {
    __extends(OrAction, _super);
    function OrAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("or");
    }
    OrAction.fromJS = function (parameters) {
        return new OrAction(Action.jsToValue(parameters));
    };
    OrAction.prototype.getNecessaryInputTypes = function () {
        return 'BOOLEAN';
    };
    OrAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    OrAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    OrAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return inputFn(d, c) || expressionFn(d, c);
        };
    };
    OrAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "||" + expressionJS + ")";
    };
    OrAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + " OR " + expressionSQL + ")";
    };
    OrAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.FALSE);
    };
    OrAction.prototype._nukeExpression = function () {
        if (this.expression.equals(Expression.TRUE))
            return Expression.TRUE;
        return null;
    };
    OrAction.prototype._distributeAction = function () {
        return this.expression.actionize(this.action);
    };
    OrAction.prototype._performOnLiteral = function (literalExpression) {
        if (literalExpression.equals(Expression.FALSE)) {
            return this.expression;
        }
        if (literalExpression.equals(Expression.TRUE)) {
            return Expression.TRUE;
        }
        return null;
    };
    OrAction.prototype._performOnSimpleChain = function (chainExpression) {
        var expression = this.expression;
        var orExpressions = chainExpression.getExpressionPattern('or');
        if (orExpressions) {
            for (var i = 0; i < orExpressions.length; i++) {
                var orExpression = orExpressions[i];
                var mergedExpression = mergeOr(orExpression, expression);
                if (mergedExpression) {
                    orExpressions[i] = mergedExpression;
                    return Expression.or(orExpressions).simplify();
                }
            }
        }
        return mergeOr(chainExpression, expression);
    };
    return OrAction;
}(Action));
Action.register(OrAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var OverlapAction = exports.OverlapAction = (function (_super) {
    __extends(OverlapAction, _super);
    function OverlapAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("overlap");
        if (!this.expression.canHaveType('SET')) {
            throw new Error(this.action + " must have an expression of type SET (is: " + this.expression.type + ")");
        }
    }
    OverlapAction.fromJS = function (parameters) {
        return new OverlapAction(Action.jsToValue(parameters));
    };
    OverlapAction.prototype.getNecessaryInputTypes = function () {
        var expressionType = this.expression.type;
        if (expressionType && expressionType !== 'NULL' && expressionType !== 'SET/NULL') {
            var setExpressionType = wrapSetType(expressionType);
            var unwrapped = unwrapSetType(setExpressionType);
            return [setExpressionType, unwrapped];
        }
        else {
            return [
                'NULL', 'BOOLEAN', 'NUMBER', 'TIME', 'STRING', 'NUMBER_RANGE', 'TIME_RANGE', 'STRING_RANGE',
                'SET', 'SET/NULL', 'SET/BOOLEAN', 'SET/NUMBER', 'SET/TIME', 'SET/STRING',
                'SET/NUMBER_RANGE', 'SET/TIME_RANGE', 'DATASET'
            ];
        }
    };
    OverlapAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'BOOLEAN';
    };
    OverlapAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'BOOLEAN'
        };
    };
    OverlapAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            var inV = inputFn(d, c);
            var exV = expressionFn(d, c);
            if (exV == null)
                return null;
            return Set.isSet(inV) ? inV.overlap(exV) : exV.contains(inV);
        };
    };
    OverlapAction.prototype._nukeExpression = function () {
        if (this.expression.equals(Expression.EMPTY_SET))
            return Expression.FALSE;
        return null;
    };
    OverlapAction.prototype._performOnSimpleWhatever = function (ex) {
        var expression = this.expression;
        if ('SET/' + ex.type === expression.type) {
            return new InAction({ expression: expression }).performOnSimple(ex);
        }
        return null;
    };
    OverlapAction.prototype._performOnLiteral = function (literalExpression) {
        var expression = this.expression;
        if (!expression.isOp('literal'))
            return new OverlapAction({ expression: literalExpression }).performOnSimple(expression);
        return this._performOnSimpleWhatever(literalExpression);
    };
    OverlapAction.prototype._performOnRef = function (refExpression) {
        return this._performOnSimpleWhatever(refExpression);
    };
    OverlapAction.prototype._performOnSimpleChain = function (chainExpression) {
        return this._performOnSimpleWhatever(chainExpression);
    };
    return OverlapAction;
}(Action));
Action.register(OverlapAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var PowerAction = exports.PowerAction = (function (_super) {
    __extends(PowerAction, _super);
    function PowerAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("power");
        this._checkExpressionTypes('NUMBER');
    }
    PowerAction.fromJS = function (parameters) {
        return new PowerAction(Action.jsToValue(parameters));
    };
    PowerAction.prototype.getNecessaryInputTypes = function () {
        return 'NUMBER';
    };
    PowerAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    PowerAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    PowerAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return Math.pow((inputFn(d, c) || 0), (expressionFn(d, c) || 0));
        };
    };
    PowerAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "Math.pow(" + inputJS + "," + expressionJS + ")";
    };
    PowerAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "POW(" + inputSQL + "," + expressionSQL + ")";
    };
    PowerAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.ONE);
    };
    PowerAction.prototype._performOnRef = function (simpleExpression) {
        if (this.expression.equals(Expression.ZERO))
            return simpleExpression;
        return null;
    };
    return PowerAction;
}(Action));
Action.register(PowerAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var QuantileAction = exports.QuantileAction = (function (_super) {
    __extends(QuantileAction, _super);
    function QuantileAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.quantile = parameters.quantile;
        this._ensureAction("quantile");
        this._checkExpressionTypes('NUMBER');
    }
    QuantileAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.quantile = parameters.quantile;
        return new QuantileAction(value);
    };
    QuantileAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.quantile = this.quantile;
        return value;
    };
    QuantileAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.quantile = this.quantile;
        return js;
    };
    QuantileAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.quantile === other.quantile;
    };
    QuantileAction.prototype._toStringParameters = function (expressionString) {
        return [expressionString, String(this.quantile)];
    };
    QuantileAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    QuantileAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    QuantileAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'NUMBER'
        };
    };
    QuantileAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        var quantile = this.quantile;
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV.quantile(expressionFn, quantile, foldContext(d, c)) : null;
        };
    };
    QuantileAction.prototype.isAggregate = function () {
        return true;
    };
    QuantileAction.prototype.isNester = function () {
        return true;
    };
    return QuantileAction;
}(Action));
Action.register(QuantileAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var SelectAction = exports.SelectAction = (function (_super) {
    __extends(SelectAction, _super);
    function SelectAction(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this.attributes = parameters.attributes;
        this._ensureAction("select");
    }
    SelectAction.fromJS = function (parameters) {
        return new SelectAction({
            action: parameters.action,
            attributes: parameters.attributes
        });
    };
    SelectAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.attributes = this.attributes;
        return value;
    };
    SelectAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.attributes = this.attributes;
        return js;
    };
    SelectAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            String(this.attributes) === String(other.attributes);
    };
    SelectAction.prototype._toStringParameters = function (expressionString) {
        return this.attributes;
    };
    SelectAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    SelectAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'DATASET';
    };
    SelectAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        var attributes = this.attributes;
        var datasetType = typeContext.datasetType;
        var newDatasetType = Object.create(null);
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var attr = attributes_1[_i];
            var attrType = datasetType[attr];
            if (!attrType)
                throw new Error("unknown attribute '" + attr + "' in select");
            newDatasetType[attr] = attrType;
        }
        typeContext.datasetType = newDatasetType;
        return typeContext;
    };
    SelectAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        var attributes = this.attributes;
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV.select(attributes) : null;
        };
    };
    SelectAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        throw new Error('can not be expressed as SQL directly');
    };
    SelectAction.prototype._foldWithPrevAction = function (prevAction) {
        var attributes = this.attributes;
        if (prevAction instanceof SelectAction) {
            return new SelectAction({
                attributes: prevAction.attributes.filter(function (a) { return attributes.indexOf(a) !== -1; })
            });
        }
        else if (prevAction instanceof ApplyAction) {
            if (attributes.indexOf(prevAction.name) === -1) {
                return this;
            }
        }
        return null;
    };
    return SelectAction;
}(Action));
Action.register(SelectAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var SortAction = exports.SortAction = (function (_super) {
    __extends(SortAction, _super);
    function SortAction(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        var direction = parameters.direction || 'ascending';
        if (direction !== SortAction.DESCENDING && direction !== SortAction.ASCENDING) {
            throw new Error("direction must be '" + SortAction.DESCENDING + "' or '" + SortAction.ASCENDING + "'");
        }
        this.direction = direction;
        if (!this.expression.isOp('ref')) {
            throw new Error("must be a reference expression: " + this.expression);
        }
        this._ensureAction("sort");
    }
    SortAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.direction = parameters.direction;
        return new SortAction(value);
    };
    SortAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.direction = this.direction;
        return value;
    };
    SortAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.direction = this.direction;
        return js;
    };
    SortAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.direction === other.direction;
    };
    SortAction.prototype._toStringParameters = function (expressionString) {
        return [expressionString, this.direction];
    };
    SortAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    SortAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'DATASET';
    };
    SortAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return typeContext;
    };
    SortAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        var direction = this.direction;
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV.sort(expressionFn, direction) : null;
        };
    };
    SortAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        var dir = this.direction === SortAction.DESCENDING ? 'DESC' : 'ASC';
        return "ORDER BY " + expressionSQL + " " + dir;
    };
    SortAction.prototype.refName = function () {
        var expression = this.expression;
        return (expression instanceof RefExpression) ? expression.name : null;
    };
    SortAction.prototype.isNester = function () {
        return true;
    };
    SortAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction instanceof SortAction && this.expression.equals(prevAction.expression)) {
            return this;
        }
        return null;
    };
    SortAction.prototype.toggleDirection = function () {
        return new SortAction({
            expression: this.expression,
            direction: this.direction === SortAction.ASCENDING ? SortAction.DESCENDING : SortAction.ASCENDING
        });
    };
    SortAction.DESCENDING = 'descending';
    SortAction.ASCENDING = 'ascending';
    return SortAction;
}(Action));
Action.register(SortAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var SplitAction = exports.SplitAction = (function (_super) {
    __extends(SplitAction, _super);
    function SplitAction(parameters) {
        _super.call(this, parameters, dummyObject);
        var splits = parameters.splits;
        if (!splits)
            throw new Error('must have splits');
        this.splits = splits;
        this.keys = Object.keys(splits).sort();
        if (!this.keys.length)
            throw new Error('must have at least one split');
        this.dataName = parameters.dataName;
        this._ensureAction("split");
    }
    SplitAction.fromJS = function (parameters) {
        var value = {
            action: parameters.action
        };
        var splits;
        if (parameters.expression && parameters.name) {
            splits = (_a = {}, _a[parameters.name] = parameters.expression, _a);
        }
        else {
            splits = parameters.splits;
        }
        value.splits = Expression.expressionLookupFromJS(splits);
        value.dataName = parameters.dataName;
        return new SplitAction(value);
        var _a;
    };
    SplitAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.splits = this.splits;
        value.dataName = this.dataName;
        return value;
    };
    SplitAction.prototype.toJS = function () {
        var splits = this.splits;
        var js = _super.prototype.toJS.call(this);
        if (this.isMultiSplit()) {
            js.splits = Expression.expressionLookupToJS(splits);
        }
        else {
            for (var name in splits) {
                js.name = name;
                js.expression = splits[name].toJS();
            }
        }
        js.dataName = this.dataName;
        return js;
    };
    SplitAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            immutableLookupsEqual(this.splits, other.splits) &&
            this.dataName === other.dataName;
    };
    SplitAction.prototype._toStringParameters = function (expressionString) {
        if (this.isMultiSplit()) {
            var splits = this.splits;
            var splitStrings = [];
            for (var name in splits) {
                splitStrings.push(name + ": " + splits[name]);
            }
            return [splitStrings.join(', '), this.dataName];
        }
        else {
            return [this.firstSplitExpression().toString(), this.firstSplitName(), this.dataName];
        }
    };
    SplitAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    SplitAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'DATASET';
    };
    SplitAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        var newDatasetType = {};
        this.mapSplits(function (name, expression) {
            newDatasetType[name] = expression._fillRefSubstitutions(typeContext, indexer, alterations);
        });
        newDatasetType[this.dataName] = typeContext;
        return {
            parent: typeContext.parent,
            type: 'DATASET',
            datasetType: newDatasetType,
            remote: false
        };
    };
    SplitAction.prototype.getFn = function (inputType, inputFn) {
        var dataName = this.dataName;
        var splitFns = this.mapSplitExpressions(function (ex) { return ex.getFn(); });
        return function (d, c) {
            var inV = inputFn(d, c);
            return inV ? inV.split(splitFns, dataName) : null;
        };
    };
    SplitAction.prototype.getSQL = function (inputType, inputSQL, dialect) {
        var groupBys = this.mapSplits(function (name, expression) { return expression.getSQL(dialect); });
        return "GROUP BY " + groupBys.join(', ');
    };
    SplitAction.prototype.getSelectSQL = function (dialect) {
        return this.mapSplits(function (name, expression) { return (expression.getSQL(dialect) + " AS " + dialect.escapeName(name)); });
    };
    SplitAction.prototype.getShortGroupBySQL = function () {
        return 'GROUP BY ' + Object.keys(this.splits).map(function (d, i) { return i + 1; }).join(', ');
    };
    SplitAction.prototype.expressionCount = function () {
        var count = 0;
        this.mapSplits(function (k, expression) {
            count += expression.expressionCount();
        });
        return count;
    };
    SplitAction.prototype.fullyDefined = function () {
        return false;
    };
    SplitAction.prototype.simplify = function () {
        if (this.simple)
            return this;
        var simpleSplits = this.mapSplitExpressions(function (ex) { return ex.simplify(); });
        var value = this.valueOf();
        value.splits = simpleSplits;
        value.simple = true;
        return new SplitAction(value);
    };
    SplitAction.prototype.getExpressions = function () {
        return this.mapSplits(function (name, ex) { return ex; });
    };
    SplitAction.prototype._substituteHelper = function (substitutionFn, thisArg, indexer, depth, nestDiff) {
        var nestDiffNext = nestDiff + 1;
        var hasChanged = false;
        var subSplits = this.mapSplitExpressions(function (ex) {
            var subExpression = ex._substituteHelper(substitutionFn, thisArg, indexer, depth, nestDiffNext);
            if (subExpression !== ex)
                hasChanged = true;
            return subExpression;
        });
        if (!hasChanged)
            return this;
        var value = this.valueOf();
        value.splits = subSplits;
        return new SplitAction(value);
    };
    SplitAction.prototype.isNester = function () {
        return true;
    };
    SplitAction.prototype.numSplits = function () {
        return this.keys.length;
    };
    SplitAction.prototype.isMultiSplit = function () {
        return this.numSplits() > 1;
    };
    SplitAction.prototype.mapSplits = function (fn) {
        var _a = this, splits = _a.splits, keys = _a.keys;
        var res = [];
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var v = fn(k, splits[k]);
            if (typeof v !== 'undefined')
                res.push(v);
        }
        return res;
    };
    SplitAction.prototype.mapSplitExpressions = function (fn) {
        var _a = this, splits = _a.splits, keys = _a.keys;
        var ret = Object.create(null);
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var key = keys_2[_i];
            ret[key] = fn(splits[key], key);
        }
        return ret;
    };
    SplitAction.prototype.transformExpressions = function (fn) {
        var _a = this, splits = _a.splits, keys = _a.keys;
        var newSplits = Object.create(null);
        var changed = false;
        for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
            var key = keys_3[_i];
            var ex = splits[key];
            var transformed = fn(ex, key);
            if (transformed !== ex)
                changed = true;
            newSplits[key] = transformed;
        }
        if (!changed)
            return this;
        var value = this.valueOf();
        value.splits = newSplits;
        return new SplitAction(value);
    };
    SplitAction.prototype.firstSplitName = function () {
        return this.keys[0];
    };
    SplitAction.prototype.firstSplitExpression = function () {
        return this.splits[this.firstSplitName()];
    };
    SplitAction.prototype.filterFromDatum = function (datum) {
        return Expression.and(this.mapSplits(function (name, expression) {
            if (isSetType(expression.type)) {
                return r(datum[name]).in(expression);
            }
            else {
                return expression.is(r(datum[name]));
            }
        })).simplify();
    };
    SplitAction.prototype.hasKey = function (key) {
        return hasOwnProperty(this.splits, key);
    };
    SplitAction.prototype.maxBucketNumber = function () {
        var _a = this, splits = _a.splits, keys = _a.keys;
        var num = 1;
        for (var _i = 0, keys_4 = keys; _i < keys_4.length; _i++) {
            var key = keys_4[_i];
            num *= splits[key].maxPossibleSplitValues();
        }
        return num;
    };
    SplitAction.prototype.isAggregate = function () {
        return true;
    };
    return SplitAction;
}(Action));
Action.register(SplitAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var SubstrAction = exports.SubstrAction = (function (_super) {
    __extends(SubstrAction, _super);
    function SubstrAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.position = parameters.position;
        this.length = parameters.length;
        this._ensureAction("substr");
    }
    SubstrAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.position = parameters.position;
        value.length = parameters.length;
        return new SubstrAction(value);
    };
    SubstrAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.position = this.position;
        value.length = this.length;
        return value;
    };
    SubstrAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.position = this.position;
        js.length = this.length;
        return js;
    };
    SubstrAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.position === other.position &&
            this.length === other.length;
    };
    SubstrAction.prototype._toStringParameters = function (expressionString) {
        return [String(this.position), String(this.length)];
    };
    SubstrAction.prototype.getNecessaryInputTypes = function () {
        return this._stringTransformInputType;
    };
    SubstrAction.prototype.getOutputType = function (inputType) {
        return this._stringTransformOutputType(inputType);
    };
    SubstrAction.prototype._fillRefSubstitutions = function (typeContext, inputType) {
        return inputType;
    };
    SubstrAction.prototype._getFnHelper = function (inputType, inputFn) {
        var _a = this, position = _a.position, length = _a.length;
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            return inV.substr(position, length);
        };
    };
    SubstrAction.prototype._getJSHelper = function (inputType, inputJS) {
        var _a = this, position = _a.position, length = _a.length;
        return "(_=" + inputJS + ",_==null?null:(''+_).substr(" + position + "," + length + "))";
    };
    SubstrAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "SUBSTR(" + inputSQL + "," + (this.position + 1) + "," + this.length + ")";
    };
    return SubstrAction;
}(Action));
Action.register(SubstrAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var SubtractAction = exports.SubtractAction = (function (_super) {
    __extends(SubtractAction, _super);
    function SubtractAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("subtract");
        this._checkExpressionTypes('NUMBER');
    }
    SubtractAction.fromJS = function (parameters) {
        return new SubtractAction(Action.jsToValue(parameters));
    };
    SubtractAction.prototype.getNecessaryInputTypes = function () {
        return 'NUMBER';
    };
    SubtractAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    SubtractAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return inputType;
    };
    SubtractAction.prototype._getFnHelper = function (inputType, inputFn, expressionFn) {
        return function (d, c) {
            return (inputFn(d, c) || 0) - (expressionFn(d, c) || 0);
        };
    };
    SubtractAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        return "(" + inputJS + "-" + expressionJS + ")";
    };
    SubtractAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "(" + inputSQL + "-" + expressionSQL + ")";
    };
    SubtractAction.prototype._removeAction = function () {
        return this.expression.equals(Expression.ZERO);
    };
    return SubtractAction;
}(Action));
Action.register(SubtractAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var SumAction = exports.SumAction = (function (_super) {
    __extends(SumAction, _super);
    function SumAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureAction("sum");
        this._checkExpressionTypes('NUMBER');
    }
    SumAction.fromJS = function (parameters) {
        return new SumAction(Action.jsToValue(parameters));
    };
    SumAction.prototype.getNecessaryInputTypes = function () {
        return 'DATASET';
    };
    SumAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    SumAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        this.expression._fillRefSubstitutions(typeContext, indexer, alterations);
        return {
            type: 'NUMBER'
        };
    };
    SumAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return "SUM(" + dialect.aggregateFilterIfNeeded(inputSQL, expressionSQL) + ")";
    };
    SumAction.prototype.isAggregate = function () {
        return true;
    };
    SumAction.prototype.isNester = function () {
        return true;
    };
    SumAction.prototype.canDistribute = function () {
        var expression = this.expression;
        return expression instanceof LiteralExpression ||
            Boolean(expression.getExpressionPattern('add') || expression.getExpressionPattern('subtract'));
    };
    SumAction.prototype.distribute = function (preEx) {
        var expression = this.expression;
        if (expression instanceof LiteralExpression) {
            var value = expression.value;
            if (value === 0)
                return Expression.ZERO;
            return expression.multiply(preEx.count()).simplify();
        }
        var pattern;
        if (pattern = expression.getExpressionPattern('add')) {
            return Expression.add(pattern.map(function (ex) { return preEx.sum(ex).distribute(); }));
        }
        if (pattern = expression.getExpressionPattern('subtract')) {
            return Expression.subtract(pattern.map(function (ex) { return preEx.sum(ex).distribute(); }));
        }
        return null;
    };
    return SumAction;
}(Action));
Action.register(SumAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var TimeBucketAction = exports.TimeBucketAction = (function (_super) {
    __extends(TimeBucketAction, _super);
    function TimeBucketAction(parameters) {
        _super.call(this, parameters, dummyObject);
        var duration = parameters.duration;
        this.duration = duration;
        this.timezone = parameters.timezone;
        this._ensureAction("timeBucket");
        if (!Duration.isDuration(duration)) {
            throw new Error("`duration` must be a Duration");
        }
        if (!duration.isFloorable()) {
            throw new Error("duration '" + duration.toString() + "' is not floorable");
        }
    }
    TimeBucketAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeBucketAction(value);
    };
    TimeBucketAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeBucketAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeBucketAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeBucketAction.prototype._toStringParameters = function (expressionString) {
        var ret = [this.duration.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeBucketAction.prototype.getNecessaryInputTypes = function () {
        return ['TIME', 'TIME_RANGE'];
    };
    TimeBucketAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'TIME_RANGE';
    };
    TimeBucketAction.prototype._fillRefSubstitutions = function () {
        return {
            type: 'TIME_RANGE',
        };
    };
    TimeBucketAction.prototype._getFnHelper = function (inputType, inputFn) {
        var duration = this.duration;
        var timezone = this.getTimezone();
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            return TimeRange.timeBucket(inV, duration, timezone);
        };
    };
    TimeBucketAction.prototype._getJSHelper = function (inputType, inputJS) {
        throw new Error("implement me");
    };
    TimeBucketAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.timeBucketExpression(inputSQL, this.duration, this.getTimezone());
    };
    TimeBucketAction.prototype.needsEnvironment = function () {
        return !this.timezone;
    };
    TimeBucketAction.prototype.defineEnvironment = function (environment) {
        if (this.timezone || !environment.timezone)
            return this;
        var value = this.valueOf();
        value.timezone = environment.timezone;
        return new TimeBucketAction(value);
    };
    TimeBucketAction.prototype.getTimezone = function () {
        return this.timezone || Timezone.UTC;
    };
    return TimeBucketAction;
}(Action));
Action.register(TimeBucketAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};








var TimeFloorAction = exports.TimeFloorAction = (function (_super) {
    __extends(TimeFloorAction, _super);
    function TimeFloorAction(parameters) {
        _super.call(this, parameters, dummyObject);
        var duration = parameters.duration;
        this.duration = duration;
        this.timezone = parameters.timezone;
        this._ensureAction("timeFloor");
        if (!Duration.isDuration(duration)) {
            throw new Error("`duration` must be a Duration");
        }
        if (!duration.isFloorable()) {
            throw new Error("duration '" + duration.toString() + "' is not floorable");
        }
    }
    TimeFloorAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeFloorAction(value);
    };
    TimeFloorAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeFloorAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeFloorAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeFloorAction.prototype._toStringParameters = function (expressionString) {
        var ret = [this.duration.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeFloorAction.prototype.getNecessaryInputTypes = function () {
        return 'TIME';
    };
    TimeFloorAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'TIME';
    };
    TimeFloorAction.prototype._fillRefSubstitutions = function () {
        return {
            type: 'TIME',
        };
    };
    TimeFloorAction.prototype._getFnHelper = function (inputType, inputFn) {
        var duration = this.duration;
        var timezone = this.getTimezone();
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            return duration.floor(inV, timezone);
        };
    };
    TimeFloorAction.prototype._getJSHelper = function (inputType, inputJS) {
        throw new Error("implement me");
    };
    TimeFloorAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.timeFloorExpression(inputSQL, this.duration, this.getTimezone());
    };
    TimeFloorAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction.equals(this)) {
            return this;
        }
        return null;
    };
    TimeFloorAction.prototype.needsEnvironment = function () {
        return !this.timezone;
    };
    TimeFloorAction.prototype.defineEnvironment = function (environment) {
        if (this.timezone || !environment.timezone)
            return this;
        var value = this.valueOf();
        value.timezone = environment.timezone;
        return new TimeFloorAction(value);
    };
    TimeFloorAction.prototype.getTimezone = function () {
        return this.timezone || Timezone.UTC;
    };
    TimeFloorAction.prototype.alignsWith = function (actions) {
        if (!actions.length)
            return false;
        var action = actions[0];
        var _a = this, timezone = _a.timezone, duration = _a.duration;
        if (!timezone)
            return false;
        if (action instanceof TimeFloorAction || action instanceof TimeBucketAction) {
            return timezone.equals(action.timezone) && action.duration.dividesBy(duration);
        }
        if (action instanceof InAction || action instanceof OverlapAction) {
            var literal = action.getLiteralValue();
            if (TimeRange.isTimeRange(literal)) {
                return literal.isAligned(duration, timezone);
            }
            else if (Set.isSet(literal)) {
                if (literal.setType !== 'TIME_RANGE')
                    return false;
                return literal.elements.every(function (e) {
                    return e.isAligned(duration, timezone);
                });
            }
        }
        return false;
    };
    return TimeFloorAction;
}(Action));
Action.register(TimeFloorAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var PART_TO_FUNCTION = {
    SECOND_OF_MINUTE: function (d) { return d.getSeconds(); },
    SECOND_OF_HOUR: function (d) { return d.getMinutes() * 60 + d.getSeconds(); },
    SECOND_OF_DAY: function (d) { return (d.getHours() * 60 + d.getMinutes()) * 60 + d.getSeconds(); },
    SECOND_OF_WEEK: function (d) { return ((d.getDay() * 24) + d.getHours() * 60 + d.getMinutes()) * 60 + d.getSeconds(); },
    SECOND_OF_MONTH: function (d) { return (((d.getDate() - 1) * 24) + d.getHours() * 60 + d.getMinutes()) * 60 + d.getSeconds(); },
    SECOND_OF_YEAR: null,
    MINUTE_OF_HOUR: function (d) { return d.getMinutes(); },
    MINUTE_OF_DAY: function (d) { return d.getHours() * 60 + d.getMinutes(); },
    MINUTE_OF_WEEK: function (d) { return (d.getDay() * 24) + d.getHours() * 60 + d.getMinutes(); },
    MINUTE_OF_MONTH: function (d) { return ((d.getDate() - 1) * 24) + d.getHours() * 60 + d.getMinutes(); },
    MINUTE_OF_YEAR: null,
    HOUR_OF_DAY: function (d) { return d.getHours(); },
    HOUR_OF_WEEK: function (d) { return d.getDay() * 24 + d.getHours(); },
    HOUR_OF_MONTH: function (d) { return (d.getDate() - 1) * 24 + d.getHours(); },
    HOUR_OF_YEAR: null,
    DAY_OF_WEEK: function (d) { return d.getDay() || 7; },
    DAY_OF_MONTH: function (d) { return d.getDate(); },
    DAY_OF_YEAR: null,
    WEEK_OF_MONTH: null,
    WEEK_OF_YEAR: null,
    MONTH_OF_YEAR: function (d) { return d.getMonth(); },
    YEAR: function (d) { return d.getFullYear(); }
};
var PART_TO_MAX_VALUES = {
    SECOND_OF_MINUTE: 61,
    SECOND_OF_HOUR: 3601,
    SECOND_OF_DAY: 93601,
    SECOND_OF_WEEK: null,
    SECOND_OF_MONTH: null,
    SECOND_OF_YEAR: null,
    MINUTE_OF_HOUR: 60,
    MINUTE_OF_DAY: 26 * 60,
    MINUTE_OF_WEEK: null,
    MINUTE_OF_MONTH: null,
    MINUTE_OF_YEAR: null,
    HOUR_OF_DAY: 26,
    HOUR_OF_WEEK: null,
    HOUR_OF_MONTH: null,
    HOUR_OF_YEAR: null,
    DAY_OF_WEEK: 7,
    DAY_OF_MONTH: 31,
    DAY_OF_YEAR: 366,
    WEEK_OF_MONTH: 5,
    WEEK_OF_YEAR: 53,
    MONTH_OF_YEAR: 12,
    YEAR: null
};
var TimePartAction = exports.TimePartAction = (function (_super) {
    __extends(TimePartAction, _super);
    function TimePartAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.part = parameters.part;
        this.timezone = parameters.timezone;
        this._ensureAction("timePart");
        if (typeof this.part !== 'string') {
            throw new Error("`part` must be a string");
        }
    }
    TimePartAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.part = parameters.part;
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimePartAction(value);
    };
    TimePartAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.part = this.part;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimePartAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.part = this.part;
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimePartAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.part === other.part &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimePartAction.prototype._toStringParameters = function (expressionString) {
        var ret = [this.part];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimePartAction.prototype.getNecessaryInputTypes = function () {
        return 'TIME';
    };
    TimePartAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'NUMBER';
    };
    TimePartAction.prototype._fillRefSubstitutions = function () {
        return {
            type: 'NUMBER',
        };
    };
    TimePartAction.prototype._getFnHelper = function (inputType, inputFn) {
        var part = this.part;
        var timezone = this.getTimezone();
        var parter = PART_TO_FUNCTION[part];
        if (!parter)
            throw new Error("unsupported part '" + part + "'");
        return function (d, c) {
            var inV = inputFn(d, c);
            if (!inV)
                return null;
            inV = WallTime.UTCToWallTime(inV, timezone.toString());
            return parter(inV);
        };
    };
    TimePartAction.prototype._getJSHelper = function (inputType, inputJS) {
        throw new Error("implement me");
    };
    TimePartAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.timePartExpression(inputSQL, this.part, this.getTimezone());
    };
    TimePartAction.prototype.maxPossibleSplitValues = function () {
        var maxValue = PART_TO_MAX_VALUES[this.part];
        if (!maxValue)
            return Infinity;
        return maxValue + 1;
    };
    TimePartAction.prototype.needsEnvironment = function () {
        return !this.timezone;
    };
    TimePartAction.prototype.defineEnvironment = function (environment) {
        if (this.timezone || !environment.timezone)
            return this;
        var value = this.valueOf();
        value.timezone = environment.timezone;
        return new TimePartAction(value);
    };
    TimePartAction.prototype.getTimezone = function () {
        return this.timezone || Timezone.UTC;
    };
    return TimePartAction;
}(Action));
Action.register(TimePartAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var TimeRangeAction = exports.TimeRangeAction = (function (_super) {
    __extends(TimeRangeAction, _super);
    function TimeRangeAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.duration = parameters.duration;
        this.step = parameters.step || TimeRangeAction.DEFAULT_STEP;
        this.timezone = parameters.timezone;
        this._ensureAction("timeRange");
        if (!Duration.isDuration(this.duration)) {
            throw new Error("`duration` must be a Duration");
        }
    }
    TimeRangeAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        value.step = parameters.step;
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeRangeAction(value);
    };
    TimeRangeAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        value.step = this.step;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeRangeAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        js.step = this.step;
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeRangeAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            this.step === other.step &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeRangeAction.prototype._toStringParameters = function (expressionString) {
        var ret = [this.duration.toString(), this.step.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeRangeAction.prototype.getNecessaryInputTypes = function () {
        return 'TIME';
    };
    TimeRangeAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'TIME_RANGE';
    };
    TimeRangeAction.prototype._fillRefSubstitutions = function () {
        return {
            type: 'TIME_RANGE',
        };
    };
    TimeRangeAction.prototype._getFnHelper = function (inputType, inputFn) {
        var duration = this.duration;
        var step = this.step;
        var timezone = this.getTimezone();
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            var other = duration.shift(inV, timezone, step);
            if (step > 0) {
                return new TimeRange({ start: inV, end: other });
            }
            else {
                return new TimeRange({ start: other, end: inV });
            }
        };
    };
    TimeRangeAction.prototype._getJSHelper = function (inputType, inputJS) {
        throw new Error("implement me");
    };
    TimeRangeAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        throw new Error("implement me");
    };
    TimeRangeAction.prototype.needsEnvironment = function () {
        return !this.timezone;
    };
    TimeRangeAction.prototype.defineEnvironment = function (environment) {
        if (this.timezone || !environment.timezone)
            return this;
        var value = this.valueOf();
        value.timezone = environment.timezone;
        return new TimeRangeAction(value);
    };
    TimeRangeAction.prototype.getTimezone = function () {
        return this.timezone || Timezone.UTC;
    };
    TimeRangeAction.DEFAULT_STEP = 1;
    return TimeRangeAction;
}(Action));
Action.register(TimeRangeAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var TimeShiftAction = exports.TimeShiftAction = (function (_super) {
    __extends(TimeShiftAction, _super);
    function TimeShiftAction(parameters) {
        _super.call(this, parameters, dummyObject);
        this.duration = parameters.duration;
        this.step = parameters.step || TimeShiftAction.DEFAULT_STEP;
        this.timezone = parameters.timezone;
        this._ensureAction("timeShift");
        if (!Duration.isDuration(this.duration)) {
            throw new Error("`duration` must be a Duration");
        }
    }
    TimeShiftAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        value.step = parameters.step;
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeShiftAction(value);
    };
    TimeShiftAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        value.step = this.step;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeShiftAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        js.step = this.step;
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeShiftAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            this.step === other.step &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeShiftAction.prototype._toStringParameters = function (expressionString) {
        var ret = [this.duration.toString(), this.step.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeShiftAction.prototype.getNecessaryInputTypes = function () {
        return 'TIME';
    };
    TimeShiftAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'TIME';
    };
    TimeShiftAction.prototype._fillRefSubstitutions = function () {
        return {
            type: 'TIME',
        };
    };
    TimeShiftAction.prototype._getFnHelper = function (inputType, inputFn) {
        var duration = this.duration;
        var step = this.step;
        var timezone = this.getTimezone();
        return function (d, c) {
            var inV = inputFn(d, c);
            if (inV === null)
                return null;
            return duration.shift(inV, timezone, step);
        };
    };
    TimeShiftAction.prototype._getJSHelper = function (inputType, inputJS) {
        throw new Error("implement me");
    };
    TimeShiftAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL, expressionSQL) {
        return dialect.timeShiftExpression(inputSQL, this.duration, this.getTimezone());
    };
    TimeShiftAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction instanceof TimeShiftAction) {
            if (this.duration.equals(prevAction.duration) &&
                Boolean(this.timezone) === Boolean(prevAction.timezone) &&
                (!this.timezone || this.timezone.equals(prevAction.timezone))) {
                var value = this.valueOf();
                value.step += prevAction.step;
                return new TimeShiftAction(value);
            }
        }
        return null;
    };
    TimeShiftAction.prototype.needsEnvironment = function () {
        return !this.timezone;
    };
    TimeShiftAction.prototype.defineEnvironment = function (environment) {
        if (this.timezone || !environment.timezone)
            return this;
        var value = this.valueOf();
        value.timezone = environment.timezone;
        return new TimeShiftAction(value);
    };
    TimeShiftAction.prototype.getTimezone = function () {
        return this.timezone || Timezone.UTC;
    };
    TimeShiftAction.DEFAULT_STEP = 1;
    return TimeShiftAction;
}(Action));
Action.register(TimeShiftAction);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var TransformCaseAction = exports.TransformCaseAction = (function (_super) {
    __extends(TransformCaseAction, _super);
    function TransformCaseAction(parameters) {
        _super.call(this, parameters, dummyObject);
        var transformType = parameters.transformType;
        if (transformType !== TransformCaseAction.UPPER_CASE && transformType !== TransformCaseAction.LOWER_CASE) {
            throw new Error("Must supply transform type of '" + TransformCaseAction.UPPER_CASE + "' or '" + TransformCaseAction.LOWER_CASE + "'");
        }
        this.transformType = transformType;
        this._ensureAction("transformCase");
    }
    TransformCaseAction.fromJS = function (parameters) {
        var value = Action.jsToValue(parameters);
        value.transformType = parameters.transformType;
        return new TransformCaseAction(value);
    };
    TransformCaseAction.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.transformType = this.transformType;
        return value;
    };
    TransformCaseAction.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.transformType = this.transformType;
        return js;
    };
    TransformCaseAction.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.transformType === other.transformType;
    };
    TransformCaseAction.prototype.getNecessaryInputTypes = function () {
        return 'STRING';
    };
    TransformCaseAction.prototype.getOutputType = function (inputType) {
        this._checkInputTypes(inputType);
        return 'STRING';
    };
    TransformCaseAction.prototype._fillRefSubstitutions = function (typeContext, inputType, indexer, alterations) {
        return inputType;
    };
    TransformCaseAction.prototype._foldWithPrevAction = function (prevAction) {
        if (prevAction instanceof TransformCaseAction) {
            return this;
        }
        return null;
    };
    TransformCaseAction.prototype._getFnHelper = function (inputType, inputFn) {
        var transformType = this.transformType;
        return function (d, c) {
            return transformType === TransformCaseAction.UPPER_CASE ? inputFn(d, c).toLocaleUpperCase() : inputFn(d, c).toLocaleLowerCase();
        };
    };
    TransformCaseAction.prototype._getJSHelper = function (inputType, inputJS, expressionJS) {
        var transformType = this.transformType;
        return transformType === TransformCaseAction.UPPER_CASE ? inputJS + ".toLocaleUpperCase()" : inputJS + ".toLocaleLowerCase()";
    };
    TransformCaseAction.prototype._getSQLHelper = function (inputType, dialect, inputSQL) {
        var transformType = this.transformType;
        return transformType === TransformCaseAction.UPPER_CASE ? "UPPER(" + inputSQL + ")" : "LOWER(" + inputSQL + ")";
    };
    TransformCaseAction.UPPER_CASE = 'upperCase';
    TransformCaseAction.LOWER_CASE = 'lowerCase';
    return TransformCaseAction;
}(Action));
Action.register(TransformCaseAction);
var basicExecutorFactory = exports.basicExecutorFactory = function(parameters) {
    var datasets = parameters.datasets;
    return function (ex, env) {
        if (env === void 0) { env = {}; }
        return ex.compute(datasets, env);
    };
}
Expression.expressionParser = require("./expressionParser")(exports, Chronoshift);
Expression.plyqlParser = require("./plyqlParser")(exports, Chronoshift);

var helper = {};
function addHasMoved(name, fn) {
  helper[name] = function() {
    console.warn(name + ' has moved, please update your code');
    return fn.apply(this, arguments);
  };
}

addHasMoved('parseJSON', Dataset.parseJSON);
addHasMoved('find', find);
addHasMoved('findIndex', findIndex);
addHasMoved('findByName', findByName);
addHasMoved('findIndexByName', findIndexByName);
addHasMoved('overrideByName', overrideByName);
addHasMoved('overridesByName', overridesByName);
addHasMoved('shallowCopy', shallowCopy);
addHasMoved('deduplicateSort', deduplicateSort);
addHasMoved('mapLookup', mapLookup);
addHasMoved('emptyLookup', emptyLookup);
addHasMoved('nonEmptyLookup', nonEmptyLookup);
addHasMoved('verboseRequesterFactory', verboseRequesterFactory);
addHasMoved('retryRequesterFactory', retryRequesterFactory);
addHasMoved('concurrentLimitRequesterFactory', concurrentLimitRequesterFactory);
addHasMoved('promiseWhile', promiseWhile);

exports.helper = helper;




},{"./expressionParser":1,"./plyqlParser":2,"chronoshift":4,"immutable-class":7,"q":10}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var walltimeRepack = require('walltime-repack');
var immutableClass = require('immutable-class');

var Timezone = (function () {
    function Timezone(timezone) {
        if (typeof timezone !== 'string') {
            throw new TypeError("timezone description must be a string");
        }
        if (timezone !== 'Etc/UTC') {
            walltimeRepack.WallTime.UTCToWallTime(new Date(0), timezone);
        }
        this.timezone = timezone;
    }
    Timezone.isTimezone = function (candidate) {
        return immutableClass.isInstanceOf(candidate, Timezone);
    };
    Timezone.fromJS = function (spec) {
        return new Timezone(spec);
    };
    Timezone.prototype.valueOf = function () {
        return this.timezone;
    };
    Timezone.prototype.toJS = function () {
        return this.timezone;
    };
    Timezone.prototype.toJSON = function () {
        return this.timezone;
    };
    Timezone.prototype.toString = function () {
        return this.timezone;
    };
    Timezone.prototype.equals = function (other) {
        return Timezone.isTimezone(other) &&
            this.timezone === other.timezone;
    };
    Timezone.prototype.isUTC = function () {
        return this.timezone === 'Etc/UTC';
    };
    Timezone.UTC = new Timezone('Etc/UTC');
    return Timezone;
}());

function adjustDay(day) {
    return (day + 6) % 7;
}
function floorTo(n, roundTo) {
    return Math.floor(n / roundTo) * roundTo;
}
function timeShifterFiller(tm) {
    var floor = tm.floor, shift = tm.shift;
    tm.ceil = function (dt, tz) {
        var floored = floor(dt, tz);
        if (floored.valueOf() === dt.valueOf())
            return dt;
        return shift(floored, tz, 1);
    };
    tm.move = tm.shift;
    return tm;
}
var second = timeShifterFiller({
    canonicalLength: 1000,
    siblings: 60,
    floor: function (dt, tz) {
        dt = new Date(dt.valueOf());
        dt.setUTCMilliseconds(0);
        return dt;
    },
    round: function (dt, roundTo, tz) {
        var cur = dt.getUTCSeconds();
        var adj = floorTo(cur, roundTo);
        if (cur !== adj)
            dt.setUTCSeconds(adj);
        return dt;
    },
    shift: function (dt, tz, step) {
        dt = new Date(dt.valueOf());
        dt.setUTCSeconds(dt.getUTCSeconds() + step);
        return dt;
    }
});
var minute = timeShifterFiller({
    canonicalLength: 60000,
    siblings: 60,
    floor: function (dt, tz) {
        dt = new Date(dt.valueOf());
        dt.setUTCSeconds(0, 0);
        return dt;
    },
    round: function (dt, roundTo, tz) {
        var cur = dt.getUTCMinutes();
        var adj = floorTo(cur, roundTo);
        if (cur !== adj)
            dt.setUTCMinutes(adj);
        return dt;
    },
    shift: function (dt, tz, step) {
        dt = new Date(dt.valueOf());
        dt.setUTCMinutes(dt.getUTCMinutes() + step);
        return dt;
    }
});
function hourMove(dt, tz, step) {
    if (tz.isUTC()) {
        dt = new Date(dt.valueOf());
        dt.setUTCHours(dt.getUTCHours() + step);
    }
    else {
        var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
        dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate(), wt.getHours() + step, wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
    }
    return dt;
}
var hour = timeShifterFiller({
    canonicalLength: 3600000,
    siblings: 24,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCMinutes(0, 0, 0);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate(), wt.getHours(), 0, 0, 0);
        }
        return dt;
    },
    round: function (dt, roundTo, tz) {
        if (tz.isUTC()) {
            var cur = dt.getUTCHours();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                dt.setUTCHours(adj);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            var cur = wt.getHours();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                return hourMove(dt, tz, adj - cur);
        }
        return dt;
    },
    shift: hourMove
});
var day = timeShifterFiller({
    canonicalLength: 24 * 3600000,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCHours(0, 0, 0, 0);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate(), 0, 0, 0, 0);
        }
        return dt;
    },
    shift: function (dt, tz, step) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCDate(dt.getUTCDate() + step);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate() + step, wt.getHours(), wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
        }
        return dt;
    }
});
var week = timeShifterFiller({
    canonicalLength: 7 * 24 * 3600000,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCHours(0, 0, 0, 0);
            dt.setUTCDate(dt.getUTCDate() - adjustDay(dt.getUTCDay()));
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate() - adjustDay(wt.getDay()), 0, 0, 0, 0);
        }
        return dt;
    },
    shift: function (dt, tz, step) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCDate(dt.getUTCDate() + step * 7);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate() + step * 7, wt.getHours(), wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
        }
        return dt;
    }
});
function monthShift(dt, tz, step) {
    if (tz.isUTC()) {
        dt = new Date(dt.valueOf());
        dt.setUTCMonth(dt.getUTCMonth() + step);
    }
    else {
        var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
        dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth() + step, wt.getDate(), wt.getHours(), wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
    }
    return dt;
}
var month = timeShifterFiller({
    canonicalLength: 30 * 24 * 3600000,
    siblings: 12,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCHours(0, 0, 0, 0);
            dt.setUTCDate(1);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), 1, 0, 0, 0, 0);
        }
        return dt;
    },
    round: function (dt, roundTo, tz) {
        if (tz.isUTC()) {
            var cur = dt.getUTCMonth();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                dt.setUTCMonth(adj);
        }
        else {
            var cur = dt.getMonth();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                return monthShift(dt, tz, adj - cur);
        }
        return dt;
    },
    shift: monthShift
});
function yearShift(dt, tz, step) {
    if (tz.isUTC()) {
        dt = new Date(dt.valueOf());
        dt.setUTCFullYear(dt.getUTCFullYear() + step);
    }
    else {
        var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
        dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear() + step, wt.getMonth(), wt.getDate(), wt.getHours(), wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
    }
    return dt;
}
var year = timeShifterFiller({
    canonicalLength: 365 * 24 * 3600000,
    siblings: 1000,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCHours(0, 0, 0, 0);
            dt.setUTCMonth(0, 1);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), 0, 1, 0, 0, 0, 0);
        }
        return dt;
    },
    round: function (dt, roundTo, tz) {
        if (tz.isUTC()) {
            var cur = dt.getUTCFullYear();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                dt.setUTCFullYear(adj);
        }
        else {
            var cur = dt.getFullYear();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                return yearShift(dt, tz, adj - cur);
        }
        return dt;
    },
    shift: yearShift
});
var shifters = {
    second: second,
    minute: minute,
    hour: hour,
    day: day,
    week: week,
    month: month,
    year: year
};

var spansWithWeek = ["year", "month", "week", "day", "hour", "minute", "second"];
var spansWithoutWeek = ["year", "month", "day", "hour", "minute", "second"];
function capitalizeFirst(str) {
    if (!str.length)
        return str;
    return str[0].toUpperCase() + str.substr(1);
}
var periodWeekRegExp = /^P(\d+)W$/;
var periodRegExp = /^P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?)?$/;
function getSpansFromString(durationStr) {
    var spans = {};
    var matches;
    if (matches = periodWeekRegExp.exec(durationStr)) {
        spans.week = Number(matches[1]);
        if (!spans.week)
            throw new Error("Duration can not be empty");
    }
    else if (matches = periodRegExp.exec(durationStr)) {
        var nums = matches.map(Number);
        for (var i = 0; i < spansWithoutWeek.length; i++) {
            var span = spansWithoutWeek[i];
            var value = nums[i + 1];
            if (value)
                spans[span] = value;
        }
    }
    else {
        throw new Error("Can not parse duration '" + durationStr + "'");
    }
    return spans;
}
function getSpansFromStartEnd(start, end, timezone) {
    start = second.floor(start, timezone);
    end = second.floor(end, timezone);
    if (end <= start)
        throw new Error("start must come before end");
    var spans = {};
    var iterator = start;
    for (var i = 0; i < spansWithoutWeek.length; i++) {
        var span = spansWithoutWeek[i];
        var spanCount = 0;
        var length = end.valueOf() - iterator.valueOf();
        var canonicalLength = shifters[span].canonicalLength;
        if (length < canonicalLength / 4)
            continue;
        var numberToFit = Math.min(0, Math.floor(length / canonicalLength) - 1);
        var iteratorMove;
        if (numberToFit > 0) {
            iteratorMove = shifters[span].shift(iterator, timezone, numberToFit);
            if (iteratorMove <= end) {
                spanCount += numberToFit;
                iterator = iteratorMove;
            }
        }
        while (true) {
            iteratorMove = shifters[span].shift(iterator, timezone, 1);
            if (iteratorMove <= end) {
                iterator = iteratorMove;
                spanCount++;
            }
            else {
                break;
            }
        }
        if (spanCount) {
            spans[span] = spanCount;
        }
    }
    return spans;
}
function removeZeros(spans) {
    var newSpans = {};
    for (var i = 0; i < spansWithWeek.length; i++) {
        var span = spansWithWeek[i];
        if (spans[span] > 0) {
            newSpans[span] = spans[span];
        }
    }
    return newSpans;
}
var Duration = (function () {
    function Duration(spans, end, timezone) {
        if (spans && end && timezone) {
            spans = getSpansFromStartEnd(spans, end, timezone);
        }
        else if (typeof spans === 'object') {
            spans = removeZeros(spans);
        }
        else {
            throw new Error("new Duration called with bad argument");
        }
        var usedSpans = Object.keys(spans);
        if (!usedSpans.length)
            throw new Error("Duration can not be empty");
        if (usedSpans.length === 1) {
            this.singleSpan = usedSpans[0];
        }
        else if (spans.week) {
            throw new Error("Can not mix 'week' and other spans");
        }
        this.spans = spans;
    }
    Duration.fromJS = function (durationStr) {
        if (typeof durationStr !== 'string')
            throw new TypeError("Duration JS must be a string");
        return new Duration(getSpansFromString(durationStr));
    };
    Duration.fromCanonicalLength = function (length) {
        var spans = {};
        for (var i = 0; i < spansWithWeek.length; i++) {
            var span = spansWithWeek[i];
            var spanLength = shifters[span].canonicalLength;
            var count = Math.floor(length / spanLength);
            length -= spanLength * count;
            spans[span] = count;
        }
        return new Duration(spans);
    };
    Duration.isDuration = function (candidate) {
        return immutableClass.isInstanceOf(candidate, Duration);
    };
    Duration.prototype.toString = function () {
        var strArr = ["P"];
        var spans = this.spans;
        if (spans.week) {
            strArr.push(String(spans.week), 'W');
        }
        else {
            var addedT = false;
            for (var i = 0; i < spansWithoutWeek.length; i++) {
                var span = spansWithoutWeek[i];
                var value = spans[span];
                if (!value)
                    continue;
                if (!addedT && i >= 3) {
                    strArr.push("T");
                    addedT = true;
                }
                strArr.push(String(value), span[0].toUpperCase());
            }
        }
        return strArr.join("");
    };
    Duration.prototype.add = function (duration) {
        return Duration.fromCanonicalLength(this.getCanonicalLength() + duration.getCanonicalLength());
    };
    Duration.prototype.subtract = function (duration) {
        var newCanonicalDuration = this.getCanonicalLength() - duration.getCanonicalLength();
        if (newCanonicalDuration < 0)
            throw new Error("A duration can not be negative.");
        return Duration.fromCanonicalLength(newCanonicalDuration);
    };
    Duration.prototype.valueOf = function () {
        return this.spans;
    };
    Duration.prototype.toJS = function () {
        return this.toString();
    };
    Duration.prototype.toJSON = function () {
        return this.toString();
    };
    Duration.prototype.equals = function (other) {
        return Boolean(other) &&
            this.toString() === other.toString();
    };
    Duration.prototype.isSimple = function () {
        var singleSpan = this.singleSpan;
        if (!singleSpan)
            return false;
        return this.spans[singleSpan] === 1;
    };
    Duration.prototype.isFloorable = function () {
        var singleSpan = this.singleSpan;
        if (!singleSpan)
            return false;
        var span = this.spans[singleSpan];
        if (span === 1)
            return true;
        var siblings = shifters[singleSpan].siblings;
        if (!siblings)
            return false;
        return siblings % span === 0;
    };
    Duration.prototype.floor = function (date, timezone) {
        var singleSpan = this.singleSpan;
        if (!singleSpan)
            throw new Error("Can not floor on a complex duration");
        var span = this.spans[singleSpan];
        var mover = shifters[singleSpan];
        var dt = mover.floor(date, timezone);
        if (span !== 1) {
            if (!mover.siblings)
                throw new Error("Can not floor on a " + singleSpan + " duration that is not 1");
            if (mover.siblings % span !== 0)
                throw new Error("Can not floor on a " + singleSpan + " duration that does not divide into " + mover.siblings);
            dt = mover.round(dt, span, timezone);
        }
        return dt;
    };
    Duration.prototype.shift = function (date, timezone, step) {
        if (step === void 0) { step = 1; }
        var spans = this.spans;
        for (var _i = 0, spansWithWeek_1 = spansWithWeek; _i < spansWithWeek_1.length; _i++) {
            var span = spansWithWeek_1[_i];
            var value = spans[span];
            if (value)
                date = shifters[span].shift(date, timezone, step * value);
        }
        return date;
    };
    Duration.prototype.materialize = function (start, end, timezone, step) {
        if (step === void 0) { step = 1; }
        var values = [];
        var iter = this.floor(start, timezone);
        while (iter <= end) {
            values.push(iter);
            iter = this.shift(iter, timezone, step);
        }
        return values;
    };
    Duration.prototype.isAligned = function (date, timezone) {
        return this.floor(date, timezone).valueOf() === date.valueOf();
    };
    Duration.prototype.dividesBy = function (smaller) {
        var myCanonicalLength = this.getCanonicalLength();
        var smallerCanonicalLength = smaller.getCanonicalLength();
        return myCanonicalLength % smallerCanonicalLength === 0 && this.isFloorable() && smaller.isFloorable();
    };
    Duration.prototype.getCanonicalLength = function () {
        var spans = this.spans;
        var length = 0;
        for (var _i = 0, spansWithWeek_2 = spansWithWeek; _i < spansWithWeek_2.length; _i++) {
            var span = spansWithWeek_2[_i];
            var value = spans[span];
            if (value)
                length += value * shifters[span].canonicalLength;
        }
        return length;
    };
    Duration.prototype.getDescription = function (capitalize) {
        var spans = this.spans;
        var description = [];
        for (var _i = 0, spansWithWeek_3 = spansWithWeek; _i < spansWithWeek_3.length; _i++) {
            var span = spansWithWeek_3[_i];
            var value = spans[span];
            var spanTitle = capitalize ? capitalizeFirst(span) : span;
            if (value) {
                if (value === 1) {
                    description.push(spanTitle);
                }
                else {
                    description.push(String(value) + ' ' + spanTitle + 's');
                }
            }
        }
        return description.join(', ');
    };
    Duration.prototype.getSingleSpan = function () {
        return this.singleSpan || null;
    };
    Duration.prototype.getSingleSpanValue = function () {
        if (!this.singleSpan)
            return null;
        return this.spans[this.singleSpan] || null;
    };
    return Duration;
}());

function parseYear(v) {
    if (v.length === 2) {
        var vn = parseInt(v, 10);
        return (vn < 70 ? 2000 : 1900) + vn;
    }
    else if (v.length === 4) {
        return parseInt(v, 10);
    }
    else {
        throw new Error('Invalid year in date');
    }
}
function parseMonth(v) {
    var vn = parseInt(v, 10);
    if (vn <= 0 || 12 < vn)
        throw new Error('Invalid month in date');
    return vn - 1;
}
function parseDay(v) {
    var vn = parseInt(v, 10);
    if (vn <= 0 || 31 < vn)
        throw new Error('Invalid day in date');
    return vn;
}
function parseHour(v) {
    var vn = parseInt(v, 10);
    if (vn < 0 || 24 < vn)
        throw new Error('Invalid hour in date');
    return vn;
}
function parseMinute(v) {
    var vn = parseInt(v, 10);
    if (vn < 0 || 60 < vn)
        throw new Error('Invalid minute in date');
    return vn;
}
function parseSecond(v) {
    var vn = parseInt(v, 10);
    if (vn < 0 || 60 < vn)
        throw new Error('Invalid second in date');
    return vn;
}
function parseMillisecond(v) {
    if (!v)
        return 0;
    return parseInt(v.substr(0, 3), 10);
}
function parseSQLDate(type, v) {
    if (type === 't')
        throw new Error('time literals are not supported');
    var m;
    var d;
    if (type === 'ts') {
        if (m = v.match(/^(\d{2}(?:\d{2})?)(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})$/)) {
            d = Date.UTC(parseYear(m[1]), parseMonth(m[2]), parseDay(m[3]), parseHour(m[4]), parseMinute(m[5]), parseSecond(m[6]));
        }
        else if (m = v.match(/^(\d{2}(?:\d{2})?)[~!@#$%^&*()_+=:.\-\/](\d{1,2})[~!@#$%^&*()_+=:.\-\/](\d{1,2})[T ](\d{1,2})[~!@#$%^&*()_+=:.\-\/](\d{1,2})[~!@#$%^&*()_+=:.\-\/](\d{1,2})(?:\.(\d{1,6}))?$/)) {
            d = Date.UTC(parseYear(m[1]), parseMonth(m[2]), parseDay(m[3]), parseHour(m[4]), parseMinute(m[5]), parseSecond(m[6]), parseMillisecond(m[7]));
        }
        else {
            throw new Error('Invalid timestamp');
        }
    }
    else {
        if (m = v.match(/^(\d{2}(?:\d{2})?)(\d{2})(\d{2})$/)) {
            d = Date.UTC(parseYear(m[1]), parseMonth(m[2]), parseDay(m[3]));
        }
        else if (m = v.match(/^(\d{2}(?:\d{2})?)[~!@#$%^&*()_+=:.\-\/](\d{1,2})[~!@#$%^&*()_+=:.\-\/](\d{1,2})$/)) {
            d = Date.UTC(parseYear(m[1]), parseMonth(m[2]), parseDay(m[3]));
        }
        else {
            throw new Error('Invalid date');
        }
    }
    return new Date(d);
}
var numericKeys = [1, 4, 5, 6, 10, 11];
function parseISODate(date, timezone) {
    if (timezone === void 0) { timezone = Timezone.UTC; }
    var struct;
    var minutesOffset = 0;
    if ((struct = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2})(?::?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?)?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?$/.exec(date))) {
        for (var i = 0, k; (k = numericKeys[i]); ++i) {
            struct[k] = +struct[k] || 0;
        }
        struct[2] = (+struct[2] || 1) - 1;
        struct[3] = +struct[3] || 1;
        struct[7] = struct[7] ? +(struct[7] + "00").substr(0, 3) : 0;
        if ((struct[8] === undefined || struct[8] === '') && (struct[9] === undefined || struct[9] === '') && !Timezone.UTC.equals(timezone)) {
            if (timezone === null) {
                return new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
            }
            else {
                return walltimeRepack.WallTime.WallTimeToUTC(timezone.toString(), struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
            }
        }
        else {
            if (struct[8] !== 'Z' && struct[9] !== undefined) {
                minutesOffset = struct[10] * 60 + struct[11];
                if (struct[9] === '+') {
                    minutesOffset = 0 - minutesOffset;
                }
            }
            return new Date(Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]));
        }
    }
    else {
        return null;
    }
}
function parseInterval(str, timezone, now) {
    if (timezone === void 0) { timezone = Timezone.UTC; }
    if (now === void 0) { now = new Date(); }
    var parts = str.split('/');
    if (parts.length > 2)
        throw new Error("Can not parse string " + str);
    var start = null;
    var end = null;
    var duration = null;
    var p0 = parts[0];
    if (parts.length === 1) {
        duration = Duration.fromJS(p0);
    }
    else {
        var p1 = parts[1];
        if (p0[0] === 'P') {
            duration = Duration.fromJS(p0);
            end = parseISODate(p1, timezone);
            if (!end)
                throw new Error("can not parse '" + p1 + "' as ISO date");
        }
        else if (p1[0] === 'P') {
            start = parseISODate(p0, timezone);
            if (!start)
                throw new Error("can not parse '" + p0 + "' as ISO date");
            duration = Duration.fromJS(p1);
        }
        else {
            start = parseISODate(p0, timezone);
            if (!start)
                throw new Error("can not parse '" + p0 + "' as ISO date");
            end = parseISODate(p1, timezone);
            if (!end)
                throw new Error("can not parse '" + p1 + "' as ISO date");
            if (end < start) {
                throw new Error("start must be <= end in '" + str + "'");
            }
        }
    }
    var computedStart;
    var computedEnd;
    if (start) {
        computedStart = start;
        if (duration) {
            computedEnd = duration.shift(computedStart, timezone, 1);
        }
        else {
            computedEnd = end;
        }
    }
    else {
        computedEnd = end || now;
        computedStart = duration.shift(computedEnd, timezone, -1);
    }
    return {
        computedStart: computedStart,
        computedEnd: computedEnd,
        start: start,
        end: end,
        duration: duration
    };
}

function isDate(d) {
    return !!(d && d.toISOString);
}

var WallTime$1 = walltimeRepack.WallTime;

exports.WallTime = WallTime$1;
exports.parseSQLDate = parseSQLDate;
exports.parseISODate = parseISODate;
exports.parseInterval = parseInterval;
exports.second = second;
exports.minute = minute;
exports.hour = hour;
exports.day = day;
exports.week = week;
exports.month = month;
exports.year = year;
exports.shifters = shifters;
exports.Timezone = Timezone;
exports.Duration = Duration;
exports.isDate = isDate;
},{"immutable-class":7,"walltime-repack":11}],5:[function(require,module,exports){
"use strict";
var utils_1 = require('../utils/utils');
var equality_1 = require('../equality/equality');
function firstUp(name) {
    return name[0].toUpperCase() + name.substr(1);
}
var BaseImmutable = (function () {
    function BaseImmutable(value) {
        var properties = this.ownProperties();
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            var propertyName = property.name;
            var pv = value[propertyName];
            if (!property.optional && pv == null) {
                throw new Error(this.constructor.name + "." + propertyName + " must be defined");
            }
            var possibleValues = property.possibleValues;
            if (possibleValues && possibleValues.indexOf(pv) === -1) {
                throw new Error(this.constructor.name + "." + propertyName + " can not have value '" + pv + "' must be one of [" + possibleValues.join(', ') + "]");
            }
            if (property.validate) {
                try {
                    property.validate(pv);
                }
                catch (e) {
                    throw new Error(this.constructor.name + "." + propertyName + " " + e.message);
                }
            }
            this[propertyName] = pv;
        }
    }
    BaseImmutable.jsToValue = function (properties, js) {
        var value = {};
        for (var _i = 0, properties_2 = properties; _i < properties_2.length; _i++) {
            var property = properties_2[_i];
            var propertyName = property.name;
            var propertyImmutableClass = property.immutableClass;
            var pv = js[propertyName];
            value[propertyName] = pv ? (propertyImmutableClass ? propertyImmutableClass.fromJS(pv) : pv) : null;
        }
        return value;
    };
    BaseImmutable.finalize = function (ClassFn) {
        var proto = ClassFn.prototype;
        ClassFn.PROPERTIES.forEach(function (property) {
            var propertyName = property.name;
            var upped = firstUp(property.name);
            proto['get' + upped] = function () {
                return this.get(propertyName);
            };
            proto['change' + upped] = function (newValue) {
                return this.change(propertyName, newValue);
            };
        });
    };
    BaseImmutable.prototype.ownProperties = function () {
        return this.constructor.PROPERTIES;
    };
    BaseImmutable.prototype.findOwnProperty = function (propName) {
        var properties = this.ownProperties();
        return properties.filter(function (p) { return p.name === propName; })[0] || null;
    };
    BaseImmutable.prototype.valueOf = function () {
        var value = {};
        var properties = this.ownProperties();
        for (var _i = 0, properties_3 = properties; _i < properties_3.length; _i++) {
            var property = properties_3[_i];
            var propertyName = property.name;
            value[propertyName] = this[propertyName];
        }
        return value;
    };
    BaseImmutable.prototype.toJS = function () {
        var js = {};
        var properties = this.ownProperties();
        for (var _i = 0, properties_4 = properties; _i < properties_4.length; _i++) {
            var property = properties_4[_i];
            var propertyName = property.name;
            var propertyImmutableClass = property.immutableClass;
            var pv = this[propertyName];
            if (pv != null)
                js[propertyName] = propertyImmutableClass ? pv.toJS() : pv;
        }
        return js;
    };
    BaseImmutable.prototype.toJSON = function () {
        return this.toJS();
    };
    BaseImmutable.prototype.toString = function () {
        var name = this.name;
        var extra = name === 'string' ? ": " + name : '';
        return "[ImmutableClass" + extra + "]";
    };
    BaseImmutable.prototype.equals = function (other) {
        if (!other)
            return false;
        if (this === other)
            return true;
        if (!utils_1.isInstanceOf(other, this.constructor))
            return false;
        var properties = this.ownProperties();
        for (var _i = 0, properties_5 = properties; _i < properties_5.length; _i++) {
            var property = properties_5[_i];
            var propertyName = property.name;
            var equal = property.equal || equality_1.generalEqual;
            if (!equal(this[propertyName], other[propertyName]))
                return false;
        }
        return true;
    };
    BaseImmutable.prototype.get = function (propName) {
        var properties = this.ownProperties();
        for (var _i = 0, properties_6 = properties; _i < properties_6.length; _i++) {
            var property = properties_6[_i];
            if (property.name === propName) {
                return this[propName] || property.defaultValue;
            }
        }
        throw new Error("can not find prop " + propName);
    };
    BaseImmutable.prototype.change = function (propName, newValue) {
        var value = this.valueOf();
        var property = this.findOwnProperty(propName);
        if (!property) {
            throw new Error("Unknown property: " + propName);
        }
        value[propName] = newValue;
        return new this.constructor(value);
    };
    return BaseImmutable;
}());
exports.BaseImmutable = BaseImmutable;

},{"../equality/equality":6,"../utils/utils":8}],6:[function(require,module,exports){
"use strict";
function generalEqual(a, b) {
    if (a === b)
        return true;
    if (a && b) {
        if (typeof a.toISOString === 'function' && typeof b.toISOString === 'function') {
            return a.valueOf() === b.valueOf();
        }
        if (Array.isArray(a) && Array.isArray(b)) {
            return generalArraysEqual(a, b);
        }
        if (typeof a.equals === 'function') {
            return a.equals(b);
        }
    }
    return false;
}
exports.generalEqual = generalEqual;
function immutableEqual(a, b) {
    if (a === b)
        return true;
    return Boolean(a) && a.equals(b);
}
exports.immutableEqual = immutableEqual;
function generalArraysEqual(arrayA, arrayB) {
    if (arrayA === arrayB)
        return true;
    if (!arrayA !== !arrayB)
        return false;
    var length = arrayA.length;
    if (length !== arrayB.length)
        return false;
    for (var i = 0; i < length; i++) {
        if (!generalEqual(arrayA[i], arrayB[i]))
            return false;
    }
    return true;
}
exports.generalArraysEqual = generalArraysEqual;
function immutableArraysEqual(arrayA, arrayB) {
    if (arrayA === arrayB)
        return true;
    if (!arrayA !== !arrayB)
        return false;
    var length = arrayA.length;
    if (length !== arrayB.length)
        return false;
    for (var i = 0; i < length; i++) {
        if (!immutableEqual(arrayA[i], arrayB[i]))
            return false;
    }
    return true;
}
exports.immutableArraysEqual = immutableArraysEqual;
function generalLookupsEqual(lookupA, lookupB) {
    if (lookupA === lookupB)
        return true;
    if (!lookupA !== !lookupB)
        return false;
    var keysA = Object.keys(lookupA);
    var keysB = Object.keys(lookupB);
    if (keysA.length !== keysB.length)
        return false;
    for (var _i = 0, keysA_1 = keysA; _i < keysA_1.length; _i++) {
        var k = keysA_1[_i];
        if (!generalEqual(lookupA[k], lookupB[k]))
            return false;
    }
    return true;
}
exports.generalLookupsEqual = generalLookupsEqual;
function immutableLookupsEqual(lookupA, lookupB) {
    if (lookupA === lookupB)
        return true;
    if (!lookupA !== !lookupB)
        return false;
    var keysA = Object.keys(lookupA);
    var keysB = Object.keys(lookupB);
    if (keysA.length !== keysB.length)
        return false;
    for (var _i = 0, keysA_2 = keysA; _i < keysA_2.length; _i++) {
        var k = keysA_2[_i];
        if (!immutableEqual(lookupA[k], lookupB[k]))
            return false;
    }
    return true;
}
exports.immutableLookupsEqual = immutableLookupsEqual;

},{}],7:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./utils/utils'));
__export(require('./equality/equality'));
__export(require('./base-immutable/base-immutable'));

},{"./base-immutable/base-immutable":5,"./equality/equality":6,"./utils/utils":8}],8:[function(require,module,exports){
"use strict";
function isInstanceOf(thing, constructor) {
    if (typeof constructor !== 'function')
        throw new TypeError("constructor must be a function");
    if (thing instanceof constructor)
        return true;
    if (thing == null)
        return false;
    var constructorName = constructor.name;
    if (!constructorName)
        return false;
    var thingProto = thing.__proto__;
    while (thingProto && thingProto.constructor) {
        if (thingProto.constructor.name === constructorName)
            return true;
        thingProto = thingProto.__proto__;
    }
    return false;
}
exports.isInstanceOf = isInstanceOf;
function isArrayOf(things, constructor) {
    if (!Array.isArray(things))
        return false;
    for (var i = 0, length = things.length; i < length; i++) {
        if (!isInstanceOf(things[i], constructor))
            return false;
    }
    return true;
}
exports.isArrayOf = isArrayOf;
function isImmutableClass(thing) {
    if (!thing || typeof thing !== 'object')
        return false;
    var ClassFn = thing.constructor;
    return typeof ClassFn.fromJS === 'function' &&
        typeof thing.toJS === 'function' &&
        typeof thing.equals === 'function';
}
exports.isImmutableClass = isImmutableClass;

},{}],9:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
    try {
        cachedSetTimeout = setTimeout;
    } catch (e) {
        cachedSetTimeout = function () {
            throw new Error('setTimeout is not defined');
        }
    }
    try {
        cachedClearTimeout = clearTimeout;
    } catch (e) {
        cachedClearTimeout = function () {
            throw new Error('clearTimeout is not defined');
        }
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],10:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'))
},{"_process":9}],11:[function(require,module,exports){
/*
 *  WallTime 0.1.2
 *  Copyright (c) 2013 Sprout Social, Inc.
 *  Available under the MIT License (http://bit.ly/walltime-license)
 */

(function() {
  var Days, Milliseconds, Months, Time, helpers, _base;

  (_base = Array.prototype).indexOf || (_base.indexOf = function(item) {
    var i, x, _i, _len;
    for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
      x = this[i];
      if (x === item) {
        return i;
      }
    }
    return -1;
  });

  Days = {
    DayShortNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    DayIndex: function(name) {
      return this.DayShortNames.indexOf(name);
    },
    DayNameFromIndex: function(dayIdx) {
      return this.DayShortNames[dayIdx];
    },
    AddToDate: function(dt, days) {
      return Time.MakeDateFromTimeStamp(dt.getTime() + (days * Milliseconds.inDay));
    }
  };

  Months = {
    MonthsShortNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    CompareRuleMatch: new RegExp("([a-zA-Z]*)([\\<\\>]?=)([0-9]*)"),
    MonthIndex: function(shortName) {
      return this.MonthsShortNames.indexOf(shortName.slice(0, 3));
    },
    IsDayOfMonthRule: function(str) {
      return str.indexOf(">") > -1 || str.indexOf("<") > -1 || str.indexOf("=") > -1;
    },
    IsLastDayOfMonthRule: function(str) {
      return str.slice(0, 4) === "last";
    },
    DayOfMonthByRule: function(str, year, month) {
      var compareFunc, compares, dateIndex, dayIndex, dayName, ruleParse, testDate, testPart, _ref;
      ruleParse = this.CompareRuleMatch.exec(str);
      if (!ruleParse) {
        throw new Error("Unable to parse the 'on' rule for " + str);
      }
      _ref = ruleParse.slice(1, 4), dayName = _ref[0], testPart = _ref[1], dateIndex = _ref[2];
      dateIndex = parseInt(dateIndex, 10);
      if (dateIndex === NaN) {
        throw new Error("Unable to parse the dateIndex of the 'on' rule for " + str);
      }
      dayIndex = helpers.Days.DayIndex(dayName);
      compares = {
        ">=": function(a, b) {
          return a >= b;
        },
        "<=": function(a, b) {
          return a <= b;
        },
        ">": function(a, b) {
          return a > b;
        },
        "<": function(a, b) {
          return a < b;
        },
        "=": function(a, b) {
          return a === b;
        }
      };
      compareFunc = compares[testPart];
      if (!compareFunc) {
        throw new Error("Unable to parse the conditional for " + testPart);
      }
      testDate = helpers.Time.MakeDateFromParts(year, month);
      while (!(dayIndex === testDate.getUTCDay() && compareFunc(testDate.getUTCDate(), dateIndex))) {
        testDate = helpers.Days.AddToDate(testDate, 1);
      }
      return testDate.getUTCDate();
    },
    LastDayOfMonthRule: function(str, year, month) {
      var dayIndex, dayName, lastDay;
      dayName = str.slice(4);
      dayIndex = helpers.Days.DayIndex(dayName);
      if (month < 11) {
        lastDay = helpers.Time.MakeDateFromParts(year, month + 1);
      } else {
        lastDay = helpers.Time.MakeDateFromParts(year + 1, 0);
      }
      lastDay = helpers.Days.AddToDate(lastDay, -1);
      while (lastDay.getUTCDay() !== dayIndex) {
        lastDay = helpers.Days.AddToDate(lastDay, -1);
      }
      return lastDay.getUTCDate();
    }
  };

  Milliseconds = {
    inDay: 86400000,
    inHour: 3600000,
    inMinute: 60000,
    inSecond: 1000
  };

  Time = {
    Add: function(dt, hours, mins, secs) {
      var newTs;
      if (hours == null) {
        hours = 0;
      }
      if (mins == null) {
        mins = 0;
      }
      if (secs == null) {
        secs = 0;
      }
      newTs = dt.getTime() + (hours * Milliseconds.inHour) + (mins * Milliseconds.inMinute) + (secs * Milliseconds.inSecond);
      return this.MakeDateFromTimeStamp(newTs);
    },
    ParseGMTOffset: function(str) {
      var isNeg, match, matches, reg, result;
      reg = new RegExp("(-)?([0-9]*):([0-9]*):?([0-9]*)?");
      matches = reg.exec(str);
      result = matches ? (function() {
        var _i, _len, _ref, _results;
        _ref = matches.slice(2);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          match = _ref[_i];
          _results.push(parseInt(match, 10));
        }
        return _results;
      })() : [0, 0, 0];
      isNeg = matches && matches[1] === "-";
      result.splice(0, 0, isNeg);
      return result;
    },
    ParseTime: function(str) {
      var match, matches, qual, reg, timeParts;
      reg = new RegExp("(\\d*)\\:(\\d*)([wsugz]?)");
      matches = reg.exec(str);
      if (!matches) {
        return [0, 0, ''];
      }
      timeParts = (function() {
        var _i, _len, _ref, _results;
        _ref = matches.slice(1, 3);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          match = _ref[_i];
          _results.push(parseInt(match, 10));
        }
        return _results;
      })();
      qual = matches[3] ? matches[3] : '';
      timeParts.push(qual);
      return timeParts;
    },
    ApplyOffset: function(dt, offset, reverse) {
      var offset_ms;
      offset_ms = (Milliseconds.inHour * offset.hours) + (Milliseconds.inMinute * offset.mins) + (Milliseconds.inSecond * offset.secs);
      if (!offset.negative) {
        offset_ms = offset_ms * -1;
      }
      if (reverse) {
        offset_ms = offset_ms * -1;
      }
      return this.MakeDateFromTimeStamp(dt.getTime() + offset_ms);
    },
    ApplySave: function(dt, save, reverse) {
      if (reverse !== true) {
        reverse = false;
      }
      return this.ApplyOffset(dt, {
        negative: true,
        hours: save.hours,
        mins: save.mins,
        secs: 0
      }, reverse);
    },
    UTCToWallTime: function(dt, offset, save) {
      var endTime;
      endTime = this.UTCToStandardTime(dt, offset);
      return this.ApplySave(endTime, save);
    },
    UTCToStandardTime: function(dt, offset) {
      return this.ApplyOffset(dt, offset, true);
    },
    UTCToQualifiedTime: function(dt, qualifier, offset, getSave) {
      var endTime;
      endTime = dt;
      switch (qualifier) {
        case "w":
          endTime = this.UTCToWallTime(endTime, offset, getSave());
          break;
        case "s":
          endTime = this.UTCToStandardTime(endTime, offset);
          break;
      }
      return endTime;
    },
    QualifiedTimeToUTC: function(dt, qualifier, offset, getSave) {
      var endTime;
      endTime = dt;
      switch (qualifier) {
        case "w":
          endTime = this.WallTimeToUTC(offset, getSave(), endTime);
          break;
        case "s":
          endTime = this.StandardTimeToUTC(offset, endTime);
          break;
      }
      return endTime;
    },
    StandardTimeToUTC: function(offset, y, m, d, h, mi, s, ms) {
      var dt;
      if (m == null) {
        m = 0;
      }
      if (d == null) {
        d = 1;
      }
      if (h == null) {
        h = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (s == null) {
        s = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      dt = typeof y === "number" ? this.MakeDateFromParts(y, m, d, h, mi, s, ms) : y;
      return this.ApplyOffset(dt, offset);
    },
    WallTimeToUTC: function(offset, save, y, m, d, h, mi, s, ms) {
      var dt;
      if (m == null) {
        m = 0;
      }
      if (d == null) {
        d = 1;
      }
      if (h == null) {
        h = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (s == null) {
        s = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      dt = this.StandardTimeToUTC(offset, y, m, d, h, mi, s, ms);
      return this.ApplySave(dt, save, true);
    },
    MakeDateFromParts: function(y, m, d, h, mi, s, ms) {
      var dt;
      if (m == null) {
        m = 0;
      }
      if (d == null) {
        d = 1;
      }
      if (h == null) {
        h = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (s == null) {
        s = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      if (Date.UTC) {
        return new Date(Date.UTC(y, m, d, h, mi, s, ms));
      }
      dt = new Date;
      dt.setUTCFullYear(y);
      dt.setUTCMonth(m);
      dt.setUTCDate(d);
      dt.setUTCHours(h);
      dt.setUTCMinutes(mi);
      dt.setUTCSeconds(s);
      dt.setUTCMilliseconds(ms);
      return dt;
    },
    LocalDate: function(offset, save, y, m, d, h, mi, s, ms) {
      if (m == null) {
        m = 0;
      }
      if (d == null) {
        d = 1;
      }
      if (h == null) {
        h = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (s == null) {
        s = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      return this.WallTimeToUTC(offset, save, y, m, d, h, mi, s, ms);
    },
    MakeDateFromTimeStamp: function(ts) {
      return new Date(ts);
    },
    MaxDate: function() {
      return this.MakeDateFromTimeStamp(10000000 * 86400000);
    },
    MinDate: function() {
      return this.MakeDateFromTimeStamp(-10000000 * 86400000);
    }
  };

  helpers = {
    Days: Days,
    Months: Months,
    Milliseconds: Milliseconds,
    Time: Time,
    noSave: {
      hours: 0,
      mins: 0
    },
    noZone: {
      offset: {
        negative: false,
        hours: 0,
        mins: 0,
        secs: 0
      },
      name: "UTC"
    }
  };

  this.WallTime || (this.WallTime = {});
  this.WallTime.helpers = helpers;

}).call(this);

(function() {
  var init, req_helpers;

  init = function(helpers) {
    var TimeZoneTime;
    TimeZoneTime = (function() {
      function TimeZoneTime(utc, zone, save) {
        this.utc = utc;
        this.zone = zone;
        this.save = save;
        this.offset = this.zone.offset;
        this.wallTime = helpers.Time.UTCToWallTime(this.utc, this.offset, this.save);
      }

      TimeZoneTime.prototype.getFullYear = function() {
        return this.wallTime.getUTCFullYear();
      };

      TimeZoneTime.prototype.getMonth = function() {
        return this.wallTime.getUTCMonth();
      };

      TimeZoneTime.prototype.getDate = function() {
        return this.wallTime.getUTCDate();
      };

      TimeZoneTime.prototype.getDay = function() {
        return this.wallTime.getUTCDay();
      };

      TimeZoneTime.prototype.getHours = function() {
        return this.wallTime.getUTCHours();
      };

      TimeZoneTime.prototype.getMinutes = function() {
        return this.wallTime.getUTCMinutes();
      };

      TimeZoneTime.prototype.getSeconds = function() {
        return this.wallTime.getUTCSeconds();
      };

      TimeZoneTime.prototype.getMilliseconds = function() {
        return this.wallTime.getUTCMilliseconds();
      };

      TimeZoneTime.prototype.getUTCFullYear = function() {
        return this.utc.getUTCFullYear();
      };

      TimeZoneTime.prototype.getUTCMonth = function() {
        return this.utc.getUTCMonth();
      };

      TimeZoneTime.prototype.getUTCDate = function() {
        return this.utc.getUTCDate();
      };

      TimeZoneTime.prototype.getUTCDay = function() {
        return this.utc.getUTCDay();
      };

      TimeZoneTime.prototype.getUTCHours = function() {
        return this.utc.getUTCHours();
      };

      TimeZoneTime.prototype.getUTCMinutes = function() {
        return this.utc.getUTCMinutes();
      };

      TimeZoneTime.prototype.getUTCSeconds = function() {
        return this.utc.getUTCSeconds();
      };

      TimeZoneTime.prototype.getUTCMilliseconds = function() {
        return this.utc.getUTCMilliseconds();
      };

      TimeZoneTime.prototype.getTime = function() {
        return this.utc.getTime();
      };

      TimeZoneTime.prototype.getTimezoneOffset = function() {
        var base, dst;
        base = (this.offset.hours * 60) + this.offset.mins;
        dst = (this.save.hours * 60) + this.save.mins;
        if (!this.offset.negative) {
          base = -base;
        }
        return base - dst;
      };

      TimeZoneTime.prototype.toISOString = function() {
        return this.utc.toISOString();
      };

      TimeZoneTime.prototype.toUTCString = function() {
        return this.wallTime.toUTCString();
      };

      TimeZoneTime.prototype.toDateString = function() {
        var caps, utcStr;
        utcStr = this.wallTime.toUTCString();
        caps = utcStr.match("([a-zA-Z]*), ([0-9]+) ([a-zA-Z]*) ([0-9]+)");
        return [caps[1], caps[3], caps[2], caps[4]].join(" ");
      };

      TimeZoneTime.prototype.toFormattedTime = function(use24HourTime) {
        var hour, meridiem, min, origHour;
        if (use24HourTime == null) {
          use24HourTime = false;
        }
        hour = origHour = this.getHours();
        if (hour > 12 && !use24HourTime) {
          hour -= 12;
        }
        if (hour === 0) {
          hour = 12;
        }
        min = this.getMinutes();
        if (min < 10) {
          min = "0" + min;
        }
        meridiem = origHour > 11 ? ' PM' : ' AM';
        if (use24HourTime) {
          meridiem = '';
        }
        return "" + hour + ":" + min + meridiem;
      };

      TimeZoneTime.prototype.setTime = function(ms) {
        this.wallTime = helpers.Time.UTCToWallTime(new Date(ms), this.zone.offset, this.save);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setFullYear = function(y) {
        this.wallTime.setUTCFullYear(y);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setMonth = function(m) {
        this.wallTime.setUTCMonth(m);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setDate = function(utcDate) {
        this.wallTime.setUTCDate(utcDate);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setHours = function(hours) {
        this.wallTime.setUTCHours(hours);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setMinutes = function(m) {
        this.wallTime.setUTCMinutes(m);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setSeconds = function(s) {
        this.wallTime.setUTCSeconds(s);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setMilliseconds = function(ms) {
        this.wallTime.setUTCMilliseconds(ms);
        return this._updateUTC();
      };

      TimeZoneTime.prototype._updateUTC = function() {
        this.utc = helpers.Time.WallTimeToUTC(this.offset, this.save, this.getFullYear(), this.getMonth(), this.getDate(), this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds());
        return this.utc.getTime();
      };

      return TimeZoneTime;

    })();
    return TimeZoneTime;
  };

  this.WallTime || (this.WallTime = {});
  this.WallTime.TimeZoneTime = init(this.WallTime.helpers);

}).call(this);

(function() {
  var init, req_TimeZoneTime, req_helpers,
    __hasProp = {}.hasOwnProperty;

  init = function(helpers, TimeZoneTime) {
    var CompareOnFieldHandler, LastOnFieldHandler, NumberOnFieldHandler, Rule, RuleSet, lib;
    NumberOnFieldHandler = (function() {
      function NumberOnFieldHandler() {}

      NumberOnFieldHandler.prototype.applies = function(str) {
        return !isNaN(parseInt(str, 10));
      };

      NumberOnFieldHandler.prototype.parseDate = function(str) {
        return parseInt(str, 10);
      };

      return NumberOnFieldHandler;

    })();
    LastOnFieldHandler = (function() {
      function LastOnFieldHandler() {}

      LastOnFieldHandler.prototype.applies = helpers.Months.IsLastDayOfMonthRule;

      LastOnFieldHandler.prototype.parseDate = function(str, year, month, qualifier, gmtOffset, daylightOffset) {
        return helpers.Months.LastDayOfMonthRule(str, year, month);
      };

      return LastOnFieldHandler;

    })();
    CompareOnFieldHandler = (function() {
      function CompareOnFieldHandler() {}

      CompareOnFieldHandler.prototype.applies = helpers.Months.IsDayOfMonthRule;

      CompareOnFieldHandler.prototype.parseDate = function(str, year, month) {
        return helpers.Months.DayOfMonthByRule(str, year, month);
      };

      return CompareOnFieldHandler;

    })();
    Rule = (function() {
      function Rule(name, _from, _to, type, _in, on, at, _save, letter) {
        var saveHour, saveMinute, toYear, _ref;
        this.name = name;
        this._from = _from;
        this._to = _to;
        this.type = type;
        this["in"] = _in;
        this.on = on;
        this.at = at;
        this._save = _save;
        this.letter = letter;
        this.from = parseInt(this._from, 10);
        this.isMax = false;
        toYear = this.from;
        switch (this._to) {
          case "max":
            toYear = (helpers.Time.MaxDate()).getUTCFullYear();
            this.isMax = true;
            break;
          case "only":
            toYear = this.from;
            break;
          default:
            toYear = parseInt(this._to, 10);
        }
        this.to = toYear;
        _ref = this._parseTime(this._save), saveHour = _ref[0], saveMinute = _ref[1];
        this.save = {
          hours: saveHour,
          mins: saveMinute
        };
      }

      Rule.prototype.forZone = function(offset) {
        this.offset = offset;
        this.fromUTC = helpers.Time.MakeDateFromParts(this.from, 0, 1, 0, 0, 0);
        this.fromUTC = helpers.Time.ApplyOffset(this.fromUTC, offset);
        this.toUTC = helpers.Time.MakeDateFromParts(this.to, 11, 31, 23, 59, 59, 999);
        return this.toUTC = helpers.Time.ApplyOffset(this.toUTC, offset);
      };

      Rule.prototype.setOnUTC = function(year, offset, getPrevSave) {
        var atQualifier, onParsed, toDay, toHour, toMinute, toMonth, _ref,
          _this = this;
        toMonth = helpers.Months.MonthIndex(this["in"]);
        onParsed = parseInt(this.on, 10);
        toDay = !isNaN(onParsed) ? onParsed : this._parseOnDay(this.on, year, toMonth);
        _ref = this._parseTime(this.at), toHour = _ref[0], toMinute = _ref[1], atQualifier = _ref[2];
        this.onUTC = helpers.Time.MakeDateFromParts(year, toMonth, toDay, toHour, toMinute);
        this.onUTC.setUTCMilliseconds(this.onUTC.getUTCMilliseconds() - 1);
        this.atQualifier = atQualifier !== '' ? atQualifier : "w";
        this.onUTC = helpers.Time.QualifiedTimeToUTC(this.onUTC, this.atQualifier, offset, function() {
          return getPrevSave(_this);
        });
        return this.onSort = "" + toMonth + "-" + toDay + "-" + (this.onUTC.getUTCHours()) + "-" + (this.onUTC.getUTCMinutes());
      };

      Rule.prototype.appliesToUTC = function(dt) {
        return (this.fromUTC <= dt && dt <= this.toUTC);
      };

      Rule.prototype._parseOnDay = function(onStr, year, month) {
        var handler, handlers, _i, _len;
        handlers = [new NumberOnFieldHandler, new LastOnFieldHandler, new CompareOnFieldHandler];
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          if (!handler.applies(onStr)) {
            continue;
          }
          return handler.parseDate(onStr, year, month);
        }
        throw new Error("Unable to parse 'on' field for " + this.name + "|" + this._from + "|" + this._to + "|" + onStr);
      };

      Rule.prototype._parseTime = function(atStr) {
        return helpers.Time.ParseTime(atStr);
      };

      return Rule;

    })();
    RuleSet = (function() {
      function RuleSet(rules, timeZone) {
        var beginYears, commonUpdateYearEnds, endYears, max, min, rule, _i, _len, _ref,
          _this = this;
        this.rules = rules != null ? rules : [];
        this.timeZone = timeZone;
        min = null;
        max = null;
        endYears = {};
        beginYears = {};
        _ref = this.rules;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rule = _ref[_i];
          rule.forZone(this.timeZone.offset, function() {
            return helpers.noSave;
          });
          if (min === null || rule.from < min) {
            min = rule.from;
          }
          if (max === null || rule.to > max) {
            max = rule.to;
          }
          endYears[rule.to] = endYears[rule.to] || [];
          endYears[rule.to].push(rule);
          beginYears[rule.from] = beginYears[rule.from] || [];
          beginYears[rule.from].push(rule);
        }
        this.minYear = min;
        this.maxYear = max;
        commonUpdateYearEnds = function(end, years) {
          var lastRule, year, yearRules, _results;
          if (end == null) {
            end = "toUTC";
          }
          if (years == null) {
            years = endYears;
          }
          _results = [];
          for (year in years) {
            if (!__hasProp.call(years, year)) continue;
            rules = years[year];
            yearRules = _this.allThatAppliesTo(rules[0][end]);
            if (yearRules.length < 1) {
              continue;
            }
            rules = _this._sortRulesByOnTime(rules);
            lastRule = yearRules.slice(-1)[0];
            if (lastRule.save.hours === 0 && lastRule.save.mins === 0) {
              continue;
            }
            _results.push((function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
                rule = rules[_j];
                _results1.push(rule[end] = helpers.Time.ApplySave(rule[end], lastRule.save));
              }
              return _results1;
            })());
          }
          return _results;
        };
        commonUpdateYearEnds("toUTC", endYears);
        commonUpdateYearEnds("fromUTC", beginYears);
      }

      RuleSet.prototype.allThatAppliesTo = function(dt) {
        var rule, _i, _len, _ref, _results;
        _ref = this.rules;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rule = _ref[_i];
          if (rule.appliesToUTC(dt)) {
            _results.push(rule);
          }
        }
        return _results;
      };

      RuleSet.prototype.getWallTimeForUTC = function(dt) {
        var appliedRules, getPrevRuleSave, lastSave, rule, rules, _i, _len;
        rules = this.allThatAppliesTo(dt);
        if (rules.length < 1) {
          return new TimeZoneTime(dt, this.timeZone, helpers.noSave);
        }
        rules = this._sortRulesByOnTime(rules);
        getPrevRuleSave = function(r) {
          var idx;
          idx = rules.indexOf(r);
          if (idx < 1) {
            if (rules.length < 1) {
              return helpers.noSave;
            }
            return rules.slice(-1)[0].save;
          }
          return rules[idx - 1].save;
        };
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          rule.setOnUTC(dt.getUTCFullYear(), this.timeZone.offset, getPrevRuleSave);
        }
        appliedRules = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
            rule = rules[_j];
            if (rule.onUTC.getTime() < dt.getTime()) {
              _results.push(rule);
            }
          }
          return _results;
        })();
        lastSave = rules.length < 1 ? helpers.noSave : rules.slice(-1)[0].save;
        if (appliedRules.length > 0) {
          lastSave = appliedRules.slice(-1)[0].save;
        }
        return new TimeZoneTime(dt, this.timeZone, lastSave);
      };

      RuleSet.prototype.getUTCForWallTime = function(dt) {
        var appliedRules, getPrevRuleSave, lastSave, rule, rules, utcStd, _i, _len;
        utcStd = helpers.Time.StandardTimeToUTC(this.timeZone.offset, dt);
        rules = (function() {
          var _i, _len, _ref, _results;
          _ref = this.rules;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rule = _ref[_i];
            if (rule.appliesToUTC(utcStd)) {
              _results.push(rule);
            }
          }
          return _results;
        }).call(this);
        if (rules.length < 1) {
          return utcStd;
        }
        rules = this._sortRulesByOnTime(rules);
        getPrevRuleSave = function(r) {
          var idx;
          idx = rules.indexOf(r);
          if (idx < 1) {
            if (rules.length < 1) {
              return helpers.noSave;
            }
            return rules.slice(-1)[0].save;
          }
          return rules[idx - 1].save;
        };
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          rule.setOnUTC(utcStd.getUTCFullYear(), this.timeZone.offset, getPrevRuleSave);
        }
        appliedRules = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
            rule = rules[_j];
            if (rule.onUTC.getTime() < utcStd.getTime()) {
              _results.push(rule);
            }
          }
          return _results;
        })();
        lastSave = rules.length < 1 ? helpers.noSave : rules.slice(-1)[0].save;
        if (appliedRules.length > 0) {
          lastSave = appliedRules.slice(-1)[0].save;
        }
        return helpers.Time.WallTimeToUTC(this.timeZone.offset, lastSave, dt);
      };

      RuleSet.prototype.getYearEndDST = function(dt) {
        var appliedRules, getPrevRuleSave, lastSave, rule, rules, utcStd, year, _i, _len;
        year = typeof dt === number ? dt : dt.getUTCFullYear();
        utcStd = helpers.Time.StandardTimeToUTC(this.timeZone.offset, year, 11, 31, 23, 59, 59);
        rules = (function() {
          var _i, _len, _ref, _results;
          _ref = this.rules;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rule = _ref[_i];
            if (rule.appliesToUTC(utcStd)) {
              _results.push(rule);
            }
          }
          return _results;
        }).call(this);
        if (rules.length < 1) {
          return helpers.noSave;
        }
        rules = this._sortRulesByOnTime(rules);
        getPrevRuleSave = function(r) {
          var idx;
          idx = rules.indexOf(r);
          if (idx < 1) {
            return helpers.noSave;
          }
          return rules[idx - 1].save;
        };
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          rule.setOnUTC(utcStd.getUTCFullYear(), this.timeZone.offset, getPrevRuleSave);
        }
        appliedRules = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
            rule = rules[_j];
            if (rule.onUTC.getTime() < utcStd.getTime()) {
              _results.push(rule);
            }
          }
          return _results;
        })();
        lastSave = helpers.noSave;
        if (appliedRules.length > 0) {
          lastSave = appliedRules.slice(-1)[0].save;
        }
        return lastSave;
      };

      RuleSet.prototype.isAmbiguous = function(dt) {
        var appliedRules, getPrevRuleSave, lastRule, makeAmbigRange, minsOff, prevSave, range, rule, rules, springForward, totalMinutes, utcStd, _i, _len;
        utcStd = helpers.Time.StandardTimeToUTC(this.timeZone.offset, dt);
        rules = (function() {
          var _i, _len, _ref, _results;
          _ref = this.rules;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rule = _ref[_i];
            if (rule.appliesToUTC(utcStd)) {
              _results.push(rule);
            }
          }
          return _results;
        }).call(this);
        if (rules.length < 1) {
          return false;
        }
        rules = this._sortRulesByOnTime(rules);
        getPrevRuleSave = function(r) {
          var idx;
          idx = rules.indexOf(r);
          if (idx < 1) {
            return helpers.noSave;
          }
          return rules[idx - 1].save;
        };
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          rule.setOnUTC(utcStd.getUTCFullYear(), this.timeZone.offset, getPrevRuleSave);
        }
        appliedRules = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
            rule = rules[_j];
            if (rule.onUTC.getTime() <= utcStd.getTime() - 1) {
              _results.push(rule);
            }
          }
          return _results;
        })();
        if (appliedRules.length < 1) {
          return false;
        }
        lastRule = appliedRules.slice(-1)[0];
        prevSave = getPrevRuleSave(lastRule);
        totalMinutes = {
          prev: (prevSave.hours * 60) + prevSave.mins,
          last: (lastRule.save.hours * 60) + lastRule.save.mins
        };
        if (totalMinutes.prev === totalMinutes.last) {
          return false;
        }
        springForward = totalMinutes.prev < totalMinutes.last;
        makeAmbigRange = function(begin, minutesOff) {
          var ambigRange, tmp;
          ambigRange = {
            begin: helpers.Time.MakeDateFromTimeStamp(begin.getTime() + 1)
          };
          ambigRange.end = helpers.Time.Add(ambigRange.begin, 0, minutesOff);
          if (ambigRange.begin.getTime() > ambigRange.end.getTime()) {
            tmp = ambigRange.begin;
            ambigRange.begin = ambigRange.end;
            ambigRange.end = tmp;
          }
          return ambigRange;
        };
        minsOff = springForward ? totalMinutes.last : -totalMinutes.prev;
        range = makeAmbigRange(lastRule.onUTC, minsOff);
        utcStd = helpers.Time.WallTimeToUTC(this.timeZone.offset, prevSave, dt);
        return (range.begin <= utcStd && utcStd <= range.end);
      };

      RuleSet.prototype._sortRulesByOnTime = function(rules) {
        return rules.sort(function(a, b) {
          return (helpers.Months.MonthIndex(a["in"])) - (helpers.Months.MonthIndex(b["in"]));
        });
      };

      return RuleSet;

    })();
    lib = {
      Rule: Rule,
      RuleSet: RuleSet,
      OnFieldHandlers: {
        NumberHandler: NumberOnFieldHandler,
        LastHandler: LastOnFieldHandler,
        CompareHandler: CompareOnFieldHandler
      }
    };
    return lib;
  };

  this.WallTime || (this.WallTime = {});
  this.WallTime.rule = init(this.WallTime.helpers, this.WallTime.TimeZoneTime);

}).call(this);

(function() {
  var init, req_TimeZoneTime, req_helpers, req_rule;

  init = function(helpers, rule, TimeZoneTime) {
    var Zone, ZoneSet, lib;
    Zone = (function() {
      function Zone(name, _offset, _rule, format, _until, currZone) {
        var begin, isNegative, offsetHours, offsetMins, offsetSecs, _ref;
        this.name = name;
        this._offset = _offset;
        this._rule = _rule;
        this.format = format;
        this._until = _until;
        _ref = helpers.Time.ParseGMTOffset(this._offset), isNegative = _ref[0], offsetHours = _ref[1], offsetMins = _ref[2], offsetSecs = _ref[3];
        this.offset = {
          negative: isNegative,
          hours: offsetHours,
          mins: offsetMins,
          secs: isNaN(offsetSecs) ? 0 : offsetSecs
        };
        begin = currZone ? helpers.Time.MakeDateFromTimeStamp(currZone.range.end.getTime() + 1) : helpers.Time.MinDate();
        this.range = {
          begin: begin,
          end: this._parseUntilDate(this._until)
        };
      }

      Zone.prototype._parseUntilDate = function(til) {
        var day, endTime, h, mi, month, monthName, neg, s, standardTime, time, year, _ref, _ref1;
        _ref = til.split(" "), year = _ref[0], monthName = _ref[1], day = _ref[2], time = _ref[3];
        _ref1 = time ? helpers.Time.ParseGMTOffset(time) : [false, 0, 0, 0], neg = _ref1[0], h = _ref1[1], mi = _ref1[2], s = _ref1[3];
        s = isNaN(s) ? 0 : s;
        if (!year || year === "") {
          return helpers.Time.MaxDate();
        }
        year = parseInt(year, 10);
        month = monthName ? helpers.Months.MonthIndex(monthName) : 0;
        day || (day = "1");
        if (helpers.Months.IsDayOfMonthRule(day)) {
          day = helpers.Months.DayOfMonthByRule(day, year, month);
        } else if (helpers.Months.IsLastDayOfMonthRule(day)) {
          day = helpers.Months.LastDayOfMonthRule(day, year, month);
        } else {
          day = parseInt(day, 10);
        }
        standardTime = helpers.Time.StandardTimeToUTC(this.offset, year, month, day, h, mi, s);
        endTime = helpers.Time.MakeDateFromTimeStamp(standardTime.getTime() - 1);
        return endTime;
      };

      Zone.prototype.updateEndForRules = function(getRulesNamed) {
        var endSave, hours, mins, rules, _ref;
        if (this._rule === "-" || this._rule === "") {
          return;
        }
        if (this._rule.indexOf(":") >= 0) {
          _ref = helpers.Time.ParseTime(this._rule), hours = _ref[0], mins = _ref[1];
          this.range.end = helpers.Time.ApplySave(this.range.end, {
            hours: hours,
            mins: mins
          });
        }
        rules = new rule.RuleSet(getRulesNamed(this._rule), this);
        endSave = rules.getYearEndDST(this.range.end);
        return this.range.end = helpers.Time.ApplySave(this.range.end, endSave);
      };

      Zone.prototype.UTCToWallTime = function(dt, getRulesNamed) {
        var hours, mins, rules, _ref;
        if (this._rule === "-" || this._rule === "") {
          return new TimeZoneTime(dt, this, helpers.noSave);
        }
        if (this._rule.indexOf(":") >= 0) {
          _ref = helpers.Time.ParseTime(this._rule), hours = _ref[0], mins = _ref[1];
          return new TimeZoneTime(dt, this, {
            hours: hours,
            mins: mins
          });
        }
        rules = new rule.RuleSet(getRulesNamed(this._rule), this);
        return rules.getWallTimeForUTC(dt);
      };

      Zone.prototype.WallTimeToUTC = function(dt, getRulesNamed) {
        var hours, mins, rules, _ref;
        if (this._rule === "-" || this._rule === "") {
          return helpers.Time.StandardTimeToUTC(this.offset, dt);
        }
        if (this._rule.indexOf(":") >= 0) {
          _ref = helpers.Time.ParseTime(this._rule), hours = _ref[0], mins = _ref[1];
          return helpers.Time.WallTimeToUTC(this.offset, {
            hours: hours,
            mins: mins
          }, dt);
        }
        rules = new rule.RuleSet(getRulesNamed(this._rule), this);
        return rules.getUTCForWallTime(dt, this.offset);
      };

      Zone.prototype.IsAmbiguous = function(dt, getRulesNamed) {
        var ambigCheck, hours, makeAmbigZone, mins, rules, utcDt, _ref, _ref1, _ref2;
        if (this._rule === "-" || this._rule === "") {
          return false;
        }
        if (this._rule.indexOf(":") >= 0) {
          utcDt = helpers.Time.StandardTimeToUTC(this.offset, dt);
          _ref = helpers.Time.ParseTime(this._rule), hours = _ref[0], mins = _ref[1];
          makeAmbigZone = function(begin) {
            var ambigZone, tmp;
            ambigZone = {
              begin: this.range.begin,
              end: helpers.Time.ApplySave(this.range.begin, {
                hours: hours,
                mins: mins
              })
            };
            if (ambigZone.end.getTime() < ambigZone.begin.getTime()) {
              tmp = ambigZone.begin;
              ambigZone.begin = ambigZone.end;
              ambigZone.end = tmp;
            }
            return ambigZone;
          };
          ambigCheck = makeAmbigZone(this.range.begin);
          if ((ambigCheck.begin.getTime() <= (_ref1 = utcDt.getTime()) && _ref1 < ambigCheck.end.getTime())) {
            return true;
          }
          ambigCheck = makeAmbigZone(this.range.end);
          (ambigCheck.begin.getTime() <= (_ref2 = utcDt.getTime()) && _ref2 < ambigCheck.end.getTime());
        }
        rules = new rule.RuleSet(getRulesNamed(this._rule), this);
        return rules.isAmbiguous(dt, this.offset);
      };

      return Zone;

    })();
    ZoneSet = (function() {
      function ZoneSet(zones, getRulesNamed) {
        var zone, _i, _len, _ref;
        this.zones = zones != null ? zones : [];
        this.getRulesNamed = getRulesNamed;
        if (this.zones.length > 0) {
          this.name = this.zones[0].name;
        } else {
          this.name = "";
        }
        _ref = this.zones;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          zone = _ref[_i];
          zone.updateEndForRules;
        }
      }

      ZoneSet.prototype.add = function(zone) {
        if (this.zones.length === 0 && this.name === "") {
          this.name = zone.name;
        }
        if (this.name !== zone.name) {
          throw new Error("Cannot add different named zones to a ZoneSet");
        }
        return this.zones.push(zone);
      };

      ZoneSet.prototype.findApplicable = function(dt, useOffset) {
        var findOffsetRange, found, range, ts, zone, _i, _len, _ref;
        if (useOffset == null) {
          useOffset = false;
        }
        ts = dt.getTime();
        findOffsetRange = function(zone) {
          return {
            begin: helpers.Time.UTCToStandardTime(zone.range.begin, zone.offset),
            end: helpers.Time.UTCToStandardTime(zone.range.end, zone.offset)
          };
        };
        found = null;
        _ref = this.zones;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          zone = _ref[_i];
          range = !useOffset ? zone.range : findOffsetRange(zone);
          if ((range.begin.getTime() <= ts && ts <= range.end.getTime())) {
            found = zone;
            break;
          }
        }
        return found;
      };

      ZoneSet.prototype.getWallTimeForUTC = function(dt) {
        var applicable;
        applicable = this.findApplicable(dt);
        if (!applicable) {
          return new TimeZoneTime(dt, helpers.noZone, helpers.noSave);
        }
        return applicable.UTCToWallTime(dt, this.getRulesNamed);
      };

      ZoneSet.prototype.getUTCForWallTime = function(dt) {
        var applicable;
        applicable = this.findApplicable(dt, true);
        if (!applicable) {
          return dt;
        }
        return applicable.WallTimeToUTC(dt, this.getRulesNamed);
      };

      ZoneSet.prototype.isAmbiguous = function(dt) {
        var applicable;
        applicable = this.findApplicable(dt, true);
        if (!applicable) {
          return false;
        }
        return applicable.IsAmbiguous(dt, this.getRulesNamed);
      };

      return ZoneSet;

    })();
    return lib = {
      Zone: Zone,
      ZoneSet: ZoneSet
    };
  };

  this.WallTime || (this.WallTime = {});
  this.WallTime.zone = init(this.WallTime.helpers, this.WallTime.rule, this.WallTime.TimeZoneTime);

}).call(this);

(function() {
  var api, init, key, req_help, req_rule, req_zone, val, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty;

  init = function(helpers, rule, zone) {
    var WallTime;
    WallTime = (function() {
      function WallTime() {}

      WallTime.prototype.init = function(rules, zones) {
        if (rules == null) {
          rules = {};
        }
        if (zones == null) {
          zones = {};
        }
        this.zones = {};
        this.rules = {};
        this.addRulesZones(rules, zones);
        this.zoneSet = null;
        this.timeZoneName = null;
        return this.doneInit = true;
      };

      WallTime.prototype.addRulesZones = function(rules, zones) {
        var currZone, newRules, newZone, newZones, r, ruleName, ruleVals, z, zoneName, zoneVals, _i, _len, _results;
        if (rules == null) {
          rules = {};
        }
        if (zones == null) {
          zones = {};
        }
        currZone = null;
        for (zoneName in zones) {
          if (!__hasProp.call(zones, zoneName)) continue;
          zoneVals = zones[zoneName];
          newZones = [];
          currZone = null;
          for (_i = 0, _len = zoneVals.length; _i < _len; _i++) {
            z = zoneVals[_i];
            newZone = new zone.Zone(z.name, z._offset, z._rule, z.format, z._until, currZone);
            newZones.push(newZone);
            currZone = newZone;
          }
          this.zones[zoneName] = newZones;
        }
        _results = [];
        for (ruleName in rules) {
          if (!__hasProp.call(rules, ruleName)) continue;
          ruleVals = rules[ruleName];
          newRules = (function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = ruleVals.length; _j < _len1; _j++) {
              r = ruleVals[_j];
              _results1.push(new rule.Rule(r.name, r._from, r._to, r.type, r["in"], r.on, r.at, r._save, r.letter));
            }
            return _results1;
          })();
          _results.push(this.rules[ruleName] = newRules);
        }
        return _results;
      };

      WallTime.prototype.setTimeZone = function(name) {
        var matches,
          _this = this;
        if (!this.doneInit) {
          throw new Error("Must call init with rules and zones before setting time zone");
        }
        if (!this.zones[name]) {
          throw new Error("Unable to find time zone named " + (name || '<blank>'));
        }
        matches = this.zones[name];
        this.zoneSet = new zone.ZoneSet(matches, function(ruleName) {
          return _this.rules[ruleName];
        });
        return this.timeZoneName = name;
      };

      WallTime.prototype.Date = function(y, m, d, h, mi, s, ms) {
        if (m == null) {
          m = 0;
        }
        if (d == null) {
          d = 1;
        }
        if (h == null) {
          h = 0;
        }
        if (mi == null) {
          mi = 0;
        }
        if (s == null) {
          s = 0;
        }
        if (ms == null) {
          ms = 0;
        }
        y || (y = new Date().getUTCFullYear());
        return helpers.Time.MakeDateFromParts(y, m, d, h, mi, s, ms);
      };

      WallTime.prototype.UTCToWallTime = function(dt, zoneName) {
        if (zoneName == null) {
          zoneName = this.timeZoneName;
        }
        if (typeof dt === "number") {
          dt = new Date(dt);
        }
        if (zoneName !== this.timeZoneName) {
          this.setTimeZone(zoneName);
        }
        if (!this.zoneSet) {
          throw new Error("Must set the time zone before converting times");
        }
        return this.zoneSet.getWallTimeForUTC(dt);
      };

      WallTime.prototype.WallTimeToUTC = function(zoneName, y, m, d, h, mi, s, ms) {
        var wallTime;
        if (zoneName == null) {
          zoneName = this.timeZoneName;
        }
        if (m == null) {
          m = 0;
        }
        if (d == null) {
          d = 1;
        }
        if (h == null) {
          h = 0;
        }
        if (mi == null) {
          mi = 0;
        }
        if (s == null) {
          s = 0;
        }
        if (ms == null) {
          ms = 0;
        }
        if (zoneName !== this.timeZoneName) {
          this.setTimeZone(zoneName);
        }
        wallTime = typeof y === "number" ? helpers.Time.MakeDateFromParts(y, m, d, h, mi, s, ms) : y;
        return this.zoneSet.getUTCForWallTime(wallTime);
      };

      WallTime.prototype.IsAmbiguous = function(zoneName, y, m, d, h, mi) {
        var wallTime;
        if (zoneName == null) {
          zoneName = this.timeZoneName;
        }
        if (mi == null) {
          mi = 0;
        }
        if (zoneName !== this.timeZoneName) {
          this.setTimeZone(zoneName);
        }
        wallTime = typeof y === "number" ? helpers.Time.MakeDateFromParts(y, m, d, h, mi) : y;
        return this.zoneSet.isAmbiguous(wallTime);
      };

      return WallTime;

    })();
    return new WallTime;
  };

  this.WallTime || (this.WallTime = {});
  api = init(this.WallTime.helpers, this.WallTime.rule, this.WallTime.zone);
  _ref = this.WallTime;
  for (key in _ref) {
    if (!__hasProp.call(_ref, key)) continue;
    val = _ref[key];
    api[key] = val;
  }
  this.WallTime = api;
  if (this.WallTime.autoinit && ((_ref1 = this.WallTime.data) != null ? _ref1.rules : void 0) && ((_ref2 = this.WallTime.data) != null ? _ref2.zones : void 0)) {
    this.WallTime.init(this.WallTime.data.rules, this.WallTime.data.zones);
  }

}).call(this);

exports.WallTime = this.WallTime;

},{}]},{},[3])(3)
});