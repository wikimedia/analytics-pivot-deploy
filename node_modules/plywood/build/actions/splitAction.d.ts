import { Action, ActionJS, ActionValue, Splits } from "./baseAction";
import { PlyType, DatasetFullType, FullType } from "../types";
import { Expression, Indexer, Alterations, SubstitutionFn } from "../expressions/baseExpression";
import { SQLDialect } from "../dialect/baseDialect";
import { Datum, ComputeFn } from "../datatypes/dataset";
export declare class SplitAction extends Action {
    static fromJS(parameters: ActionJS): SplitAction;
    keys: string[];
    splits: Splits;
    dataName: string;
    constructor(parameters: ActionValue);
    valueOf(): ActionValue;
    toJS(): ActionJS;
    equals(other: SplitAction): boolean;
    protected _toStringParameters(expressionString: string): string[];
    getNecessaryInputTypes(): PlyType | PlyType[];
    getOutputType(inputType: PlyType): PlyType;
    _fillRefSubstitutions(typeContext: DatasetFullType, inputType: FullType, indexer: Indexer, alterations: Alterations): FullType;
    getFn(inputType: PlyType, inputFn: ComputeFn): ComputeFn;
    getSQL(inputType: PlyType, inputSQL: string, dialect: SQLDialect): string;
    getSelectSQL(dialect: SQLDialect): string[];
    getShortGroupBySQL(): string;
    expressionCount(): int;
    fullyDefined(): boolean;
    simplify(): Action;
    getExpressions(): Expression[];
    _substituteHelper(substitutionFn: SubstitutionFn, thisArg: any, indexer: Indexer, depth: int, nestDiff: int): Action;
    isNester(): boolean;
    numSplits(): number;
    isMultiSplit(): boolean;
    mapSplits<T>(fn: (name: string, expression?: Expression) => T): T[];
    mapSplitExpressions<T>(fn: (expression: Expression, name?: string) => T): Lookup<T>;
    transformExpressions(fn: (expression: Expression, name?: string) => Expression): SplitAction;
    firstSplitName(): string;
    firstSplitExpression(): Expression;
    filterFromDatum(datum: Datum): Expression;
    hasKey(key: string): boolean;
    maxBucketNumber(): number;
    isAggregate(): boolean;
}
