"use strict";
var chai_1 = require("chai");
var PROPERTY_KEYS = ['name', 'defaultValue', 'possibleValues', 'validate', 'isDate', 'immutableClass', 'immutableClassArray', 'immutableClassLookup', 'equal'];
function testImmutableClass(ClassFn, objects, options) {
    if (options === void 0) { options = {}; }
    if (typeof ClassFn !== 'function')
        throw new TypeError("ClassFn must be a constructor function");
    if (!Array.isArray(objects) || !objects.length) {
        throw new TypeError("objects must be a non-empty array of js to test");
    }
    var newThrows = options.newThrows;
    var context = options.context;
    var className = ClassFn.name;
    if (className.length <= 1)
        throw new Error("Class must have a name longer than 1 letter");
    if (className[0] !== className[0].toUpperCase())
        throw new Error("Class name must start with a capital letter");
    var instanceName = className[0].toLowerCase() + className.substring(1);
    var isClassName = "is" + className;
    chai_1.expect(ClassFn.fromJS, className + ".fromJS should exist").to.be.a('function');
    chai_1.expect(ClassFn[isClassName], className + "." + isClassName + " should exist").to.be.a('function');
    var instance = ClassFn.fromJS(objects[0], context);
    var objectProto = Object.prototype;
    chai_1.expect(instance.valueOf, "Instance should implement valueOf").to.not.equal(objectProto.valueOf);
    chai_1.expect(instance.toString, "Instance should implement toString").to.not.equal(objectProto.toString);
    chai_1.expect(instance.toJS, "Instance should have a toJS function").to.be.a('function');
    chai_1.expect(instance.toJSON, "Instance should have a toJSON function").to.be.a('function');
    chai_1.expect(instance.equals, "Instance should have an equals function").to.be.a('function');
    var isClass = ClassFn[isClassName];
    chai_1.expect(isClass(null), isClassName + " should fail on null").to.equal(false);
    chai_1.expect(isClass([]), isClassName + " should fail on []").to.equal(false);
    chai_1.expect(isClass(''), isClassName + " should fail on ''").to.equal(false);
    if (ClassFn.PROPERTIES) {
        chai_1.expect(ClassFn.PROPERTIES, 'PROPERTIES should be an array').to.be.an('array');
        ClassFn.PROPERTIES.forEach(function (property) {
            Object.keys(property).forEach(function (key) {
                chai_1.expect(PROPERTY_KEYS).to.include(key);
                chai_1.expect(property.name).to.be.a('string');
            });
        });
    }
    for (var i = 0; i < objects.length; i++) {
        var where = "[in object " + i + "]";
        var objectJSON = JSON.stringify(objects[i]);
        var objectCopy1 = JSON.parse(objectJSON);
        var objectCopy2 = JSON.parse(objectJSON);
        var inst = ClassFn.fromJS(objectCopy1, context);
        chai_1.expect(objectCopy1, className + ".fromJS function modified its input :-(").to.deep.equal(objectCopy2);
        chai_1.expect(inst, className + ".fromJS did not return a " + className + " instance " + where).to.be.instanceOf(ClassFn);
        chai_1.expect(isClass(inst), isClassName + "." + isClassName + " failed on something created with toJS " + where).to.equal(true);
        chai_1.expect(inst.toString(), instanceName + ".toString() must return a string " + where).to.be.a('string');
        chai_1.expect(inst.equals(null), instanceName + ".equals(null) should be false " + where).to.equal(false);
        chai_1.expect(inst.equals([]), instanceName + ".equals([]) should be false " + where).to.equal(false);
        chai_1.expect(inst.toJS(), className + ".fromJS(obj).toJS() was not a fixed point (did not deep equal obj) " + where).to.deep.equal(objects[i]);
        var instValueOf = inst.valueOf();
        chai_1.expect(inst.equals(instValueOf), "inst.equals(inst.valueOf()) " + where).to.equal(false);
        var instLazyCopy = {};
        for (var key in inst) {
            if (!inst.hasOwnProperty(key))
                continue;
            instLazyCopy[key] = inst[key];
        }
        chai_1.expect(inst.equals(instLazyCopy), "inst.equals(*an object with the same values*) " + where).to.equal(false);
        if (newThrows) {
            chai_1.expect(function () {
                new ClassFn(instValueOf);
            }, "new " + className + " did not throw as indicated " + where).to.throw(Error);
        }
        else {
            var instValueCopy = new ClassFn(instValueOf);
            chai_1.expect(inst.equals(instValueCopy), "new " + className + "().toJS() is not equal to the original " + where).to.equal(true);
            chai_1.expect(instValueCopy.toJS(), "new " + className + "(" + instanceName + ".valueOf()).toJS() returned something bad " + where).to.deep.equal(inst.toJS());
        }
        var instJSONCopy = ClassFn.fromJS(JSON.parse(JSON.stringify(inst)), context);
        chai_1.expect(inst.equals(instJSONCopy), "JS Copy does not equal original " + where).to.equal(true);
        chai_1.expect(instJSONCopy.toJS(), className + ".fromJS(JSON.parse(JSON.stringify(" + instanceName + "))).toJS() returned something bad " + where).to.deep.equal(inst.toJS());
    }
    for (var j = 0; j < objects.length; j++) {
        var objectJ = ClassFn.fromJS(objects[j], context);
        for (var k = j; k < objects.length; k++) {
            var objectK = ClassFn.fromJS(objects[k], context);
            chai_1.expect(objectJ.equals(objectK), "Equality of objects " + j + " and " + k + " was wrong").to.equal(j === k);
        }
    }
}
exports.testImmutableClass = testImmutableClass;
