(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.chronoshift = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var walltimeRepack = require('walltime-repack');
var immutableClass = require('immutable-class');

var Timezone = (function () {
    function Timezone(timezone) {
        if (typeof timezone !== 'string') {
            throw new TypeError("timezone description must be a string");
        }
        if (timezone !== 'Etc/UTC') {
            walltimeRepack.WallTime.UTCToWallTime(new Date(0), timezone);
        }
        this.timezone = timezone;
    }
    Timezone.isTimezone = function (candidate) {
        return immutableClass.isInstanceOf(candidate, Timezone);
    };
    Timezone.fromJS = function (spec) {
        return new Timezone(spec);
    };
    Timezone.prototype.valueOf = function () {
        return this.timezone;
    };
    Timezone.prototype.toJS = function () {
        return this.timezone;
    };
    Timezone.prototype.toJSON = function () {
        return this.timezone;
    };
    Timezone.prototype.toString = function () {
        return this.timezone;
    };
    Timezone.prototype.equals = function (other) {
        return Timezone.isTimezone(other) &&
            this.timezone === other.timezone;
    };
    Timezone.prototype.isUTC = function () {
        return this.timezone === 'Etc/UTC';
    };
    Timezone.UTC = new Timezone('Etc/UTC');
    return Timezone;
}());

function adjustDay(day) {
    return (day + 6) % 7;
}
function floorTo(n, roundTo) {
    return Math.floor(n / roundTo) * roundTo;
}
function timeShifterFiller(tm) {
    var floor = tm.floor, shift = tm.shift;
    tm.ceil = function (dt, tz) {
        var floored = floor(dt, tz);
        if (floored.valueOf() === dt.valueOf())
            return dt;
        return shift(floored, tz, 1);
    };
    tm.move = tm.shift;
    return tm;
}
var second = timeShifterFiller({
    canonicalLength: 1000,
    siblings: 60,
    floor: function (dt, tz) {
        dt = new Date(dt.valueOf());
        dt.setUTCMilliseconds(0);
        return dt;
    },
    round: function (dt, roundTo, tz) {
        var cur = dt.getUTCSeconds();
        var adj = floorTo(cur, roundTo);
        if (cur !== adj)
            dt.setUTCSeconds(adj);
        return dt;
    },
    shift: function (dt, tz, step) {
        dt = new Date(dt.valueOf());
        dt.setUTCSeconds(dt.getUTCSeconds() + step);
        return dt;
    }
});
var minute = timeShifterFiller({
    canonicalLength: 60000,
    siblings: 60,
    floor: function (dt, tz) {
        dt = new Date(dt.valueOf());
        dt.setUTCSeconds(0, 0);
        return dt;
    },
    round: function (dt, roundTo, tz) {
        var cur = dt.getUTCMinutes();
        var adj = floorTo(cur, roundTo);
        if (cur !== adj)
            dt.setUTCMinutes(adj);
        return dt;
    },
    shift: function (dt, tz, step) {
        dt = new Date(dt.valueOf());
        dt.setUTCMinutes(dt.getUTCMinutes() + step);
        return dt;
    }
});
function hourMove(dt, tz, step) {
    if (tz.isUTC()) {
        dt = new Date(dt.valueOf());
        dt.setUTCHours(dt.getUTCHours() + step);
    }
    else {
        var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
        dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate(), wt.getHours() + step, wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
    }
    return dt;
}
var hour = timeShifterFiller({
    canonicalLength: 3600000,
    siblings: 24,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCMinutes(0, 0, 0);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate(), wt.getHours(), 0, 0, 0);
        }
        return dt;
    },
    round: function (dt, roundTo, tz) {
        if (tz.isUTC()) {
            var cur = dt.getUTCHours();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                dt.setUTCHours(adj);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            var cur = wt.getHours();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                return hourMove(dt, tz, adj - cur);
        }
        return dt;
    },
    shift: hourMove
});
var day = timeShifterFiller({
    canonicalLength: 24 * 3600000,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCHours(0, 0, 0, 0);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate(), 0, 0, 0, 0);
        }
        return dt;
    },
    shift: function (dt, tz, step) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCDate(dt.getUTCDate() + step);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate() + step, wt.getHours(), wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
        }
        return dt;
    }
});
var week = timeShifterFiller({
    canonicalLength: 7 * 24 * 3600000,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCHours(0, 0, 0, 0);
            dt.setUTCDate(dt.getUTCDate() - adjustDay(dt.getUTCDay()));
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate() - adjustDay(wt.getDay()), 0, 0, 0, 0);
        }
        return dt;
    },
    shift: function (dt, tz, step) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCDate(dt.getUTCDate() + step * 7);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), wt.getDate() + step * 7, wt.getHours(), wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
        }
        return dt;
    }
});
function monthShift(dt, tz, step) {
    if (tz.isUTC()) {
        dt = new Date(dt.valueOf());
        dt.setUTCMonth(dt.getUTCMonth() + step);
    }
    else {
        var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
        dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth() + step, wt.getDate(), wt.getHours(), wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
    }
    return dt;
}
var month = timeShifterFiller({
    canonicalLength: 30 * 24 * 3600000,
    siblings: 12,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCHours(0, 0, 0, 0);
            dt.setUTCDate(1);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), wt.getMonth(), 1, 0, 0, 0, 0);
        }
        return dt;
    },
    round: function (dt, roundTo, tz) {
        if (tz.isUTC()) {
            var cur = dt.getUTCMonth();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                dt.setUTCMonth(adj);
        }
        else {
            var cur = dt.getMonth();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                return monthShift(dt, tz, adj - cur);
        }
        return dt;
    },
    shift: monthShift
});
function yearShift(dt, tz, step) {
    if (tz.isUTC()) {
        dt = new Date(dt.valueOf());
        dt.setUTCFullYear(dt.getUTCFullYear() + step);
    }
    else {
        var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
        dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear() + step, wt.getMonth(), wt.getDate(), wt.getHours(), wt.getMinutes(), wt.getSeconds(), wt.getMilliseconds());
    }
    return dt;
}
var year = timeShifterFiller({
    canonicalLength: 365 * 24 * 3600000,
    siblings: 1000,
    floor: function (dt, tz) {
        if (tz.isUTC()) {
            dt = new Date(dt.valueOf());
            dt.setUTCHours(0, 0, 0, 0);
            dt.setUTCMonth(0, 1);
        }
        else {
            var wt = walltimeRepack.WallTime.UTCToWallTime(dt, tz.toString());
            dt = walltimeRepack.WallTime.WallTimeToUTC(tz.toString(), wt.getFullYear(), 0, 1, 0, 0, 0, 0);
        }
        return dt;
    },
    round: function (dt, roundTo, tz) {
        if (tz.isUTC()) {
            var cur = dt.getUTCFullYear();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                dt.setUTCFullYear(adj);
        }
        else {
            var cur = dt.getFullYear();
            var adj = floorTo(cur, roundTo);
            if (cur !== adj)
                return yearShift(dt, tz, adj - cur);
        }
        return dt;
    },
    shift: yearShift
});
var shifters = {
    second: second,
    minute: minute,
    hour: hour,
    day: day,
    week: week,
    month: month,
    year: year
};

var spansWithWeek = ["year", "month", "week", "day", "hour", "minute", "second"];
var spansWithoutWeek = ["year", "month", "day", "hour", "minute", "second"];
function capitalizeFirst(str) {
    if (!str.length)
        return str;
    return str[0].toUpperCase() + str.substr(1);
}
var periodWeekRegExp = /^P(\d+)W$/;
var periodRegExp = /^P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?)?$/;
function getSpansFromString(durationStr) {
    var spans = {};
    var matches;
    if (matches = periodWeekRegExp.exec(durationStr)) {
        spans.week = Number(matches[1]);
        if (!spans.week)
            throw new Error("Duration can not be empty");
    }
    else if (matches = periodRegExp.exec(durationStr)) {
        var nums = matches.map(Number);
        for (var i = 0; i < spansWithoutWeek.length; i++) {
            var span = spansWithoutWeek[i];
            var value = nums[i + 1];
            if (value)
                spans[span] = value;
        }
    }
    else {
        throw new Error("Can not parse duration '" + durationStr + "'");
    }
    return spans;
}
function getSpansFromStartEnd(start, end, timezone) {
    start = second.floor(start, timezone);
    end = second.floor(end, timezone);
    if (end <= start)
        throw new Error("start must come before end");
    var spans = {};
    var iterator = start;
    for (var i = 0; i < spansWithoutWeek.length; i++) {
        var span = spansWithoutWeek[i];
        var spanCount = 0;
        var length = end.valueOf() - iterator.valueOf();
        var canonicalLength = shifters[span].canonicalLength;
        if (length < canonicalLength / 4)
            continue;
        var numberToFit = Math.min(0, Math.floor(length / canonicalLength) - 1);
        var iteratorMove;
        if (numberToFit > 0) {
            iteratorMove = shifters[span].shift(iterator, timezone, numberToFit);
            if (iteratorMove <= end) {
                spanCount += numberToFit;
                iterator = iteratorMove;
            }
        }
        while (true) {
            iteratorMove = shifters[span].shift(iterator, timezone, 1);
            if (iteratorMove <= end) {
                iterator = iteratorMove;
                spanCount++;
            }
            else {
                break;
            }
        }
        if (spanCount) {
            spans[span] = spanCount;
        }
    }
    return spans;
}
function removeZeros(spans) {
    var newSpans = {};
    for (var i = 0; i < spansWithWeek.length; i++) {
        var span = spansWithWeek[i];
        if (spans[span] > 0) {
            newSpans[span] = spans[span];
        }
    }
    return newSpans;
}
var Duration = (function () {
    function Duration(spans, end, timezone) {
        if (spans && end && timezone) {
            spans = getSpansFromStartEnd(spans, end, timezone);
        }
        else if (typeof spans === 'object') {
            spans = removeZeros(spans);
        }
        else {
            throw new Error("new Duration called with bad argument");
        }
        var usedSpans = Object.keys(spans);
        if (!usedSpans.length)
            throw new Error("Duration can not be empty");
        if (usedSpans.length === 1) {
            this.singleSpan = usedSpans[0];
        }
        else if (spans.week) {
            throw new Error("Can not mix 'week' and other spans");
        }
        this.spans = spans;
    }
    Duration.fromJS = function (durationStr) {
        if (typeof durationStr !== 'string')
            throw new TypeError("Duration JS must be a string");
        return new Duration(getSpansFromString(durationStr));
    };
    Duration.fromCanonicalLength = function (length) {
        var spans = {};
        for (var i = 0; i < spansWithWeek.length; i++) {
            var span = spansWithWeek[i];
            var spanLength = shifters[span].canonicalLength;
            var count = Math.floor(length / spanLength);
            length -= spanLength * count;
            spans[span] = count;
        }
        return new Duration(spans);
    };
    Duration.isDuration = function (candidate) {
        return immutableClass.isInstanceOf(candidate, Duration);
    };
    Duration.prototype.toString = function () {
        var strArr = ["P"];
        var spans = this.spans;
        if (spans.week) {
            strArr.push(String(spans.week), 'W');
        }
        else {
            var addedT = false;
            for (var i = 0; i < spansWithoutWeek.length; i++) {
                var span = spansWithoutWeek[i];
                var value = spans[span];
                if (!value)
                    continue;
                if (!addedT && i >= 3) {
                    strArr.push("T");
                    addedT = true;
                }
                strArr.push(String(value), span[0].toUpperCase());
            }
        }
        return strArr.join("");
    };
    Duration.prototype.add = function (duration) {
        return Duration.fromCanonicalLength(this.getCanonicalLength() + duration.getCanonicalLength());
    };
    Duration.prototype.subtract = function (duration) {
        var newCanonicalDuration = this.getCanonicalLength() - duration.getCanonicalLength();
        if (newCanonicalDuration < 0)
            throw new Error("A duration can not be negative.");
        return Duration.fromCanonicalLength(newCanonicalDuration);
    };
    Duration.prototype.valueOf = function () {
        return this.spans;
    };
    Duration.prototype.toJS = function () {
        return this.toString();
    };
    Duration.prototype.toJSON = function () {
        return this.toString();
    };
    Duration.prototype.equals = function (other) {
        return Boolean(other) &&
            this.toString() === other.toString();
    };
    Duration.prototype.isSimple = function () {
        var singleSpan = this.singleSpan;
        if (!singleSpan)
            return false;
        return this.spans[singleSpan] === 1;
    };
    Duration.prototype.isFloorable = function () {
        var singleSpan = this.singleSpan;
        if (!singleSpan)
            return false;
        var span = this.spans[singleSpan];
        if (span === 1)
            return true;
        var siblings = shifters[singleSpan].siblings;
        if (!siblings)
            return false;
        return siblings % span === 0;
    };
    Duration.prototype.floor = function (date, timezone) {
        var singleSpan = this.singleSpan;
        if (!singleSpan)
            throw new Error("Can not floor on a complex duration");
        var span = this.spans[singleSpan];
        var mover = shifters[singleSpan];
        var dt = mover.floor(date, timezone);
        if (span !== 1) {
            if (!mover.siblings)
                throw new Error("Can not floor on a " + singleSpan + " duration that is not 1");
            if (mover.siblings % span !== 0)
                throw new Error("Can not floor on a " + singleSpan + " duration that does not divide into " + mover.siblings);
            dt = mover.round(dt, span, timezone);
        }
        return dt;
    };
    Duration.prototype.shift = function (date, timezone, step) {
        if (step === void 0) { step = 1; }
        var spans = this.spans;
        for (var _i = 0, spansWithWeek_1 = spansWithWeek; _i < spansWithWeek_1.length; _i++) {
            var span = spansWithWeek_1[_i];
            var value = spans[span];
            if (value)
                date = shifters[span].shift(date, timezone, step * value);
        }
        return date;
    };
    Duration.prototype.materialize = function (start, end, timezone, step) {
        if (step === void 0) { step = 1; }
        var values = [];
        var iter = this.floor(start, timezone);
        while (iter <= end) {
            values.push(iter);
            iter = this.shift(iter, timezone, step);
        }
        return values;
    };
    Duration.prototype.isAligned = function (date, timezone) {
        return this.floor(date, timezone).valueOf() === date.valueOf();
    };
    Duration.prototype.dividesBy = function (smaller) {
        var myCanonicalLength = this.getCanonicalLength();
        var smallerCanonicalLength = smaller.getCanonicalLength();
        return myCanonicalLength % smallerCanonicalLength === 0 && this.isFloorable() && smaller.isFloorable();
    };
    Duration.prototype.getCanonicalLength = function () {
        var spans = this.spans;
        var length = 0;
        for (var _i = 0, spansWithWeek_2 = spansWithWeek; _i < spansWithWeek_2.length; _i++) {
            var span = spansWithWeek_2[_i];
            var value = spans[span];
            if (value)
                length += value * shifters[span].canonicalLength;
        }
        return length;
    };
    Duration.prototype.getDescription = function (capitalize) {
        var spans = this.spans;
        var description = [];
        for (var _i = 0, spansWithWeek_3 = spansWithWeek; _i < spansWithWeek_3.length; _i++) {
            var span = spansWithWeek_3[_i];
            var value = spans[span];
            var spanTitle = capitalize ? capitalizeFirst(span) : span;
            if (value) {
                if (value === 1) {
                    description.push(spanTitle);
                }
                else {
                    description.push(String(value) + ' ' + spanTitle + 's');
                }
            }
        }
        return description.join(', ');
    };
    Duration.prototype.getSingleSpan = function () {
        return this.singleSpan || null;
    };
    Duration.prototype.getSingleSpanValue = function () {
        if (!this.singleSpan)
            return null;
        return this.spans[this.singleSpan] || null;
    };
    return Duration;
}());

function parseYear(v) {
    if (v.length === 2) {
        var vn = parseInt(v, 10);
        return (vn < 70 ? 2000 : 1900) + vn;
    }
    else if (v.length === 4) {
        return parseInt(v, 10);
    }
    else {
        throw new Error('Invalid year in date');
    }
}
function parseMonth(v) {
    var vn = parseInt(v, 10);
    if (vn <= 0 || 12 < vn)
        throw new Error('Invalid month in date');
    return vn - 1;
}
function parseDay(v) {
    var vn = parseInt(v, 10);
    if (vn <= 0 || 31 < vn)
        throw new Error('Invalid day in date');
    return vn;
}
function parseHour(v) {
    var vn = parseInt(v, 10);
    if (vn < 0 || 24 < vn)
        throw new Error('Invalid hour in date');
    return vn;
}
function parseMinute(v) {
    var vn = parseInt(v, 10);
    if (vn < 0 || 60 < vn)
        throw new Error('Invalid minute in date');
    return vn;
}
function parseSecond(v) {
    var vn = parseInt(v, 10);
    if (vn < 0 || 60 < vn)
        throw new Error('Invalid second in date');
    return vn;
}
function parseMillisecond(v) {
    if (!v)
        return 0;
    return parseInt(v.substr(0, 3), 10);
}
function parseSQLDate(type, v) {
    if (type === 't')
        throw new Error('time literals are not supported');
    var m;
    var d;
    if (type === 'ts') {
        if (m = v.match(/^(\d{2}(?:\d{2})?)(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})$/)) {
            d = Date.UTC(parseYear(m[1]), parseMonth(m[2]), parseDay(m[3]), parseHour(m[4]), parseMinute(m[5]), parseSecond(m[6]));
        }
        else if (m = v.match(/^(\d{2}(?:\d{2})?)[~!@#$%^&*()_+=:.\-\/](\d{1,2})[~!@#$%^&*()_+=:.\-\/](\d{1,2})[T ](\d{1,2})[~!@#$%^&*()_+=:.\-\/](\d{1,2})[~!@#$%^&*()_+=:.\-\/](\d{1,2})(?:\.(\d{1,6}))?$/)) {
            d = Date.UTC(parseYear(m[1]), parseMonth(m[2]), parseDay(m[3]), parseHour(m[4]), parseMinute(m[5]), parseSecond(m[6]), parseMillisecond(m[7]));
        }
        else {
            throw new Error('Invalid timestamp');
        }
    }
    else {
        if (m = v.match(/^(\d{2}(?:\d{2})?)(\d{2})(\d{2})$/)) {
            d = Date.UTC(parseYear(m[1]), parseMonth(m[2]), parseDay(m[3]));
        }
        else if (m = v.match(/^(\d{2}(?:\d{2})?)[~!@#$%^&*()_+=:.\-\/](\d{1,2})[~!@#$%^&*()_+=:.\-\/](\d{1,2})$/)) {
            d = Date.UTC(parseYear(m[1]), parseMonth(m[2]), parseDay(m[3]));
        }
        else {
            throw new Error('Invalid date');
        }
    }
    return new Date(d);
}
var numericKeys = [1, 4, 5, 6, 10, 11];
function parseISODate(date, timezone) {
    if (timezone === void 0) { timezone = Timezone.UTC; }
    var struct;
    var minutesOffset = 0;
    if ((struct = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2})(?::?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?)?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?$/.exec(date))) {
        for (var i = 0, k; (k = numericKeys[i]); ++i) {
            struct[k] = +struct[k] || 0;
        }
        struct[2] = (+struct[2] || 1) - 1;
        struct[3] = +struct[3] || 1;
        struct[7] = struct[7] ? +(struct[7] + "00").substr(0, 3) : 0;
        if ((struct[8] === undefined || struct[8] === '') && (struct[9] === undefined || struct[9] === '') && !Timezone.UTC.equals(timezone)) {
            if (timezone === null) {
                return new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
            }
            else {
                return walltimeRepack.WallTime.WallTimeToUTC(timezone.toString(), struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
            }
        }
        else {
            if (struct[8] !== 'Z' && struct[9] !== undefined) {
                minutesOffset = struct[10] * 60 + struct[11];
                if (struct[9] === '+') {
                    minutesOffset = 0 - minutesOffset;
                }
            }
            return new Date(Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]));
        }
    }
    else {
        return null;
    }
}
function parseInterval(str, timezone, now) {
    if (timezone === void 0) { timezone = Timezone.UTC; }
    if (now === void 0) { now = new Date(); }
    var parts = str.split('/');
    if (parts.length > 2)
        throw new Error("Can not parse string " + str);
    var start = null;
    var end = null;
    var duration = null;
    var p0 = parts[0];
    if (parts.length === 1) {
        duration = Duration.fromJS(p0);
    }
    else {
        var p1 = parts[1];
        if (p0[0] === 'P') {
            duration = Duration.fromJS(p0);
            end = parseISODate(p1, timezone);
            if (!end)
                throw new Error("can not parse '" + p1 + "' as ISO date");
        }
        else if (p1[0] === 'P') {
            start = parseISODate(p0, timezone);
            if (!start)
                throw new Error("can not parse '" + p0 + "' as ISO date");
            duration = Duration.fromJS(p1);
        }
        else {
            start = parseISODate(p0, timezone);
            if (!start)
                throw new Error("can not parse '" + p0 + "' as ISO date");
            end = parseISODate(p1, timezone);
            if (!end)
                throw new Error("can not parse '" + p1 + "' as ISO date");
            if (end < start) {
                throw new Error("start must be <= end in '" + str + "'");
            }
        }
    }
    var computedStart;
    var computedEnd;
    if (start) {
        computedStart = start;
        if (duration) {
            computedEnd = duration.shift(computedStart, timezone, 1);
        }
        else {
            computedEnd = end;
        }
    }
    else {
        computedEnd = end || now;
        computedStart = duration.shift(computedEnd, timezone, -1);
    }
    return {
        computedStart: computedStart,
        computedEnd: computedEnd,
        start: start,
        end: end,
        duration: duration
    };
}

function isDate(d) {
    return !!(d && d.toISOString);
}

var WallTime$1 = walltimeRepack.WallTime;

exports.WallTime = WallTime$1;
exports.parseSQLDate = parseSQLDate;
exports.parseISODate = parseISODate;
exports.parseInterval = parseInterval;
exports.second = second;
exports.minute = minute;
exports.hour = hour;
exports.day = day;
exports.week = week;
exports.month = month;
exports.year = year;
exports.shifters = shifters;
exports.Timezone = Timezone;
exports.Duration = Duration;
exports.isDate = isDate;
},{"immutable-class":4,"walltime-repack":6}],2:[function(require,module,exports){
"use strict";
var utils_1 = require('./utils');
var equality_1 = require('./equality');
function firstUp(name) {
    return name[0].toUpperCase() + name.substr(1);
}
var BaseImmutable = (function () {
    function BaseImmutable(value) {
        var properties = this.ownProperties();
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            var propertyName = property.name;
            var pv = value[propertyName];
            if (property.validate) {
                try {
                    property.validate(pv);
                }
                catch (e) {
                    throw new Error(this.constructor.name + "." + propertyName + " " + e.message);
                }
            }
            this[propertyName] = pv;
        }
    }
    BaseImmutable.jsToValue = function (properties, js) {
        var value = {};
        for (var _i = 0, properties_2 = properties; _i < properties_2.length; _i++) {
            var property = properties_2[_i];
            var propertyName = property.name;
            var propertyImmutableClass = property.immutableClass;
            var pv = js[propertyName];
            value[propertyName] = pv ? (propertyImmutableClass ? propertyImmutableClass.fromJS(pv) : pv) : null;
        }
        return value;
    };
    BaseImmutable.finalize = function (ClassFn) {
        var proto = ClassFn.prototype;
        ClassFn.PROPERTIES.forEach(function (property) {
            var propertyName = property.name;
            var upped = firstUp(property.name);
            proto['get' + upped] = function () {
                return this.get(propertyName);
            };
            proto['change' + upped] = function (newValue) {
                return this.change(propertyName, newValue);
            };
        });
    };
    BaseImmutable.prototype.ownProperties = function () {
        return this.constructor.PROPERTIES;
    };
    BaseImmutable.prototype.findOwnProperty = function (propName) {
        var properties = this.ownProperties();
        return properties.filter(function (p) { return p.name === propName; })[0] || null;
    };
    BaseImmutable.prototype.valueOf = function () {
        var value = {};
        var properties = this.ownProperties();
        for (var _i = 0, properties_3 = properties; _i < properties_3.length; _i++) {
            var property = properties_3[_i];
            var propertyName = property.name;
            value[propertyName] = this[propertyName];
        }
        return value;
    };
    BaseImmutable.prototype.toJS = function () {
        var js = {};
        var properties = this.ownProperties();
        for (var _i = 0, properties_4 = properties; _i < properties_4.length; _i++) {
            var property = properties_4[_i];
            var propertyName = property.name;
            var propertyImmutableClass = property.immutableClass;
            var pv = this[propertyName];
            if (pv != null)
                js[propertyName] = propertyImmutableClass ? pv.toJS() : pv;
        }
        return js;
    };
    BaseImmutable.prototype.toJSON = function () {
        return this.toJS();
    };
    BaseImmutable.prototype.toString = function () {
        return '[ImmutableClass]';
    };
    BaseImmutable.prototype.equals = function (other) {
        if (!other)
            return false;
        if (this === other)
            return true;
        if (!utils_1.isInstanceOf(other, this.constructor))
            return false;
        var properties = this.ownProperties();
        for (var _i = 0, properties_5 = properties; _i < properties_5.length; _i++) {
            var property = properties_5[_i];
            var propertyName = property.name;
            var equal = property.equal || equality_1.generalEqual;
            if (!equal(this[propertyName], other[propertyName]))
                return false;
        }
        return true;
    };
    BaseImmutable.prototype.get = function (propName) {
        var properties = this.ownProperties();
        for (var _i = 0, properties_6 = properties; _i < properties_6.length; _i++) {
            var property = properties_6[_i];
            if (property.name === propName) {
                return this[propName] || property.defaultValue;
            }
        }
        throw new Error("can not find prop " + propName);
    };
    BaseImmutable.prototype.change = function (propName, newValue) {
        var value = this.valueOf();
        var property = this.findOwnProperty(propName);
        if (!property) {
            throw new Error("Unknown property: " + propName);
        }
        value[propName] = newValue;
        return new this.constructor(value);
    };
    return BaseImmutable;
}());
exports.BaseImmutable = BaseImmutable;

},{"./equality":3,"./utils":5}],3:[function(require,module,exports){
"use strict";
function generalEqual(a, b) {
    if (a === b)
        return true;
    if (a && b) {
        if (typeof a.toISOString === 'function' && typeof b.toISOString === 'function') {
            return a.valueOf() === b.valueOf();
        }
        if (Array.isArray(a) && Array.isArray(b)) {
            return generalArraysEqual(a, b);
        }
        if (typeof a.equals === 'function') {
            return a.equals(b);
        }
    }
    return false;
}
exports.generalEqual = generalEqual;
function immutableEqual(a, b) {
    if (a === b)
        return true;
    return Boolean(a) && a.equals(b);
}
exports.immutableEqual = immutableEqual;
function generalArraysEqual(arrayA, arrayB) {
    if (arrayA === arrayB)
        return true;
    if (!arrayA !== !arrayB)
        return false;
    var length = arrayA.length;
    if (length !== arrayB.length)
        return false;
    for (var i = 0; i < length; i++) {
        if (!generalEqual(arrayA[i], arrayB[i]))
            return false;
    }
    return true;
}
exports.generalArraysEqual = generalArraysEqual;
function immutableArraysEqual(arrayA, arrayB) {
    if (arrayA === arrayB)
        return true;
    if (!arrayA !== !arrayB)
        return false;
    var length = arrayA.length;
    if (length !== arrayB.length)
        return false;
    for (var i = 0; i < length; i++) {
        if (!immutableEqual(arrayA[i], arrayB[i]))
            return false;
    }
    return true;
}
exports.immutableArraysEqual = immutableArraysEqual;
function generalLookupsEqual(lookupA, lookupB) {
    if (lookupA === lookupB)
        return true;
    if (!lookupA !== !lookupB)
        return false;
    var keysA = Object.keys(lookupA);
    var keysB = Object.keys(lookupB);
    if (keysA.length !== keysB.length)
        return false;
    for (var _i = 0, keysA_1 = keysA; _i < keysA_1.length; _i++) {
        var k = keysA_1[_i];
        if (!generalEqual(lookupA[k], lookupB[k]))
            return false;
    }
    return true;
}
exports.generalLookupsEqual = generalLookupsEqual;
function immutableLookupsEqual(lookupA, lookupB) {
    if (lookupA === lookupB)
        return true;
    if (!lookupA !== !lookupB)
        return false;
    var keysA = Object.keys(lookupA);
    var keysB = Object.keys(lookupB);
    if (keysA.length !== keysB.length)
        return false;
    for (var _i = 0, keysA_2 = keysA; _i < keysA_2.length; _i++) {
        var k = keysA_2[_i];
        if (!immutableEqual(lookupA[k], lookupB[k]))
            return false;
    }
    return true;
}
exports.immutableLookupsEqual = immutableLookupsEqual;

},{}],4:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./utils'));
__export(require('./equality'));
__export(require('./baseImmutable'));

},{"./baseImmutable":2,"./equality":3,"./utils":5}],5:[function(require,module,exports){
"use strict";
function isInstanceOf(thing, constructor) {
    if (typeof constructor !== 'function')
        throw new TypeError("constructor must be a function");
    if (thing instanceof constructor)
        return true;
    if (thing == null)
        return false;
    var constructorName = constructor.name;
    if (!constructorName)
        return false;
    var thingProto = thing.__proto__;
    while (thingProto && thingProto.constructor) {
        if (thingProto.constructor.name === constructorName)
            return true;
        thingProto = thingProto.__proto__;
    }
    return false;
}
exports.isInstanceOf = isInstanceOf;
function isArrayOf(things, constructor) {
    if (!Array.isArray(things))
        return false;
    for (var i = 0, length = things.length; i < length; i++) {
        if (!isInstanceOf(things[i], constructor))
            return false;
    }
    return true;
}
exports.isArrayOf = isArrayOf;
function isImmutableClass(thing) {
    if (!thing || typeof thing !== 'object')
        return false;
    var ClassFn = thing.constructor;
    return typeof ClassFn.fromJS === 'function' &&
        typeof thing.toJS === 'function' &&
        typeof thing.equals === 'function';
}
exports.isImmutableClass = isImmutableClass;

},{}],6:[function(require,module,exports){
/*
 *  WallTime 0.1.2
 *  Copyright (c) 2013 Sprout Social, Inc.
 *  Available under the MIT License (http://bit.ly/walltime-license)
 */

(function() {
  var Days, Milliseconds, Months, Time, helpers, _base;

  (_base = Array.prototype).indexOf || (_base.indexOf = function(item) {
    var i, x, _i, _len;
    for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
      x = this[i];
      if (x === item) {
        return i;
      }
    }
    return -1;
  });

  Days = {
    DayShortNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    DayIndex: function(name) {
      return this.DayShortNames.indexOf(name);
    },
    DayNameFromIndex: function(dayIdx) {
      return this.DayShortNames[dayIdx];
    },
    AddToDate: function(dt, days) {
      return Time.MakeDateFromTimeStamp(dt.getTime() + (days * Milliseconds.inDay));
    }
  };

  Months = {
    MonthsShortNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    CompareRuleMatch: new RegExp("([a-zA-Z]*)([\\<\\>]?=)([0-9]*)"),
    MonthIndex: function(shortName) {
      return this.MonthsShortNames.indexOf(shortName.slice(0, 3));
    },
    IsDayOfMonthRule: function(str) {
      return str.indexOf(">") > -1 || str.indexOf("<") > -1 || str.indexOf("=") > -1;
    },
    IsLastDayOfMonthRule: function(str) {
      return str.slice(0, 4) === "last";
    },
    DayOfMonthByRule: function(str, year, month) {
      var compareFunc, compares, dateIndex, dayIndex, dayName, ruleParse, testDate, testPart, _ref;
      ruleParse = this.CompareRuleMatch.exec(str);
      if (!ruleParse) {
        throw new Error("Unable to parse the 'on' rule for " + str);
      }
      _ref = ruleParse.slice(1, 4), dayName = _ref[0], testPart = _ref[1], dateIndex = _ref[2];
      dateIndex = parseInt(dateIndex, 10);
      if (dateIndex === NaN) {
        throw new Error("Unable to parse the dateIndex of the 'on' rule for " + str);
      }
      dayIndex = helpers.Days.DayIndex(dayName);
      compares = {
        ">=": function(a, b) {
          return a >= b;
        },
        "<=": function(a, b) {
          return a <= b;
        },
        ">": function(a, b) {
          return a > b;
        },
        "<": function(a, b) {
          return a < b;
        },
        "=": function(a, b) {
          return a === b;
        }
      };
      compareFunc = compares[testPart];
      if (!compareFunc) {
        throw new Error("Unable to parse the conditional for " + testPart);
      }
      testDate = helpers.Time.MakeDateFromParts(year, month);
      while (!(dayIndex === testDate.getUTCDay() && compareFunc(testDate.getUTCDate(), dateIndex))) {
        testDate = helpers.Days.AddToDate(testDate, 1);
      }
      return testDate.getUTCDate();
    },
    LastDayOfMonthRule: function(str, year, month) {
      var dayIndex, dayName, lastDay;
      dayName = str.slice(4);
      dayIndex = helpers.Days.DayIndex(dayName);
      if (month < 11) {
        lastDay = helpers.Time.MakeDateFromParts(year, month + 1);
      } else {
        lastDay = helpers.Time.MakeDateFromParts(year + 1, 0);
      }
      lastDay = helpers.Days.AddToDate(lastDay, -1);
      while (lastDay.getUTCDay() !== dayIndex) {
        lastDay = helpers.Days.AddToDate(lastDay, -1);
      }
      return lastDay.getUTCDate();
    }
  };

  Milliseconds = {
    inDay: 86400000,
    inHour: 3600000,
    inMinute: 60000,
    inSecond: 1000
  };

  Time = {
    Add: function(dt, hours, mins, secs) {
      var newTs;
      if (hours == null) {
        hours = 0;
      }
      if (mins == null) {
        mins = 0;
      }
      if (secs == null) {
        secs = 0;
      }
      newTs = dt.getTime() + (hours * Milliseconds.inHour) + (mins * Milliseconds.inMinute) + (secs * Milliseconds.inSecond);
      return this.MakeDateFromTimeStamp(newTs);
    },
    ParseGMTOffset: function(str) {
      var isNeg, match, matches, reg, result;
      reg = new RegExp("(-)?([0-9]*):([0-9]*):?([0-9]*)?");
      matches = reg.exec(str);
      result = matches ? (function() {
        var _i, _len, _ref, _results;
        _ref = matches.slice(2);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          match = _ref[_i];
          _results.push(parseInt(match, 10));
        }
        return _results;
      })() : [0, 0, 0];
      isNeg = matches && matches[1] === "-";
      result.splice(0, 0, isNeg);
      return result;
    },
    ParseTime: function(str) {
      var match, matches, qual, reg, timeParts;
      reg = new RegExp("(\\d*)\\:(\\d*)([wsugz]?)");
      matches = reg.exec(str);
      if (!matches) {
        return [0, 0, ''];
      }
      timeParts = (function() {
        var _i, _len, _ref, _results;
        _ref = matches.slice(1, 3);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          match = _ref[_i];
          _results.push(parseInt(match, 10));
        }
        return _results;
      })();
      qual = matches[3] ? matches[3] : '';
      timeParts.push(qual);
      return timeParts;
    },
    ApplyOffset: function(dt, offset, reverse) {
      var offset_ms;
      offset_ms = (Milliseconds.inHour * offset.hours) + (Milliseconds.inMinute * offset.mins) + (Milliseconds.inSecond * offset.secs);
      if (!offset.negative) {
        offset_ms = offset_ms * -1;
      }
      if (reverse) {
        offset_ms = offset_ms * -1;
      }
      return this.MakeDateFromTimeStamp(dt.getTime() + offset_ms);
    },
    ApplySave: function(dt, save, reverse) {
      if (reverse !== true) {
        reverse = false;
      }
      return this.ApplyOffset(dt, {
        negative: true,
        hours: save.hours,
        mins: save.mins,
        secs: 0
      }, reverse);
    },
    UTCToWallTime: function(dt, offset, save) {
      var endTime;
      endTime = this.UTCToStandardTime(dt, offset);
      return this.ApplySave(endTime, save);
    },
    UTCToStandardTime: function(dt, offset) {
      return this.ApplyOffset(dt, offset, true);
    },
    UTCToQualifiedTime: function(dt, qualifier, offset, getSave) {
      var endTime;
      endTime = dt;
      switch (qualifier) {
        case "w":
          endTime = this.UTCToWallTime(endTime, offset, getSave());
          break;
        case "s":
          endTime = this.UTCToStandardTime(endTime, offset);
          break;
      }
      return endTime;
    },
    QualifiedTimeToUTC: function(dt, qualifier, offset, getSave) {
      var endTime;
      endTime = dt;
      switch (qualifier) {
        case "w":
          endTime = this.WallTimeToUTC(offset, getSave(), endTime);
          break;
        case "s":
          endTime = this.StandardTimeToUTC(offset, endTime);
          break;
      }
      return endTime;
    },
    StandardTimeToUTC: function(offset, y, m, d, h, mi, s, ms) {
      var dt;
      if (m == null) {
        m = 0;
      }
      if (d == null) {
        d = 1;
      }
      if (h == null) {
        h = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (s == null) {
        s = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      dt = typeof y === "number" ? this.MakeDateFromParts(y, m, d, h, mi, s, ms) : y;
      return this.ApplyOffset(dt, offset);
    },
    WallTimeToUTC: function(offset, save, y, m, d, h, mi, s, ms) {
      var dt;
      if (m == null) {
        m = 0;
      }
      if (d == null) {
        d = 1;
      }
      if (h == null) {
        h = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (s == null) {
        s = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      dt = this.StandardTimeToUTC(offset, y, m, d, h, mi, s, ms);
      return this.ApplySave(dt, save, true);
    },
    MakeDateFromParts: function(y, m, d, h, mi, s, ms) {
      var dt;
      if (m == null) {
        m = 0;
      }
      if (d == null) {
        d = 1;
      }
      if (h == null) {
        h = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (s == null) {
        s = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      if (Date.UTC) {
        return new Date(Date.UTC(y, m, d, h, mi, s, ms));
      }
      dt = new Date;
      dt.setUTCFullYear(y);
      dt.setUTCMonth(m);
      dt.setUTCDate(d);
      dt.setUTCHours(h);
      dt.setUTCMinutes(mi);
      dt.setUTCSeconds(s);
      dt.setUTCMilliseconds(ms);
      return dt;
    },
    LocalDate: function(offset, save, y, m, d, h, mi, s, ms) {
      if (m == null) {
        m = 0;
      }
      if (d == null) {
        d = 1;
      }
      if (h == null) {
        h = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (s == null) {
        s = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      return this.WallTimeToUTC(offset, save, y, m, d, h, mi, s, ms);
    },
    MakeDateFromTimeStamp: function(ts) {
      return new Date(ts);
    },
    MaxDate: function() {
      return this.MakeDateFromTimeStamp(10000000 * 86400000);
    },
    MinDate: function() {
      return this.MakeDateFromTimeStamp(-10000000 * 86400000);
    }
  };

  helpers = {
    Days: Days,
    Months: Months,
    Milliseconds: Milliseconds,
    Time: Time,
    noSave: {
      hours: 0,
      mins: 0
    },
    noZone: {
      offset: {
        negative: false,
        hours: 0,
        mins: 0,
        secs: 0
      },
      name: "UTC"
    }
  };

  this.WallTime || (this.WallTime = {});
  this.WallTime.helpers = helpers;

}).call(this);

(function() {
  var init, req_helpers;

  init = function(helpers) {
    var TimeZoneTime;
    TimeZoneTime = (function() {
      function TimeZoneTime(utc, zone, save) {
        this.utc = utc;
        this.zone = zone;
        this.save = save;
        this.offset = this.zone.offset;
        this.wallTime = helpers.Time.UTCToWallTime(this.utc, this.offset, this.save);
      }

      TimeZoneTime.prototype.getFullYear = function() {
        return this.wallTime.getUTCFullYear();
      };

      TimeZoneTime.prototype.getMonth = function() {
        return this.wallTime.getUTCMonth();
      };

      TimeZoneTime.prototype.getDate = function() {
        return this.wallTime.getUTCDate();
      };

      TimeZoneTime.prototype.getDay = function() {
        return this.wallTime.getUTCDay();
      };

      TimeZoneTime.prototype.getHours = function() {
        return this.wallTime.getUTCHours();
      };

      TimeZoneTime.prototype.getMinutes = function() {
        return this.wallTime.getUTCMinutes();
      };

      TimeZoneTime.prototype.getSeconds = function() {
        return this.wallTime.getUTCSeconds();
      };

      TimeZoneTime.prototype.getMilliseconds = function() {
        return this.wallTime.getUTCMilliseconds();
      };

      TimeZoneTime.prototype.getUTCFullYear = function() {
        return this.utc.getUTCFullYear();
      };

      TimeZoneTime.prototype.getUTCMonth = function() {
        return this.utc.getUTCMonth();
      };

      TimeZoneTime.prototype.getUTCDate = function() {
        return this.utc.getUTCDate();
      };

      TimeZoneTime.prototype.getUTCDay = function() {
        return this.utc.getUTCDay();
      };

      TimeZoneTime.prototype.getUTCHours = function() {
        return this.utc.getUTCHours();
      };

      TimeZoneTime.prototype.getUTCMinutes = function() {
        return this.utc.getUTCMinutes();
      };

      TimeZoneTime.prototype.getUTCSeconds = function() {
        return this.utc.getUTCSeconds();
      };

      TimeZoneTime.prototype.getUTCMilliseconds = function() {
        return this.utc.getUTCMilliseconds();
      };

      TimeZoneTime.prototype.getTime = function() {
        return this.utc.getTime();
      };

      TimeZoneTime.prototype.getTimezoneOffset = function() {
        var base, dst;
        base = (this.offset.hours * 60) + this.offset.mins;
        dst = (this.save.hours * 60) + this.save.mins;
        if (!this.offset.negative) {
          base = -base;
        }
        return base - dst;
      };

      TimeZoneTime.prototype.toISOString = function() {
        return this.utc.toISOString();
      };

      TimeZoneTime.prototype.toUTCString = function() {
        return this.wallTime.toUTCString();
      };

      TimeZoneTime.prototype.toDateString = function() {
        var caps, utcStr;
        utcStr = this.wallTime.toUTCString();
        caps = utcStr.match("([a-zA-Z]*), ([0-9]+) ([a-zA-Z]*) ([0-9]+)");
        return [caps[1], caps[3], caps[2], caps[4]].join(" ");
      };

      TimeZoneTime.prototype.toFormattedTime = function(use24HourTime) {
        var hour, meridiem, min, origHour;
        if (use24HourTime == null) {
          use24HourTime = false;
        }
        hour = origHour = this.getHours();
        if (hour > 12 && !use24HourTime) {
          hour -= 12;
        }
        if (hour === 0) {
          hour = 12;
        }
        min = this.getMinutes();
        if (min < 10) {
          min = "0" + min;
        }
        meridiem = origHour > 11 ? ' PM' : ' AM';
        if (use24HourTime) {
          meridiem = '';
        }
        return "" + hour + ":" + min + meridiem;
      };

      TimeZoneTime.prototype.setTime = function(ms) {
        this.wallTime = helpers.Time.UTCToWallTime(new Date(ms), this.zone.offset, this.save);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setFullYear = function(y) {
        this.wallTime.setUTCFullYear(y);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setMonth = function(m) {
        this.wallTime.setUTCMonth(m);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setDate = function(utcDate) {
        this.wallTime.setUTCDate(utcDate);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setHours = function(hours) {
        this.wallTime.setUTCHours(hours);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setMinutes = function(m) {
        this.wallTime.setUTCMinutes(m);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setSeconds = function(s) {
        this.wallTime.setUTCSeconds(s);
        return this._updateUTC();
      };

      TimeZoneTime.prototype.setMilliseconds = function(ms) {
        this.wallTime.setUTCMilliseconds(ms);
        return this._updateUTC();
      };

      TimeZoneTime.prototype._updateUTC = function() {
        this.utc = helpers.Time.WallTimeToUTC(this.offset, this.save, this.getFullYear(), this.getMonth(), this.getDate(), this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds());
        return this.utc.getTime();
      };

      return TimeZoneTime;

    })();
    return TimeZoneTime;
  };

  this.WallTime || (this.WallTime = {});
  this.WallTime.TimeZoneTime = init(this.WallTime.helpers);

}).call(this);

(function() {
  var init, req_TimeZoneTime, req_helpers,
    __hasProp = {}.hasOwnProperty;

  init = function(helpers, TimeZoneTime) {
    var CompareOnFieldHandler, LastOnFieldHandler, NumberOnFieldHandler, Rule, RuleSet, lib;
    NumberOnFieldHandler = (function() {
      function NumberOnFieldHandler() {}

      NumberOnFieldHandler.prototype.applies = function(str) {
        return !isNaN(parseInt(str, 10));
      };

      NumberOnFieldHandler.prototype.parseDate = function(str) {
        return parseInt(str, 10);
      };

      return NumberOnFieldHandler;

    })();
    LastOnFieldHandler = (function() {
      function LastOnFieldHandler() {}

      LastOnFieldHandler.prototype.applies = helpers.Months.IsLastDayOfMonthRule;

      LastOnFieldHandler.prototype.parseDate = function(str, year, month, qualifier, gmtOffset, daylightOffset) {
        return helpers.Months.LastDayOfMonthRule(str, year, month);
      };

      return LastOnFieldHandler;

    })();
    CompareOnFieldHandler = (function() {
      function CompareOnFieldHandler() {}

      CompareOnFieldHandler.prototype.applies = helpers.Months.IsDayOfMonthRule;

      CompareOnFieldHandler.prototype.parseDate = function(str, year, month) {
        return helpers.Months.DayOfMonthByRule(str, year, month);
      };

      return CompareOnFieldHandler;

    })();
    Rule = (function() {
      function Rule(name, _from, _to, type, _in, on, at, _save, letter) {
        var saveHour, saveMinute, toYear, _ref;
        this.name = name;
        this._from = _from;
        this._to = _to;
        this.type = type;
        this["in"] = _in;
        this.on = on;
        this.at = at;
        this._save = _save;
        this.letter = letter;
        this.from = parseInt(this._from, 10);
        this.isMax = false;
        toYear = this.from;
        switch (this._to) {
          case "max":
            toYear = (helpers.Time.MaxDate()).getUTCFullYear();
            this.isMax = true;
            break;
          case "only":
            toYear = this.from;
            break;
          default:
            toYear = parseInt(this._to, 10);
        }
        this.to = toYear;
        _ref = this._parseTime(this._save), saveHour = _ref[0], saveMinute = _ref[1];
        this.save = {
          hours: saveHour,
          mins: saveMinute
        };
      }

      Rule.prototype.forZone = function(offset) {
        this.offset = offset;
        this.fromUTC = helpers.Time.MakeDateFromParts(this.from, 0, 1, 0, 0, 0);
        this.fromUTC = helpers.Time.ApplyOffset(this.fromUTC, offset);
        this.toUTC = helpers.Time.MakeDateFromParts(this.to, 11, 31, 23, 59, 59, 999);
        return this.toUTC = helpers.Time.ApplyOffset(this.toUTC, offset);
      };

      Rule.prototype.setOnUTC = function(year, offset, getPrevSave) {
        var atQualifier, onParsed, toDay, toHour, toMinute, toMonth, _ref,
          _this = this;
        toMonth = helpers.Months.MonthIndex(this["in"]);
        onParsed = parseInt(this.on, 10);
        toDay = !isNaN(onParsed) ? onParsed : this._parseOnDay(this.on, year, toMonth);
        _ref = this._parseTime(this.at), toHour = _ref[0], toMinute = _ref[1], atQualifier = _ref[2];
        this.onUTC = helpers.Time.MakeDateFromParts(year, toMonth, toDay, toHour, toMinute);
        this.onUTC.setUTCMilliseconds(this.onUTC.getUTCMilliseconds() - 1);
        this.atQualifier = atQualifier !== '' ? atQualifier : "w";
        this.onUTC = helpers.Time.QualifiedTimeToUTC(this.onUTC, this.atQualifier, offset, function() {
          return getPrevSave(_this);
        });
        return this.onSort = "" + toMonth + "-" + toDay + "-" + (this.onUTC.getUTCHours()) + "-" + (this.onUTC.getUTCMinutes());
      };

      Rule.prototype.appliesToUTC = function(dt) {
        return (this.fromUTC <= dt && dt <= this.toUTC);
      };

      Rule.prototype._parseOnDay = function(onStr, year, month) {
        var handler, handlers, _i, _len;
        handlers = [new NumberOnFieldHandler, new LastOnFieldHandler, new CompareOnFieldHandler];
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          if (!handler.applies(onStr)) {
            continue;
          }
          return handler.parseDate(onStr, year, month);
        }
        throw new Error("Unable to parse 'on' field for " + this.name + "|" + this._from + "|" + this._to + "|" + onStr);
      };

      Rule.prototype._parseTime = function(atStr) {
        return helpers.Time.ParseTime(atStr);
      };

      return Rule;

    })();
    RuleSet = (function() {
      function RuleSet(rules, timeZone) {
        var beginYears, commonUpdateYearEnds, endYears, max, min, rule, _i, _len, _ref,
          _this = this;
        this.rules = rules != null ? rules : [];
        this.timeZone = timeZone;
        min = null;
        max = null;
        endYears = {};
        beginYears = {};
        _ref = this.rules;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rule = _ref[_i];
          rule.forZone(this.timeZone.offset, function() {
            return helpers.noSave;
          });
          if (min === null || rule.from < min) {
            min = rule.from;
          }
          if (max === null || rule.to > max) {
            max = rule.to;
          }
          endYears[rule.to] = endYears[rule.to] || [];
          endYears[rule.to].push(rule);
          beginYears[rule.from] = beginYears[rule.from] || [];
          beginYears[rule.from].push(rule);
        }
        this.minYear = min;
        this.maxYear = max;
        commonUpdateYearEnds = function(end, years) {
          var lastRule, year, yearRules, _results;
          if (end == null) {
            end = "toUTC";
          }
          if (years == null) {
            years = endYears;
          }
          _results = [];
          for (year in years) {
            if (!__hasProp.call(years, year)) continue;
            rules = years[year];
            yearRules = _this.allThatAppliesTo(rules[0][end]);
            if (yearRules.length < 1) {
              continue;
            }
            rules = _this._sortRulesByOnTime(rules);
            lastRule = yearRules.slice(-1)[0];
            if (lastRule.save.hours === 0 && lastRule.save.mins === 0) {
              continue;
            }
            _results.push((function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
                rule = rules[_j];
                _results1.push(rule[end] = helpers.Time.ApplySave(rule[end], lastRule.save));
              }
              return _results1;
            })());
          }
          return _results;
        };
        commonUpdateYearEnds("toUTC", endYears);
        commonUpdateYearEnds("fromUTC", beginYears);
      }

      RuleSet.prototype.allThatAppliesTo = function(dt) {
        var rule, _i, _len, _ref, _results;
        _ref = this.rules;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rule = _ref[_i];
          if (rule.appliesToUTC(dt)) {
            _results.push(rule);
          }
        }
        return _results;
      };

      RuleSet.prototype.getWallTimeForUTC = function(dt) {
        var appliedRules, getPrevRuleSave, lastSave, rule, rules, _i, _len;
        rules = this.allThatAppliesTo(dt);
        if (rules.length < 1) {
          return new TimeZoneTime(dt, this.timeZone, helpers.noSave);
        }
        rules = this._sortRulesByOnTime(rules);
        getPrevRuleSave = function(r) {
          var idx;
          idx = rules.indexOf(r);
          if (idx < 1) {
            if (rules.length < 1) {
              return helpers.noSave;
            }
            return rules.slice(-1)[0].save;
          }
          return rules[idx - 1].save;
        };
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          rule.setOnUTC(dt.getUTCFullYear(), this.timeZone.offset, getPrevRuleSave);
        }
        appliedRules = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
            rule = rules[_j];
            if (rule.onUTC.getTime() < dt.getTime()) {
              _results.push(rule);
            }
          }
          return _results;
        })();
        lastSave = rules.length < 1 ? helpers.noSave : rules.slice(-1)[0].save;
        if (appliedRules.length > 0) {
          lastSave = appliedRules.slice(-1)[0].save;
        }
        return new TimeZoneTime(dt, this.timeZone, lastSave);
      };

      RuleSet.prototype.getUTCForWallTime = function(dt) {
        var appliedRules, getPrevRuleSave, lastSave, rule, rules, utcStd, _i, _len;
        utcStd = helpers.Time.StandardTimeToUTC(this.timeZone.offset, dt);
        rules = (function() {
          var _i, _len, _ref, _results;
          _ref = this.rules;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rule = _ref[_i];
            if (rule.appliesToUTC(utcStd)) {
              _results.push(rule);
            }
          }
          return _results;
        }).call(this);
        if (rules.length < 1) {
          return utcStd;
        }
        rules = this._sortRulesByOnTime(rules);
        getPrevRuleSave = function(r) {
          var idx;
          idx = rules.indexOf(r);
          if (idx < 1) {
            if (rules.length < 1) {
              return helpers.noSave;
            }
            return rules.slice(-1)[0].save;
          }
          return rules[idx - 1].save;
        };
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          rule.setOnUTC(utcStd.getUTCFullYear(), this.timeZone.offset, getPrevRuleSave);
        }
        appliedRules = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
            rule = rules[_j];
            if (rule.onUTC.getTime() < utcStd.getTime()) {
              _results.push(rule);
            }
          }
          return _results;
        })();
        lastSave = rules.length < 1 ? helpers.noSave : rules.slice(-1)[0].save;
        if (appliedRules.length > 0) {
          lastSave = appliedRules.slice(-1)[0].save;
        }
        return helpers.Time.WallTimeToUTC(this.timeZone.offset, lastSave, dt);
      };

      RuleSet.prototype.getYearEndDST = function(dt) {
        var appliedRules, getPrevRuleSave, lastSave, rule, rules, utcStd, year, _i, _len;
        year = typeof dt === number ? dt : dt.getUTCFullYear();
        utcStd = helpers.Time.StandardTimeToUTC(this.timeZone.offset, year, 11, 31, 23, 59, 59);
        rules = (function() {
          var _i, _len, _ref, _results;
          _ref = this.rules;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rule = _ref[_i];
            if (rule.appliesToUTC(utcStd)) {
              _results.push(rule);
            }
          }
          return _results;
        }).call(this);
        if (rules.length < 1) {
          return helpers.noSave;
        }
        rules = this._sortRulesByOnTime(rules);
        getPrevRuleSave = function(r) {
          var idx;
          idx = rules.indexOf(r);
          if (idx < 1) {
            return helpers.noSave;
          }
          return rules[idx - 1].save;
        };
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          rule.setOnUTC(utcStd.getUTCFullYear(), this.timeZone.offset, getPrevRuleSave);
        }
        appliedRules = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
            rule = rules[_j];
            if (rule.onUTC.getTime() < utcStd.getTime()) {
              _results.push(rule);
            }
          }
          return _results;
        })();
        lastSave = helpers.noSave;
        if (appliedRules.length > 0) {
          lastSave = appliedRules.slice(-1)[0].save;
        }
        return lastSave;
      };

      RuleSet.prototype.isAmbiguous = function(dt) {
        var appliedRules, getPrevRuleSave, lastRule, makeAmbigRange, minsOff, prevSave, range, rule, rules, springForward, totalMinutes, utcStd, _i, _len;
        utcStd = helpers.Time.StandardTimeToUTC(this.timeZone.offset, dt);
        rules = (function() {
          var _i, _len, _ref, _results;
          _ref = this.rules;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rule = _ref[_i];
            if (rule.appliesToUTC(utcStd)) {
              _results.push(rule);
            }
          }
          return _results;
        }).call(this);
        if (rules.length < 1) {
          return false;
        }
        rules = this._sortRulesByOnTime(rules);
        getPrevRuleSave = function(r) {
          var idx;
          idx = rules.indexOf(r);
          if (idx < 1) {
            return helpers.noSave;
          }
          return rules[idx - 1].save;
        };
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i];
          rule.setOnUTC(utcStd.getUTCFullYear(), this.timeZone.offset, getPrevRuleSave);
        }
        appliedRules = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = rules.length; _j < _len1; _j++) {
            rule = rules[_j];
            if (rule.onUTC.getTime() <= utcStd.getTime() - 1) {
              _results.push(rule);
            }
          }
          return _results;
        })();
        if (appliedRules.length < 1) {
          return false;
        }
        lastRule = appliedRules.slice(-1)[0];
        prevSave = getPrevRuleSave(lastRule);
        totalMinutes = {
          prev: (prevSave.hours * 60) + prevSave.mins,
          last: (lastRule.save.hours * 60) + lastRule.save.mins
        };
        if (totalMinutes.prev === totalMinutes.last) {
          return false;
        }
        springForward = totalMinutes.prev < totalMinutes.last;
        makeAmbigRange = function(begin, minutesOff) {
          var ambigRange, tmp;
          ambigRange = {
            begin: helpers.Time.MakeDateFromTimeStamp(begin.getTime() + 1)
          };
          ambigRange.end = helpers.Time.Add(ambigRange.begin, 0, minutesOff);
          if (ambigRange.begin.getTime() > ambigRange.end.getTime()) {
            tmp = ambigRange.begin;
            ambigRange.begin = ambigRange.end;
            ambigRange.end = tmp;
          }
          return ambigRange;
        };
        minsOff = springForward ? totalMinutes.last : -totalMinutes.prev;
        range = makeAmbigRange(lastRule.onUTC, minsOff);
        utcStd = helpers.Time.WallTimeToUTC(this.timeZone.offset, prevSave, dt);
        return (range.begin <= utcStd && utcStd <= range.end);
      };

      RuleSet.prototype._sortRulesByOnTime = function(rules) {
        return rules.sort(function(a, b) {
          return (helpers.Months.MonthIndex(a["in"])) - (helpers.Months.MonthIndex(b["in"]));
        });
      };

      return RuleSet;

    })();
    lib = {
      Rule: Rule,
      RuleSet: RuleSet,
      OnFieldHandlers: {
        NumberHandler: NumberOnFieldHandler,
        LastHandler: LastOnFieldHandler,
        CompareHandler: CompareOnFieldHandler
      }
    };
    return lib;
  };

  this.WallTime || (this.WallTime = {});
  this.WallTime.rule = init(this.WallTime.helpers, this.WallTime.TimeZoneTime);

}).call(this);

(function() {
  var init, req_TimeZoneTime, req_helpers, req_rule;

  init = function(helpers, rule, TimeZoneTime) {
    var Zone, ZoneSet, lib;
    Zone = (function() {
      function Zone(name, _offset, _rule, format, _until, currZone) {
        var begin, isNegative, offsetHours, offsetMins, offsetSecs, _ref;
        this.name = name;
        this._offset = _offset;
        this._rule = _rule;
        this.format = format;
        this._until = _until;
        _ref = helpers.Time.ParseGMTOffset(this._offset), isNegative = _ref[0], offsetHours = _ref[1], offsetMins = _ref[2], offsetSecs = _ref[3];
        this.offset = {
          negative: isNegative,
          hours: offsetHours,
          mins: offsetMins,
          secs: isNaN(offsetSecs) ? 0 : offsetSecs
        };
        begin = currZone ? helpers.Time.MakeDateFromTimeStamp(currZone.range.end.getTime() + 1) : helpers.Time.MinDate();
        this.range = {
          begin: begin,
          end: this._parseUntilDate(this._until)
        };
      }

      Zone.prototype._parseUntilDate = function(til) {
        var day, endTime, h, mi, month, monthName, neg, s, standardTime, time, year, _ref, _ref1;
        _ref = til.split(" "), year = _ref[0], monthName = _ref[1], day = _ref[2], time = _ref[3];
        _ref1 = time ? helpers.Time.ParseGMTOffset(time) : [false, 0, 0, 0], neg = _ref1[0], h = _ref1[1], mi = _ref1[2], s = _ref1[3];
        s = isNaN(s) ? 0 : s;
        if (!year || year === "") {
          return helpers.Time.MaxDate();
        }
        year = parseInt(year, 10);
        month = monthName ? helpers.Months.MonthIndex(monthName) : 0;
        day || (day = "1");
        if (helpers.Months.IsDayOfMonthRule(day)) {
          day = helpers.Months.DayOfMonthByRule(day, year, month);
        } else if (helpers.Months.IsLastDayOfMonthRule(day)) {
          day = helpers.Months.LastDayOfMonthRule(day, year, month);
        } else {
          day = parseInt(day, 10);
        }
        standardTime = helpers.Time.StandardTimeToUTC(this.offset, year, month, day, h, mi, s);
        endTime = helpers.Time.MakeDateFromTimeStamp(standardTime.getTime() - 1);
        return endTime;
      };

      Zone.prototype.updateEndForRules = function(getRulesNamed) {
        var endSave, hours, mins, rules, _ref;
        if (this._rule === "-" || this._rule === "") {
          return;
        }
        if (this._rule.indexOf(":") >= 0) {
          _ref = helpers.Time.ParseTime(this._rule), hours = _ref[0], mins = _ref[1];
          this.range.end = helpers.Time.ApplySave(this.range.end, {
            hours: hours,
            mins: mins
          });
        }
        rules = new rule.RuleSet(getRulesNamed(this._rule), this);
        endSave = rules.getYearEndDST(this.range.end);
        return this.range.end = helpers.Time.ApplySave(this.range.end, endSave);
      };

      Zone.prototype.UTCToWallTime = function(dt, getRulesNamed) {
        var hours, mins, rules, _ref;
        if (this._rule === "-" || this._rule === "") {
          return new TimeZoneTime(dt, this, helpers.noSave);
        }
        if (this._rule.indexOf(":") >= 0) {
          _ref = helpers.Time.ParseTime(this._rule), hours = _ref[0], mins = _ref[1];
          return new TimeZoneTime(dt, this, {
            hours: hours,
            mins: mins
          });
        }
        rules = new rule.RuleSet(getRulesNamed(this._rule), this);
        return rules.getWallTimeForUTC(dt);
      };

      Zone.prototype.WallTimeToUTC = function(dt, getRulesNamed) {
        var hours, mins, rules, _ref;
        if (this._rule === "-" || this._rule === "") {
          return helpers.Time.StandardTimeToUTC(this.offset, dt);
        }
        if (this._rule.indexOf(":") >= 0) {
          _ref = helpers.Time.ParseTime(this._rule), hours = _ref[0], mins = _ref[1];
          return helpers.Time.WallTimeToUTC(this.offset, {
            hours: hours,
            mins: mins
          }, dt);
        }
        rules = new rule.RuleSet(getRulesNamed(this._rule), this);
        return rules.getUTCForWallTime(dt, this.offset);
      };

      Zone.prototype.IsAmbiguous = function(dt, getRulesNamed) {
        var ambigCheck, hours, makeAmbigZone, mins, rules, utcDt, _ref, _ref1, _ref2;
        if (this._rule === "-" || this._rule === "") {
          return false;
        }
        if (this._rule.indexOf(":") >= 0) {
          utcDt = helpers.Time.StandardTimeToUTC(this.offset, dt);
          _ref = helpers.Time.ParseTime(this._rule), hours = _ref[0], mins = _ref[1];
          makeAmbigZone = function(begin) {
            var ambigZone, tmp;
            ambigZone = {
              begin: this.range.begin,
              end: helpers.Time.ApplySave(this.range.begin, {
                hours: hours,
                mins: mins
              })
            };
            if (ambigZone.end.getTime() < ambigZone.begin.getTime()) {
              tmp = ambigZone.begin;
              ambigZone.begin = ambigZone.end;
              ambigZone.end = tmp;
            }
            return ambigZone;
          };
          ambigCheck = makeAmbigZone(this.range.begin);
          if ((ambigCheck.begin.getTime() <= (_ref1 = utcDt.getTime()) && _ref1 < ambigCheck.end.getTime())) {
            return true;
          }
          ambigCheck = makeAmbigZone(this.range.end);
          (ambigCheck.begin.getTime() <= (_ref2 = utcDt.getTime()) && _ref2 < ambigCheck.end.getTime());
        }
        rules = new rule.RuleSet(getRulesNamed(this._rule), this);
        return rules.isAmbiguous(dt, this.offset);
      };

      return Zone;

    })();
    ZoneSet = (function() {
      function ZoneSet(zones, getRulesNamed) {
        var zone, _i, _len, _ref;
        this.zones = zones != null ? zones : [];
        this.getRulesNamed = getRulesNamed;
        if (this.zones.length > 0) {
          this.name = this.zones[0].name;
        } else {
          this.name = "";
        }
        _ref = this.zones;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          zone = _ref[_i];
          zone.updateEndForRules;
        }
      }

      ZoneSet.prototype.add = function(zone) {
        if (this.zones.length === 0 && this.name === "") {
          this.name = zone.name;
        }
        if (this.name !== zone.name) {
          throw new Error("Cannot add different named zones to a ZoneSet");
        }
        return this.zones.push(zone);
      };

      ZoneSet.prototype.findApplicable = function(dt, useOffset) {
        var findOffsetRange, found, range, ts, zone, _i, _len, _ref;
        if (useOffset == null) {
          useOffset = false;
        }
        ts = dt.getTime();
        findOffsetRange = function(zone) {
          return {
            begin: helpers.Time.UTCToStandardTime(zone.range.begin, zone.offset),
            end: helpers.Time.UTCToStandardTime(zone.range.end, zone.offset)
          };
        };
        found = null;
        _ref = this.zones;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          zone = _ref[_i];
          range = !useOffset ? zone.range : findOffsetRange(zone);
          if ((range.begin.getTime() <= ts && ts <= range.end.getTime())) {
            found = zone;
            break;
          }
        }
        return found;
      };

      ZoneSet.prototype.getWallTimeForUTC = function(dt) {
        var applicable;
        applicable = this.findApplicable(dt);
        if (!applicable) {
          return new TimeZoneTime(dt, helpers.noZone, helpers.noSave);
        }
        return applicable.UTCToWallTime(dt, this.getRulesNamed);
      };

      ZoneSet.prototype.getUTCForWallTime = function(dt) {
        var applicable;
        applicable = this.findApplicable(dt, true);
        if (!applicable) {
          return dt;
        }
        return applicable.WallTimeToUTC(dt, this.getRulesNamed);
      };

      ZoneSet.prototype.isAmbiguous = function(dt) {
        var applicable;
        applicable = this.findApplicable(dt, true);
        if (!applicable) {
          return false;
        }
        return applicable.IsAmbiguous(dt, this.getRulesNamed);
      };

      return ZoneSet;

    })();
    return lib = {
      Zone: Zone,
      ZoneSet: ZoneSet
    };
  };

  this.WallTime || (this.WallTime = {});
  this.WallTime.zone = init(this.WallTime.helpers, this.WallTime.rule, this.WallTime.TimeZoneTime);

}).call(this);

(function() {
  var api, init, key, req_help, req_rule, req_zone, val, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty;

  init = function(helpers, rule, zone) {
    var WallTime;
    WallTime = (function() {
      function WallTime() {}

      WallTime.prototype.init = function(rules, zones) {
        if (rules == null) {
          rules = {};
        }
        if (zones == null) {
          zones = {};
        }
        this.zones = {};
        this.rules = {};
        this.addRulesZones(rules, zones);
        this.zoneSet = null;
        this.timeZoneName = null;
        return this.doneInit = true;
      };

      WallTime.prototype.addRulesZones = function(rules, zones) {
        var currZone, newRules, newZone, newZones, r, ruleName, ruleVals, z, zoneName, zoneVals, _i, _len, _results;
        if (rules == null) {
          rules = {};
        }
        if (zones == null) {
          zones = {};
        }
        currZone = null;
        for (zoneName in zones) {
          if (!__hasProp.call(zones, zoneName)) continue;
          zoneVals = zones[zoneName];
          newZones = [];
          currZone = null;
          for (_i = 0, _len = zoneVals.length; _i < _len; _i++) {
            z = zoneVals[_i];
            newZone = new zone.Zone(z.name, z._offset, z._rule, z.format, z._until, currZone);
            newZones.push(newZone);
            currZone = newZone;
          }
          this.zones[zoneName] = newZones;
        }
        _results = [];
        for (ruleName in rules) {
          if (!__hasProp.call(rules, ruleName)) continue;
          ruleVals = rules[ruleName];
          newRules = (function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = ruleVals.length; _j < _len1; _j++) {
              r = ruleVals[_j];
              _results1.push(new rule.Rule(r.name, r._from, r._to, r.type, r["in"], r.on, r.at, r._save, r.letter));
            }
            return _results1;
          })();
          _results.push(this.rules[ruleName] = newRules);
        }
        return _results;
      };

      WallTime.prototype.setTimeZone = function(name) {
        var matches,
          _this = this;
        if (!this.doneInit) {
          throw new Error("Must call init with rules and zones before setting time zone");
        }
        if (!this.zones[name]) {
          throw new Error("Unable to find time zone named " + (name || '<blank>'));
        }
        matches = this.zones[name];
        this.zoneSet = new zone.ZoneSet(matches, function(ruleName) {
          return _this.rules[ruleName];
        });
        return this.timeZoneName = name;
      };

      WallTime.prototype.Date = function(y, m, d, h, mi, s, ms) {
        if (m == null) {
          m = 0;
        }
        if (d == null) {
          d = 1;
        }
        if (h == null) {
          h = 0;
        }
        if (mi == null) {
          mi = 0;
        }
        if (s == null) {
          s = 0;
        }
        if (ms == null) {
          ms = 0;
        }
        y || (y = new Date().getUTCFullYear());
        return helpers.Time.MakeDateFromParts(y, m, d, h, mi, s, ms);
      };

      WallTime.prototype.UTCToWallTime = function(dt, zoneName) {
        if (zoneName == null) {
          zoneName = this.timeZoneName;
        }
        if (typeof dt === "number") {
          dt = new Date(dt);
        }
        if (zoneName !== this.timeZoneName) {
          this.setTimeZone(zoneName);
        }
        if (!this.zoneSet) {
          throw new Error("Must set the time zone before converting times");
        }
        return this.zoneSet.getWallTimeForUTC(dt);
      };

      WallTime.prototype.WallTimeToUTC = function(zoneName, y, m, d, h, mi, s, ms) {
        var wallTime;
        if (zoneName == null) {
          zoneName = this.timeZoneName;
        }
        if (m == null) {
          m = 0;
        }
        if (d == null) {
          d = 1;
        }
        if (h == null) {
          h = 0;
        }
        if (mi == null) {
          mi = 0;
        }
        if (s == null) {
          s = 0;
        }
        if (ms == null) {
          ms = 0;
        }
        if (zoneName !== this.timeZoneName) {
          this.setTimeZone(zoneName);
        }
        wallTime = typeof y === "number" ? helpers.Time.MakeDateFromParts(y, m, d, h, mi, s, ms) : y;
        return this.zoneSet.getUTCForWallTime(wallTime);
      };

      WallTime.prototype.IsAmbiguous = function(zoneName, y, m, d, h, mi) {
        var wallTime;
        if (zoneName == null) {
          zoneName = this.timeZoneName;
        }
        if (mi == null) {
          mi = 0;
        }
        if (zoneName !== this.timeZoneName) {
          this.setTimeZone(zoneName);
        }
        wallTime = typeof y === "number" ? helpers.Time.MakeDateFromParts(y, m, d, h, mi) : y;
        return this.zoneSet.isAmbiguous(wallTime);
      };

      return WallTime;

    })();
    return new WallTime;
  };

  this.WallTime || (this.WallTime = {});
  api = init(this.WallTime.helpers, this.WallTime.rule, this.WallTime.zone);
  _ref = this.WallTime;
  for (key in _ref) {
    if (!__hasProp.call(_ref, key)) continue;
    val = _ref[key];
    api[key] = val;
  }
  this.WallTime = api;
  if (this.WallTime.autoinit && ((_ref1 = this.WallTime.data) != null ? _ref1.rules : void 0) && ((_ref2 = this.WallTime.data) != null ? _ref2.zones : void 0)) {
    this.WallTime.init(this.WallTime.data.rules, this.WallTime.data.zones);
  }

}).call(this);

exports.WallTime = this.WallTime;

},{}]},{},[1])(1)
});